<!DOCTYPE html>
<!-- saved from url=(0072)https://github.com/wishyouhappy/Algorithm#98-validate-binary-search-tree -->
<html lang="en" class=" is-copy-enabled"><head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb# object: http://ogp.me/ns/object# article: http://ogp.me/ns/article# profile: http://ogp.me/ns/profile#"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="Content-Language" content="en">
    <meta name="viewport" content="width=1020">
    
    
    <title>wishyouhappy/Algorithm</title>
    <link rel="search" type="application/opensearchdescription+xml" href="https://github.com/opensearch.xml" title="GitHub">
    <link rel="fluid-icon" href="https://github.com/fluidicon.png" title="GitHub">
    <link rel="apple-touch-icon" sizes="57x57" href="https://github.com/apple-touch-icon-114.png">
    <link rel="apple-touch-icon" sizes="114x114" href="https://github.com/apple-touch-icon-114.png">
    <link rel="apple-touch-icon" sizes="72x72" href="https://github.com/apple-touch-icon-144.png">
    <link rel="apple-touch-icon" sizes="144x144" href="https://github.com/apple-touch-icon-144.png">
    <meta property="fb:app_id" content="1401488693436528">

      <meta content="@github" name="twitter:site"><meta content="summary" name="twitter:card"><meta content="wishyouhappy/Algorithm" name="twitter:title"><meta content="Algorithm - problems solutions and detail in java, c++, python" name="twitter:description"><meta content="https://avatars1.githubusercontent.com/u/6973513?v=3&amp;s=400" name="twitter:image:src">
      <meta content="GitHub" property="og:site_name"><meta content="object" property="og:type"><meta content="https://avatars1.githubusercontent.com/u/6973513?v=3&amp;s=400" property="og:image"><meta content="wishyouhappy/Algorithm" property="og:title"><meta content="https://github.com/wishyouhappy/Algorithm" property="og:url"><meta content="Algorithm - problems solutions and detail in java, c++, python" property="og:description">
      <meta name="browser-stats-url" content="https://api.github.com/_private/browser/stats">
    <meta name="browser-errors-url" content="https://api.github.com/_private/browser/errors">
    <link rel="assets" href="https://assets-cdn.github.com/">
    <link rel="web-socket" href="wss://live.github.com/_sockets/ODg5MzI4NDo0M2YzMGFkNjc4ZWRkMTlmZmRjYjU1ZGJlY2Q1YzAwODowYzU2MzZkMDYzNzMxZGMxMTliZTgzY2Q3YTMzZmRjYWY2NzExMDA3ZGE1YTcyMzNhYWQ4N2Y5NzNlYmU1Mzkw--585d3540ded46fbbcc32184a40333a257190f631">
    <meta name="pjax-timeout" content="1000">
    <link rel="sudo-modal" href="https://github.com/sessions/sudo_modal">

    <meta name="msapplication-TileImage" content="/windows-tile.png">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="selected-link" value="repo_source" data-pjax-transient="">

        <meta name="google-analytics" content="UA-3769691-2">

    <meta content="collector.githubapp.com" name="octolytics-host"><meta content="collector-cdn.github.com" name="octolytics-script-host"><meta content="github" name="octolytics-app-id"><meta content="4469A80F:65B9:7565E91:55C00280" name="octolytics-dimension-request_id"><meta content="8893284" name="octolytics-actor-id"><meta content="zzoeliu" name="octolytics-actor-login"><meta content="2671fd79ee34955ea3e129ff8b651653c60cf33e31e8aa14723c797154c14201" name="octolytics-actor-hash">
    
    <meta content="Rails, view, files#disambiguate" data-pjax-transient="true" name="analytics-event">
    <meta class="js-ga-set" name="dimension1" content="Logged In">
      <meta class="js-ga-set" name="dimension4" content="Current repo nav">
    <meta name="is-dotcom" content="true">
        <meta name="hostname" content="github.com">
    <meta name="user-login" content="zzoeliu">

      <link rel="icon" sizes="any" mask="" href="https://assets-cdn.github.com/pinned-octocat.svg">
      <meta name="theme-color" content="#4078c0">
      <link rel="icon" type="image/x-icon" href="https://assets-cdn.github.com/favicon.ico">

    <!-- </textarea> --><!-- '"` --><meta content="authenticity_token" name="csrf-param">
<meta content="uEJxSGi/hvD4V1JO1BjpYKRFgeDydXmuGXpZ99Bqk87IIhR4YJ9CONSzdKARX7Qw1Qwi4haAC9/Oqy9c8tha0w==" name="csrf-token">
    

    <link crossorigin="anonymous" href="https://assets-cdn.github.com/assets/github/index-c7126cd67871e693a9f863b7a0e99879ca39079b15a8784f8b543c03bf14ad72.css" media="all" rel="stylesheet">
    <link crossorigin="anonymous" href="https://assets-cdn.github.com/assets/github2/index-87247f16e6450ef54cb0eda3f8f1484e33a3f18c7a7d3df1f76f67cba36a8d6d.css" media="all" rel="stylesheet">
    
    


    <meta http-equiv="x-pjax-version" content="5d3cb7c96fe3e48c3c2703bd7d16a1c1">

      
  <meta name="description" content="Algorithm - problems solutions and detail in java, c++, python">
  <meta name="go-import" content="github.com/wishyouhappy/Algorithm git https://github.com/wishyouhappy/Algorithm.git">

  <meta content="6973513" name="octolytics-dimension-user_id"><meta content="wishyouhappy" name="octolytics-dimension-user_login"><meta content="30830334" name="octolytics-dimension-repository_id"><meta content="wishyouhappy/Algorithm" name="octolytics-dimension-repository_nwo"><meta content="true" name="octolytics-dimension-repository_public"><meta content="false" name="octolytics-dimension-repository_is_fork"><meta content="30830334" name="octolytics-dimension-repository_network_root_id"><meta content="wishyouhappy/Algorithm" name="octolytics-dimension-repository_network_root_nwo">
  <link href="https://github.com/wishyouhappy/Algorithm/commits/master.atom" rel="alternate" title="Recent Commits to Algorithm:master" type="application/atom+xml">

  <script type="text/javascript" async="" src="./wishyouhappy_Algorithm_files/api.js"></script><style id="style-1-cropbar-clipper">/* Copyright 2014 Evernote Corporation. All rights reserved. */
.en-markup-crop-options {
    top: 18px !important;
    left: 50% !important;
    margin-left: -100px !important;
    width: 200px !important;
    border: 2px rgba(255,255,255,.38) solid !important;
    border-radius: 4px !important;
}

.en-markup-crop-options div div:first-of-type {
    margin-left: 0px !important;
}
</style></head>


  <body class="logged_in  env-production macintosh vis-public" data-pinterest-extension-installed="cr1.38.2">
    <a href="https://github.com/wishyouhappy/Algorithm#start-of-content" tabindex="1" class="accessibility-aid js-skip-to-content">Skip to content</a>
    <div class="wrapper">
      
      
      



        <div class="header header-logged-in true" role="banner">
  <div class="container clearfix">

    <a class="header-logo-invertocat" href="https://github.com/" data-hotkey="g d" aria-label="Homepage" data-ga-click="Header, go to dashboard, icon:logo">
  <span class="mega-octicon octicon-mark-github"></span>
</a>


      <div class="site-search repo-scope js-site-search" role="search">
          <!-- </textarea> --><!-- '"` --><form accept-charset="UTF-8" action="https://github.com/wishyouhappy/Algorithm/search" class="js-site-search-form" data-global-search-url="/search" data-repo-search-url="/wishyouhappy/Algorithm/search" method="get"><div style="margin:0;padding:0;display:inline"><input name="utf8" type="hidden" value="✓"></div>
  <label class="js-chromeless-input-container form-control">
    <div class="scope-badge">This repository</div>
    <input type="text" class="js-site-search-focus js-site-search-field is-clearable chromeless-input" data-hotkey="s" name="q" placeholder="Search" aria-label="Search this repository" data-global-scope-placeholder="Search GitHub" data-repo-scope-placeholder="Search" tabindex="1" autocapitalize="off">
  </label>
</form>
      </div>

      <ul class="header-nav left" role="navigation">
        <li class="header-nav-item">
          <a href="https://github.com/pulls" class="js-selected-navigation-item header-nav-link" data-ga-click="Header, click, Nav menu - item:pulls context:user" data-hotkey="g p" data-selected-links="/pulls /pulls/assigned /pulls/mentioned /pulls">
            Pull requests
</a>        </li>
        <li class="header-nav-item">
          <a href="https://github.com/issues" class="js-selected-navigation-item header-nav-link" data-ga-click="Header, click, Nav menu - item:issues context:user" data-hotkey="g i" data-selected-links="/issues /issues/assigned /issues/mentioned /issues">
            Issues
</a>        </li>
          <li class="header-nav-item">
            <a class="header-nav-link" href="https://gist.github.com/" data-ga-click="Header, go to gist, text:gist">Gist</a>
          </li>
      </ul>

    
<ul class="header-nav user-nav right" id="user-links">
  <li class="header-nav-item">
      <span class="js-socket-channel js-updatable-content" data-channel="notification-changed:zzoeliu" data-url="/notifications/header">
      <a href="https://github.com/notifications" aria-label="You have no unread notifications" class="header-nav-link notification-indicator tooltipped tooltipped-s" data-ga-click="Header, go to notifications, icon:read" data-hotkey="g n">
          <span class="mail-status all-read"></span>
          <span class="octicon octicon-inbox"></span>
</a>  </span>

  </li>

  <li class="header-nav-item dropdown js-menu-container">
    <a class="header-nav-link tooltipped tooltipped-s js-menu-target" href="https://github.com/new" aria-label="Create new…" data-ga-click="Header, create new, icon:add">
      <span class="octicon octicon-plus left"></span>
      <span class="dropdown-caret"></span>
    </a>

    <div class="dropdown-menu-content js-menu-content">
      <ul class="dropdown-menu dropdown-menu-sw">
        
<a class="dropdown-item" href="https://github.com/new" data-ga-click="Header, create new repository">
  New repository
</a>


  <a class="dropdown-item" href="https://github.com/organizations/new" data-ga-click="Header, create new organization">
    New organization
  </a>



  <div class="dropdown-divider"></div>
  <div class="dropdown-header">
    <span title="wishyouhappy/Algorithm">This repository</span>
  </div>
    <a class="dropdown-item" href="https://github.com/wishyouhappy/Algorithm/issues/new" data-ga-click="Header, create new issue">
      New issue
    </a>

      </ul>
    </div>
  </li>

  <li class="header-nav-item dropdown js-menu-container">
    <a class="header-nav-link name tooltipped tooltipped-s js-menu-target" href="https://github.com/zzoeliu" aria-label="View profile and more" data-ga-click="Header, show menu, icon:avatar">
      <img alt="@zzoeliu" class="avatar" height="20" src="./wishyouhappy_Algorithm_files/8893284" width="20">
      <span class="dropdown-caret"></span>
    </a>

    <div class="dropdown-menu-content js-menu-content">
      <div class="dropdown-menu dropdown-menu-sw">
        <div class="dropdown-header header-nav-current-user css-truncate">
          Signed in as <strong class="css-truncate-target">zzoeliu</strong>
        </div>
        <div class="dropdown-divider"></div>

        <a class="dropdown-item" href="https://github.com/zzoeliu" data-ga-click="Header, go to profile, text:your profile">
          Your profile
        </a>
        <a class="dropdown-item" href="https://github.com/stars" data-ga-click="Header, go to starred repos, text:your stars">
          Your stars
        </a>
        <a class="dropdown-item" href="https://github.com/explore" data-ga-click="Header, go to explore, text:explore">
          Explore
        </a>
        <a class="dropdown-item" href="https://help.github.com/" data-ga-click="Header, go to help, text:help">
          Help
        </a>
        <div class="dropdown-divider"></div>

        <a class="dropdown-item" href="https://github.com/settings/profile" data-ga-click="Header, go to settings, icon:settings">
          Settings
        </a>

        <!-- </textarea> --><!-- '"` --><form accept-charset="UTF-8" action="https://github.com/logout" class="logout-form" data-form-nonce="f7e732608c521a1efc3bf3e423a2e9558a764919" method="post"><div style="margin:0;padding:0;display:inline"><input name="utf8" type="hidden" value="✓"><input name="authenticity_token" type="hidden" value="TzdYm4DvSeCLTDnIrLn0O18TdfxJLp3hBoH1QwGVVlRb/qtWhUelPmAAepjgC7goDbYhp6tu7XH/C0DGtXExzA=="></div>
          <button class="dropdown-item dropdown-signout" data-ga-click="Header, sign out, icon:logout">
            Sign out
          </button>
</form>      </div>
    </div>
  </li>
</ul>


    
  </div>
</div>

        

        


      <div id="start-of-content" class="accessibility-aid"></div>
          <div class="site" itemscope="" itemtype="http://schema.org/WebPage">
    <div id="js-flash-container">
      
    </div>
    <div class="pagehead repohead instapaper_ignore readability-menu ">
      <div class="container">

        <div class="clearfix">
          
<ul class="pagehead-actions">

  <li>
      <!-- </textarea> --><!-- '"` --><form accept-charset="UTF-8" action="https://github.com/notifications/subscribe" class="js-social-container" data-autosubmit="true" data-form-nonce="f7e732608c521a1efc3bf3e423a2e9558a764919" data-remote="true" method="post"><div style="margin:0;padding:0;display:inline"><input name="utf8" type="hidden" value="✓"><input name="authenticity_token" type="hidden" value="Go1cGTnrFM5xgPb5p2/X7UGoUbhjLbBb0WJUeaeRXFnue5DfZWZOi/Qr3HhfSUsKwN9R5ra9JuJ6uEF3bnZ94w=="></div>    <input id="repository_id" name="repository_id" type="hidden" value="30830334">

      <div class="select-menu js-menu-container js-select-menu">
        <a href="https://github.com/wishyouhappy/Algorithm/subscription" class="btn btn-sm btn-with-count select-menu-button js-menu-target" role="button" tabindex="0" aria-haspopup="true" data-ga-click="Repository, click Watch settings, action:files#disambiguate">
          <span class="js-select-button">
            <span class="octicon octicon-eye"></span>
            Watch
          </span>
        </a>
        <a class="social-count js-social-count" href="https://github.com/wishyouhappy/Algorithm/watchers">
          2
        </a>

        <div class="select-menu-modal-holder">
          <div class="select-menu-modal subscription-menu-modal js-menu-content" aria-hidden="true">
            <div class="select-menu-header">
              <span class="select-menu-title">Notifications</span>
              <span class="octicon octicon-x js-menu-close" role="button" aria-label="Close"></span>
            </div>

            <div class="select-menu-list js-navigation-container" role="menu">

              <div class="select-menu-item js-navigation-item selected" role="menuitem" tabindex="0">
                <span class="select-menu-item-icon octicon octicon-check"></span>
                <div class="select-menu-item-text">
                  <input checked="checked" id="do_included" name="do" type="radio" value="included">
                  <span class="select-menu-item-heading">Not watching</span>
                  <span class="description">Be notified when participating or @mentioned.</span>
                  <span class="js-select-button-text hidden-select-button-text">
                    <span class="octicon octicon-eye"></span>
                    Watch
                  </span>
                </div>
              </div>

              <div class="select-menu-item js-navigation-item " role="menuitem" tabindex="0">
                <span class="select-menu-item-icon octicon octicon octicon-check"></span>
                <div class="select-menu-item-text">
                  <input id="do_subscribed" name="do" type="radio" value="subscribed">
                  <span class="select-menu-item-heading">Watching</span>
                  <span class="description">Be notified of all conversations.</span>
                  <span class="js-select-button-text hidden-select-button-text">
                    <span class="octicon octicon-eye"></span>
                    Unwatch
                  </span>
                </div>
              </div>

              <div class="select-menu-item js-navigation-item " role="menuitem" tabindex="0">
                <span class="select-menu-item-icon octicon octicon-check"></span>
                <div class="select-menu-item-text">
                  <input id="do_ignore" name="do" type="radio" value="ignore">
                  <span class="select-menu-item-heading">Ignoring</span>
                  <span class="description">Never be notified.</span>
                  <span class="js-select-button-text hidden-select-button-text">
                    <span class="octicon octicon-mute"></span>
                    Stop ignoring
                  </span>
                </div>
              </div>

            </div>

          </div>
        </div>
      </div>
</form>
  </li>

  <li>
    
  <div class="js-toggler-container js-social-container starring-container ">

    <!-- </textarea> --><!-- '"` --><form accept-charset="UTF-8" action="https://github.com/wishyouhappy/Algorithm/unstar" class="js-toggler-form starred js-unstar-button" data-form-nonce="f7e732608c521a1efc3bf3e423a2e9558a764919" data-remote="true" method="post"><div style="margin:0;padding:0;display:inline"><input name="utf8" type="hidden" value="✓"><input name="authenticity_token" type="hidden" value="X8bYTomI4ab96J1B1gH01mvZsNQnqVaoO4zur5GEssvLt9SJS+cPAJr2637EfAbC4ijN43acAPbjpD7S7qjM8A=="></div>
      <button class="btn btn-sm btn-with-count js-toggler-target" aria-label="Unstar this repository" title="Unstar wishyouhappy/Algorithm" data-ga-click="Repository, click unstar button, action:files#disambiguate; text:Unstar">
        <span class="octicon octicon-star"></span>
        Unstar
      </button>
        <a class="social-count js-social-count" href="https://github.com/wishyouhappy/Algorithm/stargazers">
          1
        </a>
</form>
    <!-- </textarea> --><!-- '"` --><form accept-charset="UTF-8" action="https://github.com/wishyouhappy/Algorithm/star" class="js-toggler-form unstarred js-star-button" data-form-nonce="f7e732608c521a1efc3bf3e423a2e9558a764919" data-remote="true" method="post"><div style="margin:0;padding:0;display:inline"><input name="utf8" type="hidden" value="✓"><input name="authenticity_token" type="hidden" value="rgP95uvohpwOI9auRF58bVduwKdxKUNB0VHzUL/f9gReg6lg5p6mE3UrRb+IxkmPzhEP1gdY32S3xTdo07qoTw=="></div>
      <button class="btn btn-sm btn-with-count js-toggler-target" aria-label="Star this repository" title="Star wishyouhappy/Algorithm" data-ga-click="Repository, click star button, action:files#disambiguate; text:Star">
        <span class="octicon octicon-star"></span>
        Star
      </button>
        <a class="social-count js-social-count" href="https://github.com/wishyouhappy/Algorithm/stargazers">
          1
        </a>
</form>  </div>

  </li>

        <li>
          <!-- </textarea> --><!-- '"` --><form accept-charset="UTF-8" action="https://github.com/wishyouhappy/Algorithm/fork" data-form-nonce="f7e732608c521a1efc3bf3e423a2e9558a764919" method="post"><div style="margin:0;padding:0;display:inline"><input name="utf8" type="hidden" value="✓"><input name="authenticity_token" type="hidden" value="JUT+kOzefG14/a85FT/EaLZJHOLFWmvwUg5O2WHkw+zPBwFnmScgXGrBQWIUE8+V+NPO7e0gea8Up/YNOYg2qw=="></div>
            <button type="submit" class="btn btn-sm btn-with-count" data-ga-click="Repository, show fork modal, action:files#disambiguate; text:Fork" title="Fork your own copy of wishyouhappy/Algorithm to your account" aria-label="Fork your own copy of wishyouhappy/Algorithm to your account">
              <span class="octicon octicon-repo-forked"></span>
              Fork
            </button>
            <a href="https://github.com/wishyouhappy/Algorithm/network" class="social-count">0</a>
</form>        </li>

</ul>

          <h1 itemscope="" itemtype="http://data-vocabulary.org/Breadcrumb" class="entry-title public ">
            <span class="mega-octicon octicon-repo"></span>
            <span class="author"><a href="https://github.com/wishyouhappy" class="url fn" itemprop="url" rel="author"><span itemprop="title">wishyouhappy</span></a></span><!--
         --><span class="path-divider">/</span><!--
         --><strong><a href="https://github.com/wishyouhappy/Algorithm" data-pjax="#js-repo-pjax-container">Algorithm</a></strong>

            <span class="page-context-loader">
              <img alt="" height="16" src="./wishyouhappy_Algorithm_files/octocat-spinner-32.gif" width="16">
            </span>

          </h1>
        </div>

      </div>
    </div>

      <div class="container">
        <div class="repository-with-sidebar repo-container new-discussion-timeline with-full-navigation">
          <div class="repository-sidebar clearfix">
              

<nav class="sunken-menu repo-nav js-repo-nav js-sidenav-container-pjax js-octicon-loaders" role="navigation" data-pjax="#js-repo-pjax-container" data-issue-count-url="/wishyouhappy/Algorithm/issues/counts">
  <ul class="sunken-menu-group">
    <li class="tooltipped tooltipped-w" aria-label="Code">
      <a href="https://github.com/wishyouhappy/Algorithm" aria-label="Code" aria-selected="true" class="js-selected-navigation-item selected sunken-menu-item" data-hotkey="g c" data-selected-links="repo_source repo_downloads repo_commits repo_releases repo_tags repo_branches /wishyouhappy/Algorithm">
        <span class="octicon octicon-code"></span> <span class="full-word">Code</span>
        <img alt="" class="mini-loader" height="16" src="./wishyouhappy_Algorithm_files/octocat-spinner-32.gif" width="16">
</a>    </li>

      <li class="tooltipped tooltipped-w" aria-label="Issues">
        <a href="https://github.com/wishyouhappy/Algorithm/issues" aria-label="Issues" class="js-selected-navigation-item sunken-menu-item" data-hotkey="g i" data-selected-links="repo_issues repo_labels repo_milestones /wishyouhappy/Algorithm/issues">
          <span class="octicon octicon-issue-opened"></span> <span class="full-word">Issues</span>
          <span class="counter">0</span>

          <img alt="" class="mini-loader" height="16" src="./wishyouhappy_Algorithm_files/octocat-spinner-32.gif" width="16">
</a>      </li>

    <li class="tooltipped tooltipped-w" aria-label="Pull requests">
      <a href="https://github.com/wishyouhappy/Algorithm/pulls" aria-label="Pull requests" class="js-selected-navigation-item sunken-menu-item" data-hotkey="g p" data-selected-links="repo_pulls /wishyouhappy/Algorithm/pulls">
          <span class="octicon octicon-git-pull-request"></span> <span class="full-word">Pull requests</span>
          <span class="counter">0</span>

          <img alt="" class="mini-loader" height="16" src="./wishyouhappy_Algorithm_files/octocat-spinner-32.gif" width="16">
</a>    </li>

      <li class="tooltipped tooltipped-w" aria-label="Wiki">
        <a href="https://github.com/wishyouhappy/Algorithm/wiki" aria-label="Wiki" class="js-selected-navigation-item sunken-menu-item" data-hotkey="g w" data-selected-links="repo_wiki /wishyouhappy/Algorithm/wiki">
          <span class="octicon octicon-book"></span> <span class="full-word">Wiki</span>
          <img alt="" class="mini-loader" height="16" src="./wishyouhappy_Algorithm_files/octocat-spinner-32.gif" width="16">
</a>      </li>
  </ul>
  <div class="sunken-menu-separator"></div>
  <ul class="sunken-menu-group">

    <li class="tooltipped tooltipped-w" aria-label="Pulse">
      <a href="https://github.com/wishyouhappy/Algorithm/pulse" aria-label="Pulse" class="js-selected-navigation-item sunken-menu-item" data-selected-links="pulse /wishyouhappy/Algorithm/pulse">
        <span class="octicon octicon-pulse"></span> <span class="full-word">Pulse</span>
        <img alt="" class="mini-loader" height="16" src="./wishyouhappy_Algorithm_files/octocat-spinner-32.gif" width="16">
</a>    </li>

    <li class="tooltipped tooltipped-w" aria-label="Graphs">
      <a href="https://github.com/wishyouhappy/Algorithm/graphs" aria-label="Graphs" class="js-selected-navigation-item sunken-menu-item" data-selected-links="repo_graphs repo_contributors /wishyouhappy/Algorithm/graphs">
        <span class="octicon octicon-graph"></span> <span class="full-word">Graphs</span>
        <img alt="" class="mini-loader" height="16" src="./wishyouhappy_Algorithm_files/octocat-spinner-32.gif" width="16">
</a>    </li>
  </ul>


</nav>

                <div class="only-with-full-nav">
                    
<div class="js-clone-url clone-url open" data-protocol-type="http">
  <h3><span class="text-emphasized">HTTPS</span> clone URL</h3>
  <div class="input-group js-zeroclipboard-container">
    <input type="text" class="input-mini input-monospace js-url-field js-zeroclipboard-target" value="https://github.com/wishyouhappy/Algorithm.git" readonly="readonly" aria-label="HTTPS clone URL">
    <span class="input-group-button">
      <button aria-label="Copy to clipboard" class="js-zeroclipboard btn btn-sm zeroclipboard-button tooltipped tooltipped-s" data-copied-hint="Copied!" type="button"><span class="octicon octicon-clippy"></span></button>
    </span>
  </div>
</div>

  
<div class="js-clone-url clone-url " data-protocol-type="ssh">
  <h3><span class="text-emphasized">SSH</span> clone URL</h3>
  <div class="input-group js-zeroclipboard-container">
    <input type="text" class="input-mini input-monospace js-url-field js-zeroclipboard-target" value="git@github.com:wishyouhappy/Algorithm.git" readonly="readonly" aria-label="SSH clone URL">
    <span class="input-group-button">
      <button aria-label="Copy to clipboard" class="js-zeroclipboard btn btn-sm zeroclipboard-button tooltipped tooltipped-s" data-copied-hint="Copied!" type="button"><span class="octicon octicon-clippy"></span></button>
    </span>
  </div>
</div>

  
<div class="js-clone-url clone-url " data-protocol-type="subversion">
  <h3><span class="text-emphasized">Subversion</span> checkout URL</h3>
  <div class="input-group js-zeroclipboard-container">
    <input type="text" class="input-mini input-monospace js-url-field js-zeroclipboard-target" value="https://github.com/wishyouhappy/Algorithm" readonly="readonly" aria-label="Subversion checkout URL">
    <span class="input-group-button">
      <button aria-label="Copy to clipboard" class="js-zeroclipboard btn btn-sm zeroclipboard-button tooltipped tooltipped-s" data-copied-hint="Copied!" type="button"><span class="octicon octicon-clippy"></span></button>
    </span>
  </div>
</div>



  <div class="clone-options">You can clone with
    <!-- </textarea> --><!-- '"` --><form accept-charset="UTF-8" action="https://github.com/users/set_protocol?protocol_selector=http&protocol_type=clone" class="inline-form js-clone-selector-form is-enabled" data-form-nonce="f7e732608c521a1efc3bf3e423a2e9558a764919" data-remote="true" method="post"><div style="margin:0;padding:0;display:inline"><input name="utf8" type="hidden" value="✓"><input name="authenticity_token" type="hidden" value="XX4Z2F4f4MA9+kyEixxpHTV4iGBRIJFa32wOvRkIsrDsPXYMCbKTpoPryPvA5NU/RLaTVrcT5AIr5ZVQlaSlhQ=="></div><button class="btn-link js-clone-selector" data-protocol="http" type="submit">HTTPS</button></form>, <!-- </textarea> --><!-- '"` --><form accept-charset="UTF-8" action="https://github.com/users/set_protocol?protocol_selector=ssh&protocol_type=clone" class="inline-form js-clone-selector-form is-enabled" data-form-nonce="f7e732608c521a1efc3bf3e423a2e9558a764919" data-remote="true" method="post"><div style="margin:0;padding:0;display:inline"><input name="utf8" type="hidden" value="✓"><input name="authenticity_token" type="hidden" value="4aO94Jsh7y7h0ryPAOmY1mYWiLbP5EgKZ1n+lq/2AlpSLUXHCEobH4FtkMxt5s8+B1BeUQfnOEf2GX+sAzATeg=="></div><button class="btn-link js-clone-selector" data-protocol="ssh" type="submit">SSH</button></form>, or <!-- </textarea> --><!-- '"` --><form accept-charset="UTF-8" action="https://github.com/users/set_protocol?protocol_selector=subversion&protocol_type=clone" class="inline-form js-clone-selector-form is-enabled" data-form-nonce="f7e732608c521a1efc3bf3e423a2e9558a764919" data-remote="true" method="post"><div style="margin:0;padding:0;display:inline"><input name="utf8" type="hidden" value="✓"><input name="authenticity_token" type="hidden" value="z42cj0YlOATNRojUIzwc6GA/Jn+1CCp+1TAp/WS3csqk7AGWhfY0uw9w4LMGZAn68rajeuDnfd4/LbsDXKu63w=="></div><button class="btn-link js-clone-selector" data-protocol="subversion" type="submit">Subversion</button></form>.
    <a href="https://help.github.com/articles/which-remote-url-should-i-use" class="help tooltipped tooltipped-n" aria-label="Get help on which URL is right for you.">
      <span class="octicon octicon-question"></span>
    </a>
  </div>
    <a href="https://mac.github.com/" class="btn btn-sm sidebar-button" title="Save wishyouhappy/Algorithm to your computer and use it in GitHub Desktop." aria-label="Save wishyouhappy/Algorithm to your computer and use it in GitHub Desktop.">
      <span class="octicon octicon-device-desktop"></span>
      Clone in Desktop
    </a>

                  <a href="https://github.com/wishyouhappy/Algorithm/archive/master.zip" class="btn btn-sm sidebar-button" aria-label="Download the contents of wishyouhappy/Algorithm as a zip file" title="Download the contents of wishyouhappy/Algorithm as a zip file" rel="nofollow">
                    <span class="octicon octicon-cloud-download"></span>
                    Download ZIP
                  </a>
                </div>
          </div>
          <div id="js-repo-pjax-container" class="repository-content context-loader-container" data-pjax-container="">

            
<span id="js-show-full-navigation"></span>

  <div class="repository-meta js-details-container ">
    <div class="repository-description">
      problems solutions and detail in java, c++, python
    </div>


</div>


<div class="overall-summary overall-summary-bottomless">

  <div class="stats-switcher-viewport js-stats-switcher-viewport">
    <div class="stats-switcher-wrapper">
    <ul class="numbers-summary">
      <li class="commits">
        <a data-pjax="" href="https://github.com/wishyouhappy/Algorithm/commits/master">
            <span class="octicon octicon-history"></span>
            <span class="num text-emphasized">
              188
            </span>
            commits
        </a>
      </li>
      <li>
        <a data-pjax="" href="https://github.com/wishyouhappy/Algorithm/branches">
          <span class="octicon octicon-git-branch"></span>
          <span class="num text-emphasized">
            1
          </span>
          branch
        </a>
      </li>

      <li>
        <a data-pjax="" href="https://github.com/wishyouhappy/Algorithm/releases">
          <span class="octicon octicon-tag"></span>
          <span class="num text-emphasized">
            0
          </span>
          releases
        </a>
      </li>

      <li>
        
  <a href="https://github.com/wishyouhappy/Algorithm/graphs/contributors">
    <span class="octicon octicon-organization"></span>
    <span class="num text-emphasized">
      2
    </span>
    contributors
  </a>
      </li>
    </ul>

      <div class="repository-lang-stats">
        <ol class="repository-lang-stats-numbers">
          <li>
              <a href="https://github.com/wishyouhappy/Algorithm/search?l=java">
                <span class="color-block language-color" style="background-color:#b07219;"></span>
                <span class="lang">Java</span>
                <span class="percent">96.6%</span>
              </a>
          </li>
          <li>
              <a href="https://github.com/wishyouhappy/Algorithm/search?l=python">
                <span class="color-block language-color" style="background-color:#3572A5;"></span>
                <span class="lang">Python</span>
                <span class="percent">2.2%</span>
              </a>
          </li>
          <li>
              <a href="https://github.com/wishyouhappy/Algorithm/search?l=cpp">
                <span class="color-block language-color" style="background-color:#f34b7d;"></span>
                <span class="lang">C++</span>
                <span class="percent">1.1%</span>
              </a>
          </li>
          <li>
              <a href="https://github.com/wishyouhappy/Algorithm/search?l=c">
                <span class="color-block language-color" style="background-color:#555555;"></span>
                <span class="lang">C</span>
                <span class="percent">0.1%</span>
              </a>
          </li>
        </ol>
      </div>
    </div>
  </div>

</div>

  <div class="repository-lang-stats-graph js-toggle-lang-stats" title="Click for language details">
    <span class="language-color" aria-label="Java 96.6%" style="width:96.6%; background-color:#b07219;" itemprop="keywords">Java</span>
    <span class="language-color" aria-label="Python 2.2%" style="width:2.2%; background-color:#3572A5;" itemprop="keywords">Python</span>
    <span class="language-color" aria-label="C++ 1.1%" style="width:1.1%; background-color:#f34b7d;" itemprop="keywords">C++</span>
    <span class="language-color" aria-label="C 0.1%" style="width:0.1%; background-color:#555555;" itemprop="keywords">C</span>
  </div>



  <div class="file-navigation in-mid-page">
  <a href="https://github.com/wishyouhappy/Algorithm/find/master" class="js-show-file-finder btn btn-sm empty-icon tooltipped tooltipped-s right" data-pjax="" data-hotkey="t" aria-label="Quickly jump between files" data-ga-click="Repository, find file, location:repo overview">
    <span class="octicon octicon-list-unordered"></span>
  </a>
    <a href="https://github.com/wishyouhappy/Algorithm/compare" aria-label="Compare, review, create a pull request" class="btn btn-sm btn-primary tooltipped tooltipped-se left compare-button" data-pjax="" data-ga-click="Repository, go to compare view, location:repo overview; icon:git-compare">
      <span class="octicon octicon-git-compare"></span>
    </a>

  
<div class="select-menu js-menu-container js-select-menu left">
  <span class="btn btn-sm select-menu-button js-menu-target css-truncate" data-hotkey="w" data-ref="master" title="master" role="button" aria-label="Switch branches or tags" tabindex="0" aria-haspopup="true">
    <i>Branch:</i>
    <span class="js-select-button css-truncate-target">master</span>
  </span>

  <div class="select-menu-modal-holder js-menu-content js-navigation-container" data-pjax="" aria-hidden="true">

    <div class="select-menu-modal">
      <div class="select-menu-header">
        <span class="select-menu-title">Switch branches/tags</span>
        <span class="octicon octicon-x js-menu-close" role="button" aria-label="Close"></span>
      </div>

      <div class="select-menu-filters">
        <div class="select-menu-text-filter">
          <input type="text" aria-label="Filter branches/tags" id="context-commitish-filter-field" class="js-filterable-field js-navigation-enable" placeholder="Filter branches/tags">
        </div>
        <div class="select-menu-tabs">
          <ul>
            <li class="select-menu-tab">
              <a href="https://github.com/wishyouhappy/Algorithm#" data-tab-filter="branches" data-filter-placeholder="Filter branches/tags" class="js-select-menu-tab" role="tab">Branches</a>
            </li>
            <li class="select-menu-tab">
              <a href="https://github.com/wishyouhappy/Algorithm#" data-tab-filter="tags" data-filter-placeholder="Find a tag…" class="js-select-menu-tab" role="tab">Tags</a>
            </li>
          </ul>
        </div>
      </div>

      <div class="select-menu-list select-menu-tab-bucket js-select-menu-tab-bucket" data-tab-filter="branches" role="menu">

        <div data-filterable-for="context-commitish-filter-field" data-filterable-type="substring">


            <a class="select-menu-item js-navigation-item js-navigation-open selected" href="https://github.com/wishyouhappy/Algorithm/tree/master" data-name="master" data-skip-pjax="true" rel="nofollow">
              <span class="select-menu-item-icon octicon octicon-check"></span>
              <span class="select-menu-item-text css-truncate-target" title="master">
                master
              </span>
            </a>
        </div>

          <div class="select-menu-no-results">Nothing to show</div>
      </div>

      <div class="select-menu-list select-menu-tab-bucket js-select-menu-tab-bucket" data-tab-filter="tags">
        <div data-filterable-for="context-commitish-filter-field" data-filterable-type="substring">


        </div>

        <div class="select-menu-no-results">Nothing to show</div>
      </div>

    </div>
  </div>
</div>


  <div class="breadcrumb"><span class="repo-root js-repo-root"><span itemscope="" itemtype="http://data-vocabulary.org/Breadcrumb"><a href="https://github.com/wishyouhappy/Algorithm" class="" data-branch="master" data-pjax="true" itemscope="url"><span itemprop="title">Algorithm</span></a></span></span><span class="separator">/</span>
    <!-- </textarea> --><!-- '"` --><form accept-charset="UTF-8" action="https://github.com/wishyouhappy/Algorithm/new/master" class="js-new-blob-form inline-form" data-form-nonce="f7e732608c521a1efc3bf3e423a2e9558a764919" method="post"><div style="margin:0;padding:0;display:inline"><input name="utf8" type="hidden" value="✓"><input name="authenticity_token" type="hidden" value="3X318sddT2NogMUdvdPkg8Mrpz7UqqCTlKsrau29/s4Cr+/gBiCRMYiR2UDZnPfRA3GP0smG8lnC2jjrmJ0Oyg=="></div>
      <button class="btn-link tooltipped tooltipped-e" type="submit" data-disable-with="working…" aria-label="Fork this project and create a new file">
        <span class="js-new-blob-submit octicon octicon-plus"></span>
      </button>
</form></div>
</div>





  <div class="commit commit-tease js-details-container">
    <p class="commit-title ">
        <a href="https://github.com/wishyouhappy/Algorithm/commit/b9b8af3bc58b140f6178933412498012af4b88a4" class="message" data-pjax="true" title="Valid anagram">Valid anagram</a>
        
    </p>
    <div class="commit-meta">
      <button aria-label="Copy SHA" class="js-zeroclipboard zeroclipboard-link tooltipped tooltipped-s" data-clipboard-text="b9b8af3bc58b140f6178933412498012af4b88a4" data-copied-hint="Copied!" type="button"><span class="octicon octicon-clippy"></span></button>
      <a href="https://github.com/wishyouhappy/Algorithm/commit/b9b8af3bc58b140f6178933412498012af4b88a4" class="sha-block" data-pjax="">latest commit <span class="sha">b9b8af3bc5</span></a>

      <div class="authorship">
        <img alt="@wishyouhappy" class="avatar" height="20" src="./wishyouhappy_Algorithm_files/6973513" width="20">
        <span class="author-name"><a href="https://github.com/wishyouhappy" rel="author">wishyouhappy</a></span>
        authored <time class="updated" datetime="2015-08-02T06:10:24Z" is="relative-time" title="Aug 2, 2015, 2:10 AM EDT">2 days ago</time>

      </div>
    </div>
  </div>


<div class="file-wrap">
  <a href="https://github.com/wishyouhappy/Algorithm/tree/b9b8af3bc58b140f6178933412498012af4b88a4" class="hidden js-permalink-shortcut" data-hotkey="y">Permalink</a>

  <table class="files" data-pjax="">


    <tbody>
      <tr class="warning include-fragment-error">
        <td class="icon"><span class="octicon octicon-alert"></span></td>
        <td class="content" colspan="3">Failed to load latest commit information.</td>
      </tr>

        <tr>
          <td class="icon">
            <span class="octicon octicon-file-directory"></span>
            <img alt="" class="spinner" height="16" src="./wishyouhappy_Algorithm_files/octocat-spinner-32.gif" width="16">
          </td>
          <td class="content">
            <span class="css-truncate css-truncate-target"><a href="https://github.com/wishyouhappy/Algorithm/tree/master/algorithms" class="js-directory-link" id="66270707424a729c3e557fceb03f45c9-7f7b7b7b3db719b3dee24cb1f3fe05f52c1ea668" title="algorithms">algorithms</a></span>
          </td>
          <td class="message">
            <span class="css-truncate css-truncate-target">
              <a href="https://github.com/wishyouhappy/Algorithm/commit/02bc2d247d3866766fd46a16fd081af9cb59c095" class="message" data-pjax="true" title="top k frequent words">top k frequent words</a>
            </span>
          </td>
          <td class="age">
            <span class="css-truncate css-truncate-target"><time datetime="2015-06-21T05:37:09Z" is="time-ago" title="Jun 21, 2015, 1:37 AM EDT">a month ago</time></span>
          </td>
        </tr>
        <tr>
          <td class="icon">
            <span class="octicon octicon-file-directory"></span>
            <img alt="" class="spinner" height="16" src="./wishyouhappy_Algorithm_files/octocat-spinner-32.gif" width="16">
          </td>
          <td class="content">
            <span class="css-truncate css-truncate-target"><a href="https://github.com/wishyouhappy/Algorithm/tree/master/datastructure" class="js-directory-link" id="8dc87745f885a4cc532acd7b15b8b5fe-92b5a254558c40fc696d22d4879f8f483c2cb68d" title="datastructure">datastructure</a></span>
          </td>
          <td class="message">
            <span class="css-truncate css-truncate-target">
              <a href="https://github.com/wishyouhappy/Algorithm/commit/8f5895ff498ba9d9a881c587954aa9c4581058a9" class="message" data-pjax="true" title="combine">combine</a>
            </span>
          </td>
          <td class="age">
            <span class="css-truncate css-truncate-target"><time datetime="2015-06-17T01:35:08Z" is="time-ago" title="Jun 16, 2015, 9:35 PM EDT">2 months ago</time></span>
          </td>
        </tr>
        <tr>
          <td class="icon">
            <span class="octicon octicon-file-directory"></span>
            <img alt="" class="spinner" height="16" src="./wishyouhappy_Algorithm_files/octocat-spinner-32.gif" width="16">
          </td>
          <td class="content">
            <span class="css-truncate css-truncate-target"><a href="https://github.com/wishyouhappy/Algorithm/tree/master/lc" class="js-directory-link" id="196accbcf32b0a8e6bef92e1a37d0fc0-2ebb949c94c3a0f51c632a383a372dbd181a6e48" title="lc">lc</a></span>
          </td>
          <td class="message">
            <span class="css-truncate css-truncate-target">
              <a href="https://github.com/wishyouhappy/Algorithm/commit/3c98acede86870a4917422c962b2b40ecb63f702" class="message" data-pjax="true" title="Merge k sorted array">Merge k sorted array</a>
            </span>
          </td>
          <td class="age">
            <span class="css-truncate css-truncate-target"><time datetime="2015-07-19T23:08:00Z" is="time-ago" title="Jul 19, 2015, 7:08 PM EDT">15 days ago</time></span>
          </td>
        </tr>
        <tr>
          <td class="icon">
            <span class="octicon octicon-file-directory"></span>
            <img alt="" class="spinner" height="16" src="./wishyouhappy_Algorithm_files/octocat-spinner-32.gif" width="16">
          </td>
          <td class="content">
            <span class="css-truncate css-truncate-target"><a href="https://github.com/wishyouhappy/Algorithm/tree/master/sort" class="js-directory-link" id="cadc8c8db42409733582cb3e2298ef87-80cdc61a4245c4ba3134edaaf946dd79aaa39b15" title="sort">sort</a></span>
          </td>
          <td class="message">
            <span class="css-truncate css-truncate-target">
              <a href="https://github.com/wishyouhappy/Algorithm/commit/8f5895ff498ba9d9a881c587954aa9c4581058a9" class="message" data-pjax="true" title="combine">combine</a>
            </span>
          </td>
          <td class="age">
            <span class="css-truncate css-truncate-target"><time datetime="2015-06-17T01:35:08Z" is="time-ago" title="Jun 16, 2015, 9:35 PM EDT">2 months ago</time></span>
          </td>
        </tr>
        <tr>
          <td class="icon">
            <span class="octicon octicon-file-text"></span>
            <img alt="" class="spinner" height="16" src="./wishyouhappy_Algorithm_files/octocat-spinner-32.gif" width="16">
          </td>
          <td class="content">
            <span class="css-truncate css-truncate-target"><a href="https://github.com/wishyouhappy/Algorithm/blob/master/README.md" class="js-directory-link" id="04c6e90faac2675aa89e2176d2eec7d8-cba17d807149ba9778d70ce4e1787ee1bd5082f8" title="README.md">README.md</a></span>
          </td>
          <td class="message">
            <span class="css-truncate css-truncate-target">
              <a href="https://github.com/wishyouhappy/Algorithm/commit/b9b8af3bc58b140f6178933412498012af4b88a4" class="message" data-pjax="true" title="Valid anagram">Valid anagram</a>
            </span>
          </td>
          <td class="age">
            <span class="css-truncate css-truncate-target"><time datetime="2015-08-02T06:10:24Z" is="time-ago" title="Aug 2, 2015, 2:10 AM EDT">2 days ago</time></span>
          </td>
        </tr>
        <tr>
          <td class="icon">
            <span class="octicon octicon-file-text"></span>
            <img alt="" class="spinner" height="16" src="./wishyouhappy_Algorithm_files/octocat-spinner-32.gif" width="16">
          </td>
          <td class="content">
            <span class="css-truncate css-truncate-target"><a href="https://github.com/wishyouhappy/Algorithm/blob/master/category.md" class="js-directory-link" id="3e69721a193c4a440e08a1dc438e9b91-450e568e4916ea4bf2cd757e235a31ac5a291a88" title="category.md">category.md</a></span>
          </td>
          <td class="message">
            <span class="css-truncate css-truncate-target">
              <a href="https://github.com/wishyouhappy/Algorithm/commit/cd1912eec521694e82b699132d8e421d2b8750e3" class="message" data-pjax="true" title="Longest substring without repeating characters">Longest substring without repeating characters</a>
            </span>
          </td>
          <td class="age">
            <span class="css-truncate css-truncate-target"><time datetime="2015-06-25T16:22:33Z" is="time-ago" title="Jun 25, 2015, 12:22 PM EDT">a month ago</time></span>
          </td>
        </tr>
    </tbody>
  </table>

</div>


  <div id="readme" class="boxed-group flush clearfix announce instapaper_body md">
    <h3>
      <span class="octicon octicon-book"></span>
      README.md
    </h3>

    <article class="markdown-body entry-content" itemprop="mainContentOfPage"><h3><a id="user-content-overview" class="anchor" href="https://github.com/wishyouhappy/Algorithm#overview" aria-hidden="true"><span class="octicon octicon-link"></span></a>Overview</h3>

<ul>
<li><a href="https://github.com/wishyouhappy/Algorithm#1-two-sum">1 Two Sum</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#2-add-two-numbers">2 Add Two Numbers</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#3-longest-substring-without-repeating-characters">3 Longest Substring without Repeating Characters</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#4-median-of-two-sorted-arrays">4 Median of Two Sorted Arrays</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#5-longest-palindromic-substring">5 Longest Palindromic Substring</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#6-zigzag-conversion">6 Zigzag Conversion</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#7-reverse-integer">7 Reverse Integer</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#8-string-to-integer-atoi">8 String to Integer atoi</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#9-palindrome-number">9 Palindrome Number</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#10-regular-expression-matching">10 Regular Expression Matching</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#11-container-with-most-water">11 Container with Most Water</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#12-integer-to-roman">12 Integer to Roman</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#13-roman-to-integer">13 Roman to Integer</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#14-longest-common-prefix">14 Longest Common Prefix</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#15-3sum">15 3Sum</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#16-3sum-closest">16 3Sum Closest</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#17-number-combinations-of-a-phone-number">17 Number Combinations of a Phone Number</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#18-4sum">18 4Sum</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#19-remove-nth-node-from-end-of-list">19 Remove Nth Node From End of List</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#20-valid-parentheses">20 Valid Parentheses</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#21-merge-two-sorted-lists">21 Merge Two Sorted Lists</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#22-generate-parentheses">22 Generate Parentheses</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#23-merge-k-sorted-lists">23 Merge k Sorted Lists</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#24-swap-nodes-in-pairs">24 Swap Nodes in Pairs</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#25-reverse-nodes-in-kgroup">25 Reverse Nodes in kGroup</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#26-remove-duplicates-from-sorted-array">26 Remove Duplicates from Sorted Array</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#27-remove-element">27 Remove Element</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#28-implement-strstr">28 Implement strStr</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#29-divide-two-integers">29 Divide Two Integers</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#30-substring-with-concatenation-of-all-words">30 Substring with Concatenation of All Words</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#31-next-permutation">31 Next Permutation</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#32-longest-valid-parentheses">32 Longest Valid Parentheses</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#33-search-in-rotated-sorted-array">33 Search in Rotated Sorted Array</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#34-search-for-a-range">34 Search for a Range</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#35-search-insert-position">35 Search Insert Position</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#36-valid-sudoku">36 Valid Sudoku</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#37-sudoku-solver">37 Sudoku Solver</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#38-count-and-say">38 Count and Say</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#39-combination-sum">39 Combination Sum</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#40-combination-sum-ii">40 Combination Sum II</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#41-first-missing-positive">41 First Missing Positive</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#42-trapping-rain-water">42 Trapping Rain Water</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#43-multiply-strings">43 Multiply Strings</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#44-wildcard-matching">44 Wildcard Matching</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#45-jump-game-ii">45 Jump Game II</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#46-permutations">46 Permutations</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#47-permutations-ii">47 Permutations II</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#48-rotate-image">48 Rotate Image</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#49-anagrams">49 Anagrams</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#50-pow">50 Pow</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#51-n-queens">51 N Queens</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#52-n-queens-ii">52 N Queens II</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#53-maximum-subarray">53 Maximum Subarray</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#54-spiral-matrix">54 Spiral Matrix</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#55-jump-game">55 Jump Game</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#56-merge-intervals">56 Merge Intervals</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#57-insert-interval">57 Insert Interval</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#58-length-of-last-word">58 Length of Last Word</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#59-spiral-matrix-ii">59 Spiral Matrix II</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#60-permutation-sequence">60 Permutation Sequence</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#61-rotate-list">61 Rotate List</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#62-unique-paths">62 Unique Paths</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#63-unique-paths-ii">63 Unique Paths II</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#64-minimum-path-sum">64 Minimum Path Sum</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#65-valid-number">65 Valid Number</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#66-plus-one">66 Plus One</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#67-add-binary">67 Add Binary</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#69-sqrt">69 Sqrt</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#70-climbing-stairs">70 Climbing Stairs</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#73-set-matrix-zeroes">73 Set Matrix Zeroes</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#74-search-a-2d-matrix">74 Search a 2D Matrix</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#75-sort-colors">75 Sort Colors</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#77-combinations">77 Combinations</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#78-subsets">78 Subsets</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#80-remove-duplicates-from-sorted-array">80 Remove Duplicates from Sorted Array II</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#81-search-in-rotated-sorted-array-ii">81 Search in Rotated Sorted Array II</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#82-remove-duplicates-from-sorted-list">82 Remove Duplicates from Sorted List</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#83-remove-duplicates-from-sorted-list-ii">83 Remove Duplicates from Sorted List II</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#86-partition-list">86 Partition List</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#89-gray-code">89 Gray Code</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#90-subsets-ii">90 Subsets II</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#92-reverse-linked-list-ii">92 Reverse Linked List II</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#94-binary-tree-inorder-traversal">94 Binary Tree Inorder Traversal</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#95-unique-binary-search-trees">95 Unique Binary Search Trees</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#96-unique-binary-search-trees">96 Unique Binary Search Trees II</a></li>
<li><a href="./wishyouhappy_Algorithm_files/wishyouhappy_Algorithm.html">98 Validate Binary Search Tree</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#99-recover-binary-search-tree">99 Recover Binary Search Tree</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#100-same-tree">100 Same Tree</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#101-symmetric-tree">101 Symmetric Tree</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#102-binary-tree-level-order-traversal">102 Binary Tree Level Order Traversal</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#103-binary-tree-zigzag-level-order-traversal">103 Binary Tree Zigzag Level Order Traversal</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#104-maximum-depth-of-binary-tree">104 Maximum Depth of Binary Tree</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#105-construct-binary-tree-from-preorder-and-inorder-traversal">105 Construct Binary Tree from Preorder and Inorder Traversal</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#106-construct-binary-tree-from-inorder-and-postorder-traversal">106 Construct Binary Tree from Inorder and Postorder Traversal</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#107-binary-tree-level-order-traversal-ii">107 Binary Tree Level Order Traversal II</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#108-convert-sorted-array-to-binary-search-tree">108 Convert Sorted Array to Binary Search Tree</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#109-convert-sorted-list-to-binary-search-tree">109 Convert Sorted List to Binary Search Tree</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#110-balanced-binary-tree">110 Balanced Binary Tree</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#111-minimum-depth-of-binary-tree">111 Minimum Depth of Binary Tree</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#114-flatten-binary-tree-to-linked-list">114 Flatten Binary Tree to Linked List</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#118-pascal-triangle">118 Pascal Triangle</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#119-pascal-triangle-ii">119 Pascal Triangle II</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#120-triangle">120 Triangle</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#121-best-time-to-buy-and-sell-stock">121 Best Time to Buy and Sell Stock</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#122-best-time-to-buy-and-sell-stock-ii">122 Best Time to Buy and Sell Stock II</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#123-best-time-to-buy-and-sell-stock-iii">123 Best Time to Buy and Sell Stock III</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#124-binary-tree-maximum-path-sum">124 Binary Tree Maximum Path Sum</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#126-word-ladder">126 Word Ladder</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#127-word-ladder-ii">127 Word Ladder II</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#131-parlindrome-partitioning">131 Parlindrome partitioning</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#132-parlindrome-partitioning-ii">132 Parlindrome partitioning II</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#133-clone-graph">133 Clone Graph</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#135-candy">135 Candy</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#138-copy-list-with-random-pointer">138 Copy List With Random Pointer</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#141-linked-list-cycle">141 Linked List Cycle</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#142-linked-list-cycle-ii">142 Linked List Cycle II</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#143-reorder-list">143 Reorder List</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#144-binary-tree-preorder-traversal">144 Binary Tree Preorder Traversal</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#145-binary-tree-postorder-traversal">145 Binary Tree Postorder Traversal</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#147-insertion-sort-list">147 Insertion Sort List</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#148-sort-list">148 Sort List</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#151-reverse-words-in-a-string">151 Reverse Words in a String</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#153-find-minimum-in-rotated-sorted-array">153 Find Minimum in Rotated Sorted Array</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#154-find-minimum-in-rotated-sorted-array-ii">154 Find Minimum in Rotated Sorted Array II</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#155-min-stack">155 Min Stack</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#156-binary-tree-upside-down">156 Binary Tree Upside Down</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#157-read-n-characters-given-read4">157 Read N Characters Given Read4</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#158-read-n-characters-given-read4-ii-call-multiple-times">158 Read N Characters Given Read4 II - Call multiple times</a> </li>
<li><a href="https://github.com/wishyouhappy/Algorithm#159-longest-string-with-at-most-two-distinct-characters">159 Longest String with At Most Two Distinct Characters</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#160-intersection-of-two-linked-lists">160 Intersection of Two Linked Lists</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#161-one-edit-distance">161 One edit distance</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#162-find-peak-element">162 Find Peak Element</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#166-fraction-to-recurring-decimal">166 Fraction to Recurring Decimal</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#167-two-sum-ii-input-array-is-sorted">167 Two Sum II Input array is sorted</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#170-two-sum-iii-data-structure-design">170 Two Sum III Data Structure Design</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#173-binary-search-tree-iterator">173 Binary Search Tree Iterator</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#188-best-time-to-buy-and-sell-stock-iv">188 Best Time to Buy and Sell Stock IV</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#189-rotate-array">189 Rotate Array</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#190-reverse-bits">190 Reverse Bits</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#191-number-of-1-bits">191 Number of 1 Bits</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#198-house-robber">198 House Robber</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#199-binary-tree-right-side-view">199 Binary Tree Right Side View</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#200-number-of-islands">200 Number of Islands</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#201-bitwise-and-of-numbers-range">201 Bitwise AND of Numbers Range</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#202-happy-number">202 Happy Number</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#203-remove-linked-list-elements">203 Remove Linked List Elements</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#204-count-primes">204 Count Primes</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#205-isomorphic-strings">205 Isomorphic Strings</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#206-reverse-linked-list">206 Reverse Linked List</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#207-course-schedule">207 Course Schedule</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#208-implement-trie-prefix-tree">208 Implement Trie Prefix Tree</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#209-minimum-size-subarray-sum">209 Minimum Size Subarray Sum</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#210-course-schedule-ii">210 Course Schedule II</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#216-combination-sum-iii">216 Combination Sum III</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#222-count-complete-tree-nodes">222 Count Complete Tree Nodes</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#237-delete-node-in-a-linked-list">237 Delete Node in a Linked List</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#238-product-of-array-except-self">238 Product of Array Except Self</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#241-different-ways-to-add-parentheses">241 Different Ways to Add Parentheses</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#242-Valid%20Anagram">242 Valid Anagram</a></li>
</ul>

<h3><a id="user-content-others" class="anchor" href="https://github.com/wishyouhappy/Algorithm#others" aria-hidden="true"><span class="octicon octicon-link"></span></a>Others</h3>

<ul>
<li><a href="https://github.com/wishyouhappy/Algorithm#1-search-a-2d-matrix-ii">1 Search a 2D Matrix II</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#2-first-bad-version">2 First Bad Version</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#3-compare-strings">3 Compare Strings</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#4-longest-common-substring">4 Longest Common Substring</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#5-insert-in-sorted-linked-list">5 Insert in Sorted Linked List</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#6-is-bipartite">6 Is Bipartite</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#7-lowest-common-ancestor">7 Lowest Common Ancestor</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#8-median-tracker">8 Median tracker</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#9-95-percentile">9 95 Percentile</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#10-perfect-shuffle">10 Perfect shuffle</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#11-reservoir-sample">11 Reservoir sample</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#12-random7-using-random5">12 Random7 Using Random5</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#13-random1000-using-random5">13 Random1000 using random5</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#14-array-deduplication">14 Array deduplication</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#15-move-0s-to-the-end">15 Move 0s to the end</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#16-largest-and-smallest">16 Largest and Samllest</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#17-sort-in-specific-order">17 Sort in specific order</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#18-closest-number-in-binary-search-tree">18 Closest number in binary search tree</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm/blob/master/%EF%BC%8319-delete-in-binary-search-tree">19 Delete In Binary Search Tree</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#20-cutting-wood">20 Cutting wood</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#21-merge-stone">21 Merge stone</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#22-binary-tree-path-sum-to-target">22 Binary Tree Path Sum To Target</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#22-common-elements-in-three-sorted-array">23 Common Elements in Three Sorted Array</a></li>
</ul>

<p><br></p>

<h3><a id="user-content-1-two-sum" class="anchor" href="https://github.com/wishyouhappy/Algorithm#1-two-sum" aria-hidden="true"><span class="octicon octicon-link"></span></a>1 Two Sum</h3>

<blockquote>
<p>Given an array of integers, find two numbers such that they add up to a specific target number.</p>

<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p>

<p>You may assume that each input would have exactly one solution.</p>

<p>Input: numbers={2, 7, 11, 15}, target=9</p>

<p>Output: index1=1, index2=2</p>
</blockquote>

<p><strong>Solution1</strong>: Use hashmap to record the number and its index, each time check if map containsKey target - num[i].</p>

<p><strong>Time complexity</strong> O(n)</p>

<p><strong>Space</strong> O(n)</p>

<div class="highlight highlight-java"><pre>   <span class="pl-k">public</span> <span class="pl-k">int</span>[] twoSum(<span class="pl-k">int</span>[] numbers, <span class="pl-k">int</span> target) {
        <span class="pl-c">//use hashmap</span>
        <span class="pl-k">Map&lt;<span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>&gt;</span> map <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashMap&lt;<span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>&gt;</span>();
        <span class="pl-k">int</span>[] result <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[<span class="pl-c1">2</span>];
        <span class="pl-k">if</span>(numbers <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> numbers<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> result;

        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> numbers<span class="pl-k">.</span>length; i<span class="pl-k">++</span>){
            <span class="pl-k">if</span>(map<span class="pl-k">.</span>containsKey(target <span class="pl-k">-</span> numbers[i])){
                result[<span class="pl-c1">0</span>] <span class="pl-k">=</span> map<span class="pl-k">.</span>get(target <span class="pl-k">-</span> numbers[i]) <span class="pl-k">+</span> <span class="pl-c1">1</span>;
                result[<span class="pl-c1">1</span>] <span class="pl-k">=</span> i <span class="pl-k">+</span> <span class="pl-c1">1</span>;
                <span class="pl-k">return</span> result;
            }
            map<span class="pl-k">.</span>put(numbers[i], i);
        }
        <span class="pl-k">return</span> result;
    }</pre></div>

<p><strong>Solution2</strong>: We can first sort the numbers. Then use two pointers, the first pointer points to the begining and the second points to the end. Each time compares the target and num[p1]+num[p2], if target is bigger, p1++, else p2--. But it doesn't work for this problem, because we need to return the index. If we are requested to return the nunbers, we can use the following way.</p>

<p><strong>Time</strong>: O(nlgn)</p>

<p><strong>Space</strong>: O(1)</p>

<div class="highlight highlight-java"><pre>    <span class="pl-c">//this function returns the numbers, not the index</span>
    <span class="pl-k">public</span> <span class="pl-k">int</span>[] twoSum(<span class="pl-k">int</span>[] numbers, <span class="pl-k">int</span> target) {
        <span class="pl-c">//First sort, then use two pointers</span>
        <span class="pl-k">int</span>[] res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[<span class="pl-c1">2</span>];
        <span class="pl-k">if</span>(numbers <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> numbers<span class="pl-k">.</span>length <span class="pl-k">&lt;=</span> <span class="pl-c1">1</span>) <span class="pl-k">return</span> res;
        <span class="pl-smi">Arrays</span><span class="pl-k">.</span>sort(numbers);
        <span class="pl-k">int</span> l <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> r <span class="pl-k">=</span> numbers<span class="pl-k">.</span>length <span class="pl-k">-</span><span class="pl-c1">1</span>;
        <span class="pl-k">while</span>(l <span class="pl-k">&lt;</span> r){
            <span class="pl-k">if</span>(numbers[l] <span class="pl-k">+</span> numbers[r] <span class="pl-k">==</span> target){
                res[<span class="pl-c1">0</span>] <span class="pl-k">=</span> numbers[l];
                res[<span class="pl-c1">1</span>] <span class="pl-k">=</span> numbers[r];
                <span class="pl-k">return</span> res;
            }<span class="pl-k">else</span> <span class="pl-k">if</span>(numbers[l] <span class="pl-k">+</span> numbers[r] <span class="pl-k">&gt;</span> target)
                r<span class="pl-k">--</span>;
            <span class="pl-k">else</span> l<span class="pl-k">++</span>;
        }
        <span class="pl-k">return</span> res;
    }
</pre></div>

<p><br></p>

<p><strong>Related</strong>: Return all pairs 's indexs.</p>

<blockquote>
<p>for example: given {3, 5, 3, 2, 4, 4}, target = 7, return [[1, 3], [0, 4], [2, 4], [0, 5], [2, 5]]</p>
</blockquote>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> allPairs(<span class="pl-k">int</span>[] array, <span class="pl-k">int</span> target) {
    <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>();
    <span class="pl-k">if</span> (array <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> array<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
      <span class="pl-k">return</span> res;
    }
    <span class="pl-k">Map&lt;<span class="pl-smi">Integer</span>, <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> map <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashMap&lt;<span class="pl-smi">Integer</span>, <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>();
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> array<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
      <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> indexs <span class="pl-k">=</span> map<span class="pl-k">.</span>get(target <span class="pl-k">-</span> array[i]);
      <span class="pl-k">if</span> (indexs <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
        <span class="pl-k">for</span> (<span class="pl-smi">Integer</span> j <span class="pl-k">:</span> indexs) {
          <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> cur <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
          cur<span class="pl-k">.</span>add(j);
          cur<span class="pl-k">.</span>add(i);
          res<span class="pl-k">.</span>add(cur);
        }
      }
      <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> temp <span class="pl-k">=</span> map<span class="pl-k">.</span>get(array[i]);
      <span class="pl-k">if</span> (temp <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
        map<span class="pl-k">.</span>put(array[i], <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>());
      }
      map<span class="pl-k">.</span>get(array[i])<span class="pl-k">.</span>add(i);
    }
    <span class="pl-k">return</span> res;
  }
</pre></div>

<p><br></p>

<p><strong>Related</strong>: return all distinct pairs.</p>

<blockquote>
<p>for example: given {2, 1, 3, 2, 4, 3, 4, 2}, target = 4, return [[1, 3], [2, 2]]</p>
</blockquote>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> allPairs(<span class="pl-k">int</span>[] array, <span class="pl-k">int</span> target) {
    <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>();
    <span class="pl-k">if</span> (array <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> array<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
      <span class="pl-k">return</span> res;
    }
    <span class="pl-k">Map&lt;<span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>&gt;</span> map <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashMap&lt;<span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>&gt;</span>();
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">:</span> array) {
      <span class="pl-smi">Integer</span> temp <span class="pl-k">=</span> map<span class="pl-k">.</span>get(target <span class="pl-k">-</span> i);
      <span class="pl-k">if</span> (temp <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> temp <span class="pl-k">==</span> <span class="pl-c1">1</span>) {
        <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> cur <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
        cur<span class="pl-k">.</span>add(target <span class="pl-k">-</span> i);
        cur<span class="pl-k">.</span>add(i);
        res<span class="pl-k">.</span>add(cur);
        map<span class="pl-k">.</span>put(target <span class="pl-k">-</span> i, <span class="pl-c1">0</span>);
        map<span class="pl-k">.</span>put(i, <span class="pl-c1">0</span>);
      }
      <span class="pl-k">if</span> (<span class="pl-k">!</span>map<span class="pl-k">.</span>containsKey(i)) {
        map<span class="pl-k">.</span>put(i, <span class="pl-c1">1</span>);
      }
    }
    <span class="pl-k">return</span> res;
  }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-2-add-two-numbers" class="anchor" href="https://github.com/wishyouhappy/Algorithm#2-add-two-numbers" aria-hidden="true"><span class="octicon octicon-link"></span></a>2 Add Two Numbers</h3>

<blockquote>
<p>You are given two linked lists representing two non-negative numbers.
The digits are stored in reverse order and each of their nodes contain a single digit.
Add the two numbers and return it as a linked list.</p>

<p><strong><code>Input:</code></strong> <code>(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</code></p>

<p><strong><code>Output</code></strong> <code>(7 -&gt; 0 -&gt; 8)</code></p>
</blockquote>

<p><strong>Idea</strong>: </p>

<p>Digits are stored in reverse order, that means <code>(2 -&gt; 4 -&gt; 3)</code> is <code>342</code>. When it reaches 10 after addition, the next node shall add 1 and current node shall only keep the unit number: <code>(3 -&gt; 2) + (9 -&gt; 1) = (2 -&gt; 4)</code>; if one integer doesn't have more numbers, add the remaining digits to  result.</p>

<p><strong>Attention</strong>: After both l1 and l2 reach to the end, check the carry. If carry != 0, add an additional node to the result. </p>

<p><strong>More</strong>: What if the numbers are store in order? It's a little complicated than the question above. One way is add the corresponding digits, notice that the numbers might have different number of bits, so we can not add from beginning. The other stupid method is first reverse the linkedlist, then use the method above. </p>

<p><strong>java code</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-smi">ListNode</span> addTwoNumbers(<span class="pl-smi">ListNode</span> l1, <span class="pl-smi">ListNode</span> l2) {
        <span class="pl-k">if</span>(l1 <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">return</span> l2;
        <span class="pl-k">if</span>(l2 <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">return</span> l1;
        <span class="pl-smi">ListNode</span> fakeHead <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">ListNode</span>(<span class="pl-k">-</span><span class="pl-c1">1</span>);
        <span class="pl-smi">ListNode</span> res <span class="pl-k">=</span> fakeHead;
        <span class="pl-k">int</span> carry <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">while</span>(l1 <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> l2 <span class="pl-k">!=</span> <span class="pl-c1">null</span>){
            <span class="pl-k">int</span> sum <span class="pl-k">=</span> l1<span class="pl-k">.</span>val <span class="pl-k">+</span> l2<span class="pl-k">.</span>val <span class="pl-k">+</span> carry;
            <span class="pl-k">int</span> mod <span class="pl-k">=</span> sum <span class="pl-k">%</span> <span class="pl-c1">10</span>;
            carry <span class="pl-k">=</span> sum <span class="pl-k">/</span> <span class="pl-c1">10</span>;
            res<span class="pl-k">.</span>next <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">ListNode</span>(mod);
            res <span class="pl-k">=</span> res<span class="pl-k">.</span>next;
            l1 <span class="pl-k">=</span> l1<span class="pl-k">.</span>next;
            l2 <span class="pl-k">=</span> l2<span class="pl-k">.</span>next;
        }
        <span class="pl-k">while</span>(l1 <span class="pl-k">!=</span> <span class="pl-c1">null</span>){
            <span class="pl-k">int</span> sum <span class="pl-k">=</span> l1<span class="pl-k">.</span>val <span class="pl-k">+</span> carry;
            <span class="pl-k">int</span> mod <span class="pl-k">=</span> sum <span class="pl-k">%</span> <span class="pl-c1">10</span>;
            carry <span class="pl-k">=</span> sum <span class="pl-k">/</span> <span class="pl-c1">10</span>;
            res<span class="pl-k">.</span>next <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">ListNode</span>(mod);
            l1 <span class="pl-k">=</span> l1<span class="pl-k">.</span>next;
            res <span class="pl-k">=</span> res<span class="pl-k">.</span>next;
        }
        <span class="pl-k">while</span>(l2 <span class="pl-k">!=</span> <span class="pl-c1">null</span>){
            <span class="pl-k">int</span> sum <span class="pl-k">=</span> l2<span class="pl-k">.</span>val <span class="pl-k">+</span> carry;
            <span class="pl-k">int</span> mod <span class="pl-k">=</span> sum <span class="pl-k">%</span> <span class="pl-c1">10</span>;
            carry <span class="pl-k">=</span> sum <span class="pl-k">/</span> <span class="pl-c1">10</span>;
            res<span class="pl-k">.</span>next <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">ListNode</span>(mod);
            l2 <span class="pl-k">=</span> l2<span class="pl-k">.</span>next;
            res <span class="pl-k">=</span> res<span class="pl-k">.</span>next;
        }
        <span class="pl-k">if</span>(carry <span class="pl-k">!=</span> <span class="pl-c1">0</span>)
            res<span class="pl-k">.</span>next <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">ListNode</span>(carry);
        <span class="pl-k">return</span> fakeHead<span class="pl-k">.</span>next;
    }
</pre></div>

<p><strong>c++ Code</strong>:</p>

<div class="highlight highlight-cpp"><pre><span class="pl-c">/**</span>
<span class="pl-c"> * Definition for singly-linked list.</span>
<span class="pl-c"> * struct ListNode {</span>
<span class="pl-c"> *     int val;</span>
<span class="pl-c"> *     ListNode *next;</span>
<span class="pl-c"> *     ListNode(int x) : val(x), next(NULL) {}</span>
<span class="pl-c"> * };</span>
<span class="pl-c"> */</span>
<span class="pl-k">class</span> <span class="pl-en">Solution</span> {
<span class="pl-k">public:</span>
    ListNode *<span class="pl-en">addTwoNumbers</span>(ListNode *l1, ListNode *l2) {
        ListNode *p1 = l1, *p2 = l2;
        ListNode *r = <span class="pl-k">new</span> <span class="pl-c1">ListNode</span>(<span class="pl-c1">0</span>);
        ListNode *begin = r;
        <span class="pl-k">int</span> sum = <span class="pl-c1">0</span>;

        <span class="pl-k">while</span> (p1 &amp;&amp; p2) {
            sum = p1-&gt;val + p2-&gt;val + sum / <span class="pl-c1">10</span>;
            r-&gt;next = <span class="pl-k">new</span> <span class="pl-c1">ListNode</span>(sum % <span class="pl-c1">10</span>);
            p1 = p1-&gt;next;
            p2 = p2-&gt;next;
            r = r-&gt;next;
        }

        ListNode *px = <span class="pl-c1">NULL</span>;
        <span class="pl-k">if</span> (p1) { px = p1; }
        <span class="pl-k">else</span> <span class="pl-k">if</span> (p2) { px = p2; }

        <span class="pl-k">while</span> (px) {
            sum = sum / <span class="pl-c1">10</span> + px-&gt;val;
            r-&gt;next = <span class="pl-k">new</span> <span class="pl-c1">ListNode</span>(sum % <span class="pl-c1">10</span>);
            px = px-&gt;next;
            r = r-&gt;next;
        }
        <span class="pl-k">if</span> (sum &gt;= <span class="pl-c1">10</span>) { r-&gt;next = <span class="pl-k">new</span> <span class="pl-c1">ListNode</span>(sum / <span class="pl-c1">10</span>); }

        <span class="pl-k">return</span> begin-&gt;next;
    }

};</pre></div>

<p>The time complexity is O(m+n) and space complexity is O(m+n).</p>

<p><br>
<br></p>

<h3><a id="user-content-3-longest-substring-without-repeating-characters" class="anchor" href="https://github.com/wishyouhappy/Algorithm#3-longest-substring-without-repeating-characters" aria-hidden="true"><span class="octicon octicon-link"></span></a>3 Longest Substring without Repeating Characters</h3>

<blockquote>
<p>Given a string, find the length of the longest substring without repeating characters. For example, the longest substring without repeating letters for "abcabcbb" is "abc", which the length is 3. For "bbbbb" the longest substring is "b", with the length of 1.</p>
</blockquote>

<p><strong>Idea</strong>: if encounter duplicates, start from the character after the dulicate appear at the first time. eg: abcab, at index 4 a is duplicated, we start count from index 1(after the first a).</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> lengthOfLongestSubstring(<span class="pl-smi">String</span> s) {
        <span class="pl-k">if</span>(s <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> s<span class="pl-k">.</span>length() <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> start <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> current <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> max <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">Set&lt;<span class="pl-smi">Character</span>&gt;</span> set <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashSet&lt;<span class="pl-smi">Character</span>&gt;</span>();
        <span class="pl-k">while</span>(current <span class="pl-k">&lt;</span> s<span class="pl-k">.</span>length()){
            <span class="pl-k">if</span>(set<span class="pl-k">.</span>contains(s<span class="pl-k">.</span>charAt(current))){
                max <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(max, current <span class="pl-k">-</span> start);
                <span class="pl-k">while</span>(s<span class="pl-k">.</span>charAt(start) <span class="pl-k">!=</span> s<span class="pl-k">.</span>charAt(current)){
                    set<span class="pl-k">.</span>remove(s<span class="pl-k">.</span>charAt(start));
                    start<span class="pl-k">++</span>;
                }
                start<span class="pl-k">++</span>;
            }<span class="pl-k">else</span>{
                set<span class="pl-k">.</span>add(s<span class="pl-k">.</span>charAt(current));
            }
            current<span class="pl-k">++</span>;
        }
        max <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(current<span class="pl-k">-</span> start, max);
        <span class="pl-k">return</span> max;
    }

</pre></div>

<p>There is another solution use primitive string methods, such as indexOf, subString and contains. Because indexOf and contains take O(n*m), so it's really slow. It can be AC by leetcode, but when network is bad, it may time limit exceeded.</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> lengthOfLongestSubstring(<span class="pl-smi">String</span> s) {
        <span class="pl-k">if</span>(s <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> s<span class="pl-k">.</span>length() <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;      
        <span class="pl-k">int</span> longest <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> current <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-smi">StringBuilder</span> sBuilder <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">StringBuilder</span>();
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>, len <span class="pl-k">=</span> s<span class="pl-k">.</span>length(); i <span class="pl-k">&lt;</span> len; i<span class="pl-k">++</span>){

            <span class="pl-k">if</span>(sBuilder<span class="pl-k">.</span>toString()<span class="pl-k">.</span>contains(s<span class="pl-k">.</span>charAt(i)<span class="pl-k">+</span><span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>)){
                longest <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(longest, current);
                <span class="pl-k">int</span> index <span class="pl-k">=</span> sBuilder<span class="pl-k">.</span>indexOf(s<span class="pl-k">.</span>charAt(i)<span class="pl-k">+</span><span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>);
                sBuilder <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">StringBuilder</span>(sBuilder<span class="pl-k">.</span>substring(index<span class="pl-k">+</span><span class="pl-c1">1</span>));
                sBuilder<span class="pl-k">.</span>append(s<span class="pl-k">.</span>charAt(i));
                current <span class="pl-k">=</span> sBuilder<span class="pl-k">.</span>length();
            }<span class="pl-k">else</span>{
                sBuilder<span class="pl-k">.</span>append(s<span class="pl-k">.</span>charAt(i));
                current<span class="pl-k">++</span>;
            }
        }
        longest <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(longest, current);
        <span class="pl-k">return</span> longest;        
    }
</pre></div>

<p><br></p>

<p><br></p>

<h3><a id="user-content-4-median-of-two-sorted-arrays" class="anchor" href="https://github.com/wishyouhappy/Algorithm#4-median-of-two-sorted-arrays" aria-hidden="true"><span class="octicon octicon-link"></span></a>4 Median of Two Sorted Arrays</h3>

<blockquote>
<p>There are two sorted arrays A and B of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
</blockquote>

<p><strong>Idea</strong>: We need to find the median, thus if (lenA + lenB) % 2 == 1, we need to find the ((lenA + lenB)/2 + 1)th smallest element. If  (lenA + lenB) % 2 == 0, we return ( (lenA + lenB)/2)th + (lenA + lenB)/2 + 1)th)/ 2. So we can use the idea in find the kth element in an array. The steps are as follows:</p>

<ul>
<li>1) find the k/2 element of A and B</li>
<li>2) when B[k/2 -1] = A[k/2 -1], then the kth element is A[k/2 -1]</li>
<li>3) if A[k/2 -1] &lt; B[k/2 -1], then the kth element is not in A[0.....k/2 -1] and  B[k/2.....B.length -1]</li>
<li>4) if A[k/2 -1] &gt; B[k/2 -1], then the kth element is not in B[0.....k/2 -1] and  A[k/2.....A.length -1]</li>
</ul>

<p>*<em>Time complexity *</em> O(log(m+n))</p>

<p><strong>Attention</strong>: There are cases when one array is really longer than the other one, so we need to check the length of k/2 and length of array. Otherwise, there might be indexoutofbound exception. </p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">double</span> findMedianSortedArrays(<span class="pl-k">int</span> <span class="pl-k">A</span>[], <span class="pl-k">int</span> <span class="pl-k">B</span>[]) {
        <span class="pl-k">if</span>(<span class="pl-smi">A</span> <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> <span class="pl-smi">B</span> <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        <span class="pl-k">if</span>(<span class="pl-smi">A</span> <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">return</span> <span class="pl-smi">B</span><span class="pl-k">.</span>length <span class="pl-k">%</span> <span class="pl-c1">2</span> <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">?</span> (<span class="pl-k">B</span>[<span class="pl-smi">B</span><span class="pl-k">.</span>length<span class="pl-k">/</span><span class="pl-c1">2</span> <span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">+</span> <span class="pl-k">B</span>[<span class="pl-smi">B</span><span class="pl-k">.</span>length<span class="pl-k">/</span><span class="pl-c1">2</span>])<span class="pl-k">/</span><span class="pl-c1">2</span> <span class="pl-k">:</span> <span class="pl-k">B</span>[<span class="pl-smi">B</span><span class="pl-k">.</span>length<span class="pl-k">/</span><span class="pl-c1">2</span>];
        <span class="pl-k">if</span>(<span class="pl-smi">B</span> <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">return</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length <span class="pl-k">%</span> <span class="pl-c1">2</span> <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">?</span> (<span class="pl-k">A</span>[<span class="pl-smi">A</span><span class="pl-k">.</span>length<span class="pl-k">/</span><span class="pl-c1">2</span> <span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">+</span> <span class="pl-k">A</span>[<span class="pl-smi">A</span><span class="pl-k">.</span>length<span class="pl-k">/</span><span class="pl-c1">2</span>])<span class="pl-k">/</span><span class="pl-c1">2</span> <span class="pl-k">:</span> <span class="pl-k">A</span>[<span class="pl-smi">A</span><span class="pl-k">.</span>length<span class="pl-k">/</span><span class="pl-c1">2</span>];
        <span class="pl-k">return</span> ((<span class="pl-smi">A</span><span class="pl-k">.</span>length <span class="pl-k">+</span> <span class="pl-smi">B</span><span class="pl-k">.</span>length) <span class="pl-k">%</span> <span class="pl-c1">2</span> <span class="pl-k">==</span> <span class="pl-c1">1</span>) <span class="pl-k">?</span> helper(<span class="pl-smi">A</span>, <span class="pl-smi">B</span>, <span class="pl-c1">0</span>, <span class="pl-smi">A</span><span class="pl-k">.</span>length<span class="pl-k">-</span><span class="pl-c1">1</span>, <span class="pl-c1">0</span>, <span class="pl-smi">B</span><span class="pl-k">.</span>length<span class="pl-k">-</span><span class="pl-c1">1</span>, (<span class="pl-smi">A</span><span class="pl-k">.</span>length <span class="pl-k">+</span> <span class="pl-smi">B</span><span class="pl-k">.</span>length)<span class="pl-k">/</span><span class="pl-c1">2</span> <span class="pl-k">+</span> <span class="pl-c1">1</span>)<span class="pl-k">:</span>((helper(<span class="pl-smi">A</span>, <span class="pl-smi">B</span>, <span class="pl-c1">0</span>, <span class="pl-smi">A</span><span class="pl-k">.</span>length<span class="pl-k">-</span><span class="pl-c1">1</span>, <span class="pl-c1">0</span>, <span class="pl-smi">B</span><span class="pl-k">.</span>length<span class="pl-k">-</span><span class="pl-c1">1</span>, (<span class="pl-smi">A</span><span class="pl-k">.</span>length <span class="pl-k">+</span> <span class="pl-smi">B</span><span class="pl-k">.</span>length)<span class="pl-k">/</span><span class="pl-c1">2</span> )) <span class="pl-k">+</span> helper(<span class="pl-smi">A</span>, <span class="pl-smi">B</span>, <span class="pl-c1">0</span>, <span class="pl-smi">A</span><span class="pl-k">.</span>length<span class="pl-k">-</span><span class="pl-c1">1</span>, <span class="pl-c1">0</span>, <span class="pl-smi">B</span><span class="pl-k">.</span>length<span class="pl-k">-</span><span class="pl-c1">1</span>, (<span class="pl-smi">A</span><span class="pl-k">.</span>length <span class="pl-k">+</span> <span class="pl-smi">B</span><span class="pl-k">.</span>length)<span class="pl-k">/</span><span class="pl-c1">2</span> <span class="pl-k">+</span> <span class="pl-c1">1</span>))<span class="pl-k">/</span><span class="pl-c1">2</span>;
    }

    <span class="pl-k">public</span> <span class="pl-k">double</span> helper(<span class="pl-k">int</span>[] <span class="pl-smi">A</span>, <span class="pl-k">int</span>[] <span class="pl-smi">B</span>, <span class="pl-k">int</span> startA, <span class="pl-k">int</span> endA, <span class="pl-k">int</span> startB, <span class="pl-k">int</span> endB, <span class="pl-k">int</span> k){
        <span class="pl-k">int</span> lenA <span class="pl-k">=</span> endA <span class="pl-k">-</span> startA <span class="pl-k">+</span> <span class="pl-c1">1</span>;
        <span class="pl-k">int</span> lenB <span class="pl-k">=</span> endB <span class="pl-k">-</span> startB <span class="pl-k">+</span> <span class="pl-c1">1</span>;
        <span class="pl-k">if</span>(lenA <span class="pl-k">&gt;</span> lenB) <span class="pl-k">return</span> helper(<span class="pl-smi">B</span>, <span class="pl-smi">A</span>, startB, endB, startA, endA, k);
        <span class="pl-k">if</span>(lenA <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-k">B</span>[startB <span class="pl-k">+</span> k <span class="pl-k">-</span> <span class="pl-c1">1</span>];
        <span class="pl-k">if</span>(lenB <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-k">A</span>[startA <span class="pl-k">+</span> k <span class="pl-k">-</span> <span class="pl-c1">1</span>];
        <span class="pl-k">if</span>(k <span class="pl-k">==</span> <span class="pl-c1">1</span>) <span class="pl-k">return</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>min(<span class="pl-k">A</span>[startA], <span class="pl-k">B</span>[startB]);
        <span class="pl-k">int</span> posA <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>min(k<span class="pl-k">/</span><span class="pl-c1">2</span>, lenA);
        <span class="pl-k">int</span> posB <span class="pl-k">=</span> k <span class="pl-k">-</span> posA;
        <span class="pl-k">if</span>(<span class="pl-k">A</span>[startA <span class="pl-k">+</span> posA <span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">==</span> <span class="pl-k">B</span>[startB <span class="pl-k">+</span> posB <span class="pl-k">-</span><span class="pl-c1">1</span>]) <span class="pl-k">return</span> <span class="pl-k">A</span>[startA <span class="pl-k">+</span> posA <span class="pl-k">-</span><span class="pl-c1">1</span>];
        <span class="pl-k">if</span>(<span class="pl-k">A</span>[startA <span class="pl-k">+</span> posA <span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">&lt;</span> <span class="pl-k">B</span>[startB <span class="pl-k">+</span> posB <span class="pl-k">-</span><span class="pl-c1">1</span>]) <span class="pl-k">return</span> helper(<span class="pl-smi">A</span>, <span class="pl-smi">B</span>, posA<span class="pl-k">+</span>startA, endA, startB, posB<span class="pl-k">+</span>startB<span class="pl-k">-</span><span class="pl-c1">1</span>, k <span class="pl-k">-</span> posA);
        <span class="pl-k">else</span> <span class="pl-k">return</span> helper(<span class="pl-smi">A</span>, <span class="pl-smi">B</span>, startA, posA <span class="pl-k">+</span> startA <span class="pl-k">-</span><span class="pl-c1">1</span>, startB <span class="pl-k">+</span> posB, endB, k <span class="pl-k">-</span> posB);

    }
</pre></div>

<p>Here is the python code for this problem. We defined two extra functions: <code>median()</code> will find the median from <em>one</em> given array. <code>shrink()</code> will get two shrinked arrays, while one is from the left side and the other is the right side from the given arrays. Because either array may contains the median with exactly the middle two items in the array. So the shrinking size of array will be slightly less.</p>

<p>For example, for array [1,2,6,7] and [3,4,5,8]. The median of two arrays is 4.5 . <code>median(A)</code> is 4, <code>median(B)</code> is 4.5. So we will shrink the left side of A, and shrink the right side of B. So <code>shrink(A, B, true)</code> will be <code>[2,6,7], [3,4,5]</code>.</p>

<div class="highlight highlight-python"><pre><span class="pl-k">class</span> <span class="pl-en">Solution</span>:
    <span class="pl-k">def</span> <span class="pl-en">median</span>(<span class="pl-smi">self</span>, <span class="pl-smi">array</span>):
        n <span class="pl-k">=</span> <span class="pl-c1">len</span>(array)
        <span class="pl-k">if</span> n <span class="pl-k">==</span> <span class="pl-c1">1</span>:
            <span class="pl-k">return</span> array[<span class="pl-c1">0</span>]
        <span class="pl-k">elif</span> n <span class="pl-k">%</span> <span class="pl-c1">2</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>:
            <span class="pl-k">return</span> <span class="pl-c1">float</span>((array[n<span class="pl-k">/</span><span class="pl-c1">2</span>] <span class="pl-k">+</span> array[n<span class="pl-k">/</span><span class="pl-c1">2</span> <span class="pl-k">-</span> <span class="pl-c1">1</span>])) <span class="pl-k">/</span> <span class="pl-c1">2</span>
        <span class="pl-k">else</span>:
            <span class="pl-k">return</span> array[n<span class="pl-k">/</span><span class="pl-c1">2</span>]

    <span class="pl-k">def</span> <span class="pl-en">shrink</span>(<span class="pl-smi">self</span>, <span class="pl-smi">A</span>, <span class="pl-smi">B</span>, <span class="pl-smi">A_isleft</span>):
        a, b <span class="pl-k">=</span> <span class="pl-c1">len</span>(A), <span class="pl-c1">len</span>(B)
        n <span class="pl-k">=</span> (b<span class="pl-k">-</span><span class="pl-c1">1</span>) <span class="pl-k">/</span> <span class="pl-c1">2</span> <span class="pl-k">if</span> a <span class="pl-k">&gt;</span> b <span class="pl-k">else</span> (a<span class="pl-k">-</span><span class="pl-c1">1</span>) <span class="pl-k">/</span> <span class="pl-c1">2</span>
        <span class="pl-k">if</span> A_isleft:
            <span class="pl-k">return</span> A[:a<span class="pl-k">-</span>n], B[n:]
        <span class="pl-k">else</span>:
            <span class="pl-k">return</span> A[n:], B[:b<span class="pl-k">-</span>n]

    <span class="pl-c"># @return a float</span>
    <span class="pl-k">def</span> <span class="pl-en">findMedianSortedArrays</span>(<span class="pl-smi">self</span>, <span class="pl-smi">A</span>, <span class="pl-smi">B</span>):
        <span class="pl-k">if</span> <span class="pl-k">not</span> A <span class="pl-k">and</span> <span class="pl-k">not</span> B: <span class="pl-k">raise</span> <span class="pl-c1">ValueError</span>(<span class="pl-smi">message</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Two empty arrays<span class="pl-pds">"</span></span>)

        <span class="pl-k">if</span> <span class="pl-k">not</span> A:
            <span class="pl-k">return</span> <span class="pl-v">self</span>.median(B)

        <span class="pl-k">if</span> <span class="pl-k">not</span> B:
            <span class="pl-k">return</span> <span class="pl-v">self</span>.median(A)

        <span class="pl-k">if</span> <span class="pl-c1">len</span>(A) <span class="pl-k">&lt;=</span> <span class="pl-c1">2</span> <span class="pl-k">or</span> <span class="pl-c1">len</span>(B) <span class="pl-k">&lt;=</span> <span class="pl-c1">2</span>:
            <span class="pl-k">return</span> <span class="pl-v">self</span>.median(<span class="pl-c1">sorted</span>(A<span class="pl-k">+</span>B))

        A_isleft <span class="pl-k">=</span> <span class="pl-v">self</span>.median(A) <span class="pl-k">&gt;</span> <span class="pl-v">self</span>.median(B)
        a, b <span class="pl-k">=</span> <span class="pl-v">self</span>.shrink(A, B, A_isleft)
        <span class="pl-k">return</span> <span class="pl-v">self</span>.findMedianSortedArrays(a, b)</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-5-longest-palindromic-substring" class="anchor" href="https://github.com/wishyouhappy/Algorithm#5-longest-palindromic-substring" aria-hidden="true"><span class="octicon octicon-link"></span></a>5 Longest Palindromic Substring</h3>

<blockquote>
<p>Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.</p>
</blockquote>

<p><strong>Idea</strong>:</p>

<ul>
<li>1) solution1: use dp, we dp[j][i] == true represents that j...i is a parlindromic substring.</li>
<li>2) solution2: for each character s[i], we find the longest substring whose center is s[i] </li>
</ul>

<p><strong>solution1 code</strong></p>

<div class="highlight highlight-java"><pre>     <span class="pl-k">public</span> <span class="pl-smi">String</span> longestPalindrome(<span class="pl-smi">String</span> s) {
        <span class="pl-k">if</span>(s <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> s<span class="pl-k">.</span>length() <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> s;
        <span class="pl-k">boolean</span>[][] dp <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">boolean</span>[s<span class="pl-k">.</span>length()<span class="pl-k">+</span><span class="pl-c1">1</span>][s<span class="pl-k">.</span>length() <span class="pl-k">+</span> <span class="pl-c1">1</span>];
        dp[<span class="pl-c1">0</span>][<span class="pl-c1">0</span>] <span class="pl-k">=</span> <span class="pl-c1">true</span>;
        <span class="pl-k">int</span> max <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-smi">String</span> res <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> s<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>){
            <span class="pl-k">for</span>(<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;=</span> i; j<span class="pl-k">++</span>){
                <span class="pl-k">if</span>(s<span class="pl-k">.</span>charAt(i) <span class="pl-k">==</span> s<span class="pl-k">.</span>charAt(j) <span class="pl-k">&amp;&amp;</span> (i <span class="pl-k">-</span> j <span class="pl-k">&lt;=</span> <span class="pl-c1">2</span> <span class="pl-k">||</span> dp[j<span class="pl-k">+</span><span class="pl-c1">1</span>][i<span class="pl-k">-</span><span class="pl-c1">1</span>])){
                    dp[j][i] <span class="pl-k">=</span> <span class="pl-c1">true</span>;
                    <span class="pl-k">if</span>(i <span class="pl-k">-</span> j <span class="pl-k">+</span> <span class="pl-c1">1</span> <span class="pl-k">&gt;</span> max){
                        max <span class="pl-k">=</span> i<span class="pl-k">-</span>j<span class="pl-k">+</span><span class="pl-c1">1</span>;
                        res <span class="pl-k">=</span> s<span class="pl-k">.</span>substring(j, i<span class="pl-k">+</span><span class="pl-c1">1</span>);
                    }
                }

            }
        }
        <span class="pl-k">return</span> res;
    }
</pre></div>

<p><strong>solution2 code</strong></p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-smi">String</span> longestPalindrome(<span class="pl-smi">String</span> s) {
        <span class="pl-k">if</span>(s <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> s<span class="pl-k">.</span>length() <span class="pl-k">&lt;=</span> <span class="pl-c1">1</span>) <span class="pl-k">return</span> s;
        <span class="pl-k">int</span> max <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-smi">String</span> res <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> s<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>){
            <span class="pl-smi">String</span> mid <span class="pl-k">=</span> helper(s, i<span class="pl-k">-</span><span class="pl-c1">1</span>, i<span class="pl-k">+</span><span class="pl-c1">1</span>);
            <span class="pl-smi">String</span> left <span class="pl-k">=</span>  helper(s, i<span class="pl-k">-</span><span class="pl-c1">1</span>, i);
            <span class="pl-smi">String</span> right <span class="pl-k">=</span>  helper(s, i, i<span class="pl-k">+</span><span class="pl-c1">1</span>);
            <span class="pl-smi">String</span> temp <span class="pl-k">=</span> mid<span class="pl-k">.</span>length() <span class="pl-k">&gt;</span> left<span class="pl-k">.</span>length() <span class="pl-k">?</span> mid <span class="pl-k">:</span> left;
            temp <span class="pl-k">=</span> temp<span class="pl-k">.</span>equals(mid) <span class="pl-k">?</span> (mid<span class="pl-k">.</span>length() <span class="pl-k">&gt;</span> right<span class="pl-k">.</span>length() <span class="pl-k">?</span> mid <span class="pl-k">:</span> right) <span class="pl-k">:</span> (left<span class="pl-k">.</span>length() <span class="pl-k">&gt;</span> right<span class="pl-k">.</span>length() <span class="pl-k">?</span> left <span class="pl-k">:</span> right);
            <span class="pl-k">if</span>(temp<span class="pl-k">.</span>length() <span class="pl-k">&gt;</span> max){
                max <span class="pl-k">=</span> temp<span class="pl-k">.</span>length();
                res <span class="pl-k">=</span> temp;
            }
        }
        <span class="pl-k">return</span> res;
    }

    <span class="pl-k">public</span> <span class="pl-smi">String</span> helper(<span class="pl-smi">String</span> s, <span class="pl-k">int</span> l, <span class="pl-k">int</span> r){
        <span class="pl-k">while</span>(l <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> r <span class="pl-k">&lt;</span> s<span class="pl-k">.</span>length()){
            <span class="pl-k">if</span>(s<span class="pl-k">.</span>charAt(l) <span class="pl-k">==</span> s<span class="pl-k">.</span>charAt(r)) {
                l<span class="pl-k">--</span>;
                r<span class="pl-k">++</span>;
            }<span class="pl-k">else</span>{
                <span class="pl-k">return</span> s<span class="pl-k">.</span>substring(l<span class="pl-k">+</span><span class="pl-c1">1</span>, r);
            }
        }
        <span class="pl-k">return</span> s<span class="pl-k">.</span>substring(l<span class="pl-k">+</span><span class="pl-c1">1</span>, r);
    }

</pre></div>

<h3><a id="user-content-6-zigzag-conversion" class="anchor" href="https://github.com/wishyouhappy/Algorithm#6-zigzag-conversion" aria-hidden="true"><span class="octicon octicon-link"></span></a>6 Zigzag Conversion</h3>

<blockquote>
<p>The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)
</p><pre><p></p>
</pre></blockquote>

<p>P   A   H   N
A P L S I I G
Y   I   R</p>

<p>
And then read line by line: "PAHNAPLSIIGYIR"
Write the code that will take a string and make this conversion given a number of rows:</p>

<p>string convert(string text, int nRows);
convert("PAYPALISHIRING", 3) should return "PAHNAPLSIIGYIR".</p>

<p>** Idea**: </p>

<p>size of zigzag: 2 * nRows - 2;</p>

<p>index of middle element : size - i + j - i ; i is the row number, j is the starting index of each row.</p>

<p><strong>code</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-smi">String</span> convert(<span class="pl-smi">String</span> s, <span class="pl-k">int</span> nRows) {
        <span class="pl-k">if</span>(s <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> nRows <span class="pl-k">==</span> <span class="pl-c1">1</span>) <span class="pl-k">return</span> s;
        <span class="pl-smi">StringBuilder</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">StringBuilder</span>();
        <span class="pl-k">int</span> size <span class="pl-k">=</span> nRows <span class="pl-k">*</span> <span class="pl-c1">2</span> <span class="pl-k">-</span> <span class="pl-c1">2</span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> nRows; i<span class="pl-k">++</span>){
            <span class="pl-k">for</span>(<span class="pl-k">int</span> j <span class="pl-k">=</span> i; j <span class="pl-k">&lt;</span> s<span class="pl-k">.</span>length(); j <span class="pl-k">+=</span> size){
                res<span class="pl-k">.</span>append(s<span class="pl-k">.</span>charAt(j));
                <span class="pl-k">if</span>(i <span class="pl-k">!=</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> i <span class="pl-k">!=</span> nRows<span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-k">&amp;&amp;</span> ((size <span class="pl-k">-</span> i <span class="pl-k">+</span> j <span class="pl-k">-</span> i) <span class="pl-k">&lt;</span> s<span class="pl-k">.</span>length()))
                    res<span class="pl-k">.</span>append(s<span class="pl-k">.</span>charAt(size <span class="pl-k">-</span> i <span class="pl-k">+</span> j <span class="pl-k">-</span> i));
            }
        }
        <span class="pl-k">return</span> res<span class="pl-k">.</span>toString();
    }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-7-reverse-integer" class="anchor" href="https://github.com/wishyouhappy/Algorithm#7-reverse-integer" aria-hidden="true"><span class="octicon octicon-link"></span></a>7 Reverse Integer</h3>

<blockquote>
<p>Reverse digits of an integer.</p>

<p>Example1: x = 123, return 321</p>

<p>Example2: x = -123, return -321</p>
</blockquote>

<p><strong>Idea</strong>: Record the sign of the number then take abs of the number. Move the lsb to the msb each time until the number change to 0.</p>

<p><strong>Attention</strong>: After reverse, the number might overflow, then we need to check during reverse. When overflow, we return 0;</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> reverse(<span class="pl-k">int</span> x) {
        <span class="pl-k">if</span>(x <span class="pl-k">&lt;=</span> <span class="pl-c1">9</span> <span class="pl-k">&amp;&amp;</span> x <span class="pl-k">&gt;=</span> <span class="pl-k">-</span><span class="pl-c1">9</span>) <span class="pl-k">return</span> x;
        <span class="pl-k">int</span> res <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">boolean</span> positive <span class="pl-k">=</span> x <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">?</span> <span class="pl-c1">true</span> <span class="pl-k">:</span> <span class="pl-c1">false</span>;
        x <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>abs(x);
        <span class="pl-k">while</span>(x <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> (<span class="pl-smi">Integer</span><span class="pl-c1"><span class="pl-k">.</span>MAX_VALUE</span> <span class="pl-k">-</span> x <span class="pl-k">%</span> <span class="pl-c1">10</span>) <span class="pl-k">/</span> <span class="pl-c1">10</span> <span class="pl-k">&gt;=</span> res){
            <span class="pl-k">int</span> mod <span class="pl-k">=</span> x <span class="pl-k">%</span> <span class="pl-c1">10</span>;
            res <span class="pl-k">=</span> res <span class="pl-k">*</span> <span class="pl-c1">10</span> <span class="pl-k">+</span> mod;
            x <span class="pl-k">=</span> x <span class="pl-k">/</span> <span class="pl-c1">10</span>;
        }
        <span class="pl-k">if</span>(x <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        <span class="pl-k">return</span> positive <span class="pl-k">?</span>  res <span class="pl-k">:</span> <span class="pl-k">-</span>res;
    }
</pre></div>

<h3><a id="user-content-8-string-to-integer-atoi" class="anchor" href="https://github.com/wishyouhappy/Algorithm#8-string-to-integer-atoi" aria-hidden="true"><span class="octicon octicon-link"></span></a>8 String to Integer atoi</h3>

<blockquote>
<p>Implement atoi to convert a string to an integer.</p>

<p>Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.</p>

<p>Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.</p>
</blockquote>

<p><strong>Some rules</strong>: </p>

<p>1) if can not convert, return 0;</p>

<p>2) if value if out of range, return INT_MAX or INT_MIN</p>

<p>3) discard any whitespace until first non-whitespace character is found</p>

<p>4) takes as many characters as possible to form a valid character until encounter an unvalid</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> myAtoi(<span class="pl-smi">String</span> str) {
        <span class="pl-k">if</span> (str <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        }
        str <span class="pl-k">=</span> str<span class="pl-k">.</span>trim();
        <span class="pl-k">int</span> res <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">boolean</span> isPositive <span class="pl-k">=</span> <span class="pl-c1">true</span>; 
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> str<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>) {
            <span class="pl-k">char</span> c <span class="pl-k">=</span> str<span class="pl-k">.</span>charAt(i);
            <span class="pl-k">if</span> (i <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> (c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>-<span class="pl-pds">'</span></span> <span class="pl-k">||</span> c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>+<span class="pl-pds">'</span></span>)) {
                <span class="pl-k">if</span> (c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>-<span class="pl-pds">'</span></span>) {
                    isPositive <span class="pl-k">=</span> <span class="pl-c1">false</span>;
                }
                <span class="pl-k">continue</span>;
            }
            <span class="pl-k">if</span> (<span class="pl-k">!</span>isNum(c)) {
                <span class="pl-k">break</span>;
            } <span class="pl-k">else</span> <span class="pl-k">if</span> (res <span class="pl-k">&gt;</span> (<span class="pl-smi">Integer</span><span class="pl-c1"><span class="pl-k">.</span>MAX_VALUE</span> <span class="pl-k">-</span> (c <span class="pl-k">-</span> <span class="pl-s"><span class="pl-pds">'</span>0<span class="pl-pds">'</span></span>)) <span class="pl-k">/</span> <span class="pl-c1">10</span>) {
                <span class="pl-k">return</span> isPositive <span class="pl-k">?</span> <span class="pl-smi">Integer</span><span class="pl-c1"><span class="pl-k">.</span>MAX_VALUE</span> <span class="pl-k">:</span> <span class="pl-smi">Integer</span><span class="pl-c1"><span class="pl-k">.</span>MIN_VALUE</span>;
            } <span class="pl-k">else</span> {
                res <span class="pl-k">=</span> res <span class="pl-k">*</span> <span class="pl-c1">10</span> <span class="pl-k">+</span> (c <span class="pl-k">-</span> <span class="pl-s"><span class="pl-pds">'</span>0<span class="pl-pds">'</span></span>);
            }
        }
        <span class="pl-k">return</span> isPositive <span class="pl-k">?</span> res <span class="pl-k">:</span> <span class="pl-k">-</span>res;
    }

    <span class="pl-k">public</span> <span class="pl-k">boolean</span> isNum(<span class="pl-k">char</span> c) {
        <span class="pl-k">return</span> c <span class="pl-k">&gt;=</span> <span class="pl-s"><span class="pl-pds">'</span>0<span class="pl-pds">'</span></span> <span class="pl-k">&amp;&amp;</span> c <span class="pl-k">&lt;=</span> <span class="pl-s"><span class="pl-pds">'</span>9<span class="pl-pds">'</span></span>;
    }
</pre></div>

<p>5) python accepts integer larger than INT_MAX and integer smaller than INT_MIN, so make an if-else on that.</p>

<div class="highlight highlight-python"><pre><span class="pl-k">class</span> <span class="pl-en">Solution</span>:
    INT_MIN <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">2147483648</span>
    INT_MAX <span class="pl-k">=</span> <span class="pl-c1">2147483647</span>

    <span class="pl-k">if</span> num <span class="pl-k">&lt;</span> <span class="pl-v">self</span>.INT_MIN:
        <span class="pl-k">return</span> <span class="pl-v">self</span>.INT_MIN
    <span class="pl-k">elif</span> num <span class="pl-k">&gt;</span> <span class="pl-v">self</span>.INT_MAX:
        <span class="pl-k">return</span> <span class="pl-v">self</span>.INT_MAX</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-9-palindrome-number" class="anchor" href="https://github.com/wishyouhappy/Algorithm#9-palindrome-number" aria-hidden="true"><span class="octicon octicon-link"></span></a>9 Palindrome Number</h3>

<blockquote>
<p>Determine whether an integer is a palindrome. Do this without extra space.</p>
</blockquote>

<p><strong>Idea</strong>: Just like check if a string is a palindrom, we need to have two pointers, one from beginning and one from end. The difference is that for a integer, we can not use charAt. But we can still get the number of the two pointers use divide and mod. </p>

<p><strong>Jave Code</strong></p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">boolean</span> isPalindrome(<span class="pl-k">int</span> x) {
        <span class="pl-k">if</span>(x <span class="pl-k">&lt;</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        <span class="pl-k">if</span>(x <span class="pl-k">&lt;=</span> <span class="pl-c1">9</span>) <span class="pl-k">return</span> <span class="pl-c1">true</span>;
        <span class="pl-k">int</span> divide <span class="pl-k">=</span> <span class="pl-c1">1</span>;
        <span class="pl-k">while</span>((divide <span class="pl-k">&lt;</span> <span class="pl-smi">Integer</span><span class="pl-c1"><span class="pl-k">.</span>MAX_VALUE</span><span class="pl-k">/</span><span class="pl-c1">10</span>) <span class="pl-k">&amp;&amp;</span> (divide <span class="pl-k">*</span> <span class="pl-c1">10</span>) <span class="pl-k">&lt;=</span> x){
            divide <span class="pl-k">*=</span> <span class="pl-c1">10</span>;
        }
        <span class="pl-k">while</span>(x <span class="pl-k">!=</span> <span class="pl-c1">0</span>){
            <span class="pl-k">int</span> ms <span class="pl-k">=</span> x<span class="pl-k">/</span>divide;
            <span class="pl-k">int</span> ls <span class="pl-k">=</span> x<span class="pl-k">%</span><span class="pl-c1">10</span>;
            <span class="pl-k">if</span>(ms <span class="pl-k">!=</span> ls) <span class="pl-k">return</span> <span class="pl-c1">false</span>;
            x <span class="pl-k">=</span> (x <span class="pl-k">%</span> divide) <span class="pl-k">/</span> <span class="pl-c1">10</span>;
            divide  <span class="pl-k">=</span> divide <span class="pl-k">/</span> <span class="pl-c1">100</span>;
        }
        <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-10-regular-expression-matching" class="anchor" href="https://github.com/wishyouhappy/Algorithm#10-regular-expression-matching" aria-hidden="true"><span class="octicon octicon-link"></span></a>10 Regular Expression Matching</h3>

<blockquote>
<p>Implement regular expression matching with support for '.' and '*'.</p>
</blockquote>

<pre>'.' Matches any single character.
'*' Matches zero or more of the preceding element.

The matching should cover the entire input string (not partial).

The function prototype should be:
bool isMatch(const char *s, const char *p)

Some examples:
isMatch("aa","a") → false
isMatch("aa","aa") → true
isMatch("aaa","aa") → false
isMatch("aa", "a*") → true
isMatch("aa", ".*") → true
isMatch("ab", ".*") → true
isMatch("aab", "c*a*b") → true

</pre>

<p><strong>Idea</strong>:</p>

<ul>
<li> Solution1: We divide it into two cases: 1) p[j+1] == '*'  2)p[j+1] != '*'. In the first case, it's a little complicated. Because * can match 0 or more characters. Thus we need to check match(s, p, i, j+2), match(s, p, i+1, j+2)....... In the second case we just need to compare s[i] and p[j], if s[i] == p[j] or p[j] == '.', we continue to compare(s, p, i+1, j+1).</li>
</ul>

<p><strong>Solution1 code</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">boolean</span> isMatch(<span class="pl-smi">String</span> s, <span class="pl-smi">String</span> p) {
        <span class="pl-k">if</span>((s <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> p <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">||</span> p<span class="pl-k">.</span>equals(<span class="pl-s"><span class="pl-pds">"</span>.*<span class="pl-pds">"</span></span>)) <span class="pl-k">return</span> <span class="pl-c1">true</span>;
        <span class="pl-k">return</span> helper(s, p, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>);
    }
    <span class="pl-k">public</span> <span class="pl-k">boolean</span> helper(<span class="pl-smi">String</span> s, <span class="pl-smi">String</span> p, <span class="pl-k">int</span> i, <span class="pl-k">int</span> j){
        <span class="pl-k">if</span>(j <span class="pl-k">==</span> p<span class="pl-k">.</span>length()) <span class="pl-k">return</span> i <span class="pl-k">==</span> s<span class="pl-k">.</span>length();
         <span class="pl-k">if</span>(j<span class="pl-k">+</span><span class="pl-c1">1</span> <span class="pl-k">==</span> p<span class="pl-k">.</span>length() <span class="pl-k">||</span> p<span class="pl-k">.</span>charAt(j<span class="pl-k">+</span><span class="pl-c1">1</span>) <span class="pl-k">!=</span> <span class="pl-s"><span class="pl-pds">'</span>*<span class="pl-pds">'</span></span>){
            <span class="pl-k">if</span>(i <span class="pl-k">&lt;</span> s<span class="pl-k">.</span>length() <span class="pl-k">&amp;&amp;</span> (s<span class="pl-k">.</span>charAt(i) <span class="pl-k">==</span> p<span class="pl-k">.</span>charAt(j) <span class="pl-k">||</span> p<span class="pl-k">.</span>charAt(j) <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>.<span class="pl-pds">'</span></span>)) <span class="pl-k">return</span> helper(s, p, i<span class="pl-k">+</span><span class="pl-c1">1</span>, j<span class="pl-k">+</span><span class="pl-c1">1</span>);
            <span class="pl-k">else</span> <span class="pl-k">return</span> <span class="pl-c1">false</span>;
         }
         <span class="pl-k">while</span>(i <span class="pl-k">&lt;</span> s<span class="pl-k">.</span>length() <span class="pl-k">&amp;&amp;</span> (p<span class="pl-k">.</span>charAt(j) <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>.<span class="pl-pds">'</span></span> <span class="pl-k">||</span> p<span class="pl-k">.</span>charAt(j) <span class="pl-k">==</span> s<span class="pl-k">.</span>charAt(i))){
             <span class="pl-k">if</span>(helper(s, p, i<span class="pl-k">++</span>, j<span class="pl-k">+</span><span class="pl-c1">2</span>)) <span class="pl-k">return</span> <span class="pl-c1">true</span>;
         }
         <span class="pl-k">return</span> helper(s, p, i, j<span class="pl-k">+</span><span class="pl-c1">2</span>);
    }</pre></div>

<p><strong>Solution2</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">boolean</span> isMatch(<span class="pl-smi">String</span> s, <span class="pl-smi">String</span> p) {
        <span class="pl-k">if</span>((s <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> p <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">||</span> p<span class="pl-k">.</span>equals(<span class="pl-s"><span class="pl-pds">"</span>.*<span class="pl-pds">"</span></span>)) <span class="pl-k">return</span> <span class="pl-c1">true</span>;
        <span class="pl-k">boolean</span>[][] dp <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">boolean</span>[s<span class="pl-k">.</span>length()<span class="pl-k">+</span><span class="pl-c1">1</span>][p<span class="pl-k">.</span>length()<span class="pl-k">+</span><span class="pl-c1">1</span>];
        dp[<span class="pl-c1">0</span>][<span class="pl-c1">0</span>] <span class="pl-k">=</span> <span class="pl-c1">true</span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">2</span>; i <span class="pl-k">&lt;=</span> p<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>){
            <span class="pl-k">if</span>(p<span class="pl-k">.</span>charAt(i<span class="pl-k">-</span><span class="pl-c1">1</span>) <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>*<span class="pl-pds">'</span></span>) dp[<span class="pl-c1">0</span>][i] <span class="pl-k">=</span> dp[<span class="pl-c1">0</span>][i<span class="pl-k">-</span><span class="pl-c1">2</span>];
        }
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;=</span> s<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>){
            <span class="pl-k">for</span>(<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">1</span>; j <span class="pl-k">&lt;=</span> p<span class="pl-k">.</span>length(); j<span class="pl-k">++</span>){
                <span class="pl-k">if</span>(p<span class="pl-k">.</span>charAt(j<span class="pl-k">-</span><span class="pl-c1">1</span>) <span class="pl-k">!=</span> <span class="pl-s"><span class="pl-pds">'</span>*<span class="pl-pds">'</span></span>){
                    <span class="pl-k">if</span>(s<span class="pl-k">.</span>charAt(i<span class="pl-k">-</span><span class="pl-c1">1</span>) <span class="pl-k">==</span> p<span class="pl-k">.</span>charAt(j<span class="pl-k">-</span><span class="pl-c1">1</span>) <span class="pl-k">||</span> p<span class="pl-k">.</span>charAt(j<span class="pl-k">-</span><span class="pl-c1">1</span>) <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>.<span class="pl-pds">'</span></span>) dp[i][j] <span class="pl-k">=</span> dp[i<span class="pl-k">-</span><span class="pl-c1">1</span>][j<span class="pl-k">-</span><span class="pl-c1">1</span>];
                }<span class="pl-k">else</span>{
                   <span class="pl-k">if</span>(j <span class="pl-k">&gt;</span> <span class="pl-c1">1</span> <span class="pl-k">&amp;&amp;</span> (s<span class="pl-k">.</span>charAt(i<span class="pl-k">-</span><span class="pl-c1">1</span>) <span class="pl-k">==</span> p<span class="pl-k">.</span>charAt(j<span class="pl-k">-</span><span class="pl-c1">2</span>) <span class="pl-k">||</span> p<span class="pl-k">.</span>charAt(j<span class="pl-k">-</span><span class="pl-c1">2</span>) <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>.<span class="pl-pds">'</span></span>))
                         dp[i][j] <span class="pl-k">=</span> dp[i][j<span class="pl-k">-</span><span class="pl-c1">2</span>] <span class="pl-k">||</span> dp[i<span class="pl-k">-</span><span class="pl-c1">1</span>][j];
                   <span class="pl-k">else</span> dp[i][j] <span class="pl-k">=</span> dp[i][j<span class="pl-k">-</span><span class="pl-c1">2</span>];
                }
            }
        }
        <span class="pl-k">return</span> dp[s<span class="pl-k">.</span>length()][p<span class="pl-k">.</span>length()];
     }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-11-container-with-most-water" class="anchor" href="https://github.com/wishyouhappy/Algorithm#11-container-with-most-water" aria-hidden="true"><span class="octicon octicon-link"></span></a>11 Container with Most Water</h3>

<blockquote>
<p>Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.
Note: You may not slant the container.</p>
</blockquote>

<p><strong>Idea</strong>: Thea easiest way we can do is brute force. We calcuate the possible value with element with all the values after it. The time complexity is O(n^2). Have have another efficient way. We set a window, l = 0, r = size -1. Each time we calculate the container of l r, then we compare the height[l] and height[r]. if(height[l] &gt; height[r]), r--. Because we know that height[l] &gt; height[r], if we move l pointer, then the volumn would decrease.</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> maxArea(<span class="pl-k">int</span>[] height) {
        <span class="pl-k">if</span>(height <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> height<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> left <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> right <span class="pl-k">=</span> height<span class="pl-k">.</span>length<span class="pl-k">-</span><span class="pl-c1">1</span>;
        <span class="pl-k">int</span> max <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">while</span>(left <span class="pl-k">&lt;</span> right){
            max <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(max, <span class="pl-smi">Math</span><span class="pl-k">.</span>min(height[left], height[right]) <span class="pl-k">*</span> (right<span class="pl-k">-</span>left));
            <span class="pl-k">if</span>(height[right] <span class="pl-k">&gt;</span> height[left]) left<span class="pl-k">++</span>;
            <span class="pl-k">else</span> right<span class="pl-k">--</span>;
        }
        <span class="pl-k">return</span> max;
    }

</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-12-integer-to-roman" class="anchor" href="https://github.com/wishyouhappy/Algorithm#12-integer-to-roman" aria-hidden="true"><span class="octicon octicon-link"></span></a>12 Integer to Roman</h3>

<blockquote>
<p>Given an integer, convert it to a roman numeral.</p>

<p>Input is guaranteed to be within the range from 1 to 3999.</p>
</blockquote>

<p><strong>Some rules about Roman</strong>:</p>

<p><em>Numbers</em>:</p>

<ul>
<li>I : 1</li>
<li>V : 5</li>
<li>X : 10</li>
<li>L : 50</li>
<li>C : 100</li>
<li>D : 500</li>
<li>M : 1000</li>
</ul>

<p><em>specific rules</em>: </p>

<ul>
<li>When a larger number add some smaller numbers on its right side: larger + smaller</li>
<li>when a larger number add some smaller numbers on its left side : larger - smaller</li>
<li>when add a line on top of roman number, it means the number * 1000</li>
<li>The same roman code can repeat at most three times eg: XL: 40, we cannot write it as XXXX</li>
</ul>

<p><strong>Some Example</strong>:</p>

<ul>
<li>I : 1</li>
<li>II : 2</li>
<li>III : 3</li>
<li>IV : 4</li>
<li>V : 5</li>
<li>VI : 6</li>
<li>VII: 7</li>
<li>VIII : 8</li>
<li>IX : 9</li>
<li>X: 10</li>
<li>XI : 11</li>
<li>......</li>
<li>XC: 90</li>
<li>CD : 400</li>
<li>DCCC: 800</li>
<li>.....</li>
</ul>

<p><strong>Idea</strong>:</p>

<ul>
<li><p>1) Solution1: The most straight forward way is we add the value of each character. There are two cases to consider. 1. character I 2. character V, X....... For the first case, we just need to add I to the result. For the second case, we need to check if there are smaller characters before it. For example IV if 4, we need first add 1 then add 5 -2.</p></li>
<li><p>2)  Solution2 : We add a map for each pair. These additional space can help make our code more concisely.</p></li>
</ul>

<p><strong>Solution1 code</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> romanToInt1(<span class="pl-smi">String</span> s) {
        <span class="pl-k">if</span>(s <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> s<span class="pl-k">.</span>length() <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> res <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> s<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>){
            <span class="pl-k">char</span> c <span class="pl-k">=</span> s<span class="pl-k">.</span>charAt(i);
            <span class="pl-k">if</span>(c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>I<span class="pl-pds">'</span></span>) res <span class="pl-k">+=</span> <span class="pl-c1">1</span>;
            <span class="pl-k">else</span> <span class="pl-k">if</span>( c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>V<span class="pl-pds">'</span></span>){
                <span class="pl-k">if</span>(i <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> s<span class="pl-k">.</span>charAt(i<span class="pl-k">-</span><span class="pl-c1">1</span>) <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>I<span class="pl-pds">'</span></span>) res <span class="pl-k">+=</span> <span class="pl-c1">3</span>;
                <span class="pl-k">else</span> res <span class="pl-k">+=</span> <span class="pl-c1">5</span>;
            }<span class="pl-k">else</span> <span class="pl-k">if</span>(c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>X<span class="pl-pds">'</span></span>){
                <span class="pl-k">if</span>(i <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> s<span class="pl-k">.</span>charAt(i<span class="pl-k">-</span><span class="pl-c1">1</span>) <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>I<span class="pl-pds">'</span></span>) res <span class="pl-k">+=</span> <span class="pl-c1">8</span>;
                <span class="pl-k">else</span> res <span class="pl-k">+=</span> <span class="pl-c1">10</span>;
            }<span class="pl-k">else</span> <span class="pl-k">if</span>(c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>L<span class="pl-pds">'</span></span>){
                <span class="pl-k">if</span>(i <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> s<span class="pl-k">.</span>charAt(i<span class="pl-k">-</span><span class="pl-c1">1</span>) <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>X<span class="pl-pds">'</span></span>) res <span class="pl-k">+=</span> <span class="pl-c1">30</span>;
                <span class="pl-k">else</span> res <span class="pl-k">+=</span> <span class="pl-c1">50</span>;
            }<span class="pl-k">else</span> <span class="pl-k">if</span>(c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>C<span class="pl-pds">'</span></span>){
                <span class="pl-k">if</span>(i <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> s<span class="pl-k">.</span>charAt(i<span class="pl-k">-</span><span class="pl-c1">1</span>) <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>X<span class="pl-pds">'</span></span>) res <span class="pl-k">+=</span> <span class="pl-c1">80</span>;
                <span class="pl-k">else</span> res <span class="pl-k">+=</span> <span class="pl-c1">100</span>;
            }<span class="pl-k">else</span> <span class="pl-k">if</span>(c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>D<span class="pl-pds">'</span></span>){
                <span class="pl-k">if</span>(i <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> s<span class="pl-k">.</span>charAt(i<span class="pl-k">-</span><span class="pl-c1">1</span>) <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>C<span class="pl-pds">'</span></span>) res <span class="pl-k">+=</span> <span class="pl-c1">300</span>;
                <span class="pl-k">else</span> res <span class="pl-k">+=</span> <span class="pl-c1">500</span>;
            }<span class="pl-k">else</span> <span class="pl-k">if</span> (c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>M<span class="pl-pds">'</span></span>){
                <span class="pl-k">if</span>(i <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> s<span class="pl-k">.</span>charAt(i<span class="pl-k">-</span><span class="pl-c1">1</span>) <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>C<span class="pl-pds">'</span></span>) res <span class="pl-k">+=</span> <span class="pl-c1">800</span>;
                <span class="pl-k">else</span> res <span class="pl-k">+=</span> <span class="pl-c1">1000</span>;
            }
        }
        <span class="pl-k">return</span> res;
    }
</pre></div>

<p><strong>Solution2 code</strong>: Use hashmap</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> romanToInt(<span class="pl-smi">String</span> s) {
        <span class="pl-k">if</span>(s <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> s<span class="pl-k">.</span>length() <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> res <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">Map&lt;<span class="pl-smi">Character</span>, <span class="pl-smi">Integer</span>&gt;</span> map <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashMap&lt;<span class="pl-smi">Character</span>, <span class="pl-smi">Integer</span>&gt;</span>();
        map<span class="pl-k">.</span>put(<span class="pl-s"><span class="pl-pds">'</span>I<span class="pl-pds">'</span></span>, <span class="pl-c1">1</span>);
        map<span class="pl-k">.</span>put(<span class="pl-s"><span class="pl-pds">'</span>V<span class="pl-pds">'</span></span>, <span class="pl-c1">5</span>);
        map<span class="pl-k">.</span>put(<span class="pl-s"><span class="pl-pds">'</span>X<span class="pl-pds">'</span></span>, <span class="pl-c1">10</span>);
        map<span class="pl-k">.</span>put(<span class="pl-s"><span class="pl-pds">'</span>L<span class="pl-pds">'</span></span>, <span class="pl-c1">50</span>);
        map<span class="pl-k">.</span>put(<span class="pl-s"><span class="pl-pds">'</span>C<span class="pl-pds">'</span></span>, <span class="pl-c1">100</span>);
        map<span class="pl-k">.</span>put(<span class="pl-s"><span class="pl-pds">'</span>D<span class="pl-pds">'</span></span>, <span class="pl-c1">500</span>);
        map<span class="pl-k">.</span>put(<span class="pl-s"><span class="pl-pds">'</span>M<span class="pl-pds">'</span></span>, <span class="pl-c1">1000</span>);
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> s<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>){
            <span class="pl-k">char</span> c <span class="pl-k">=</span> s<span class="pl-k">.</span>charAt(i);
            <span class="pl-k">if</span>(c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>I<span class="pl-pds">'</span></span>) {
                res <span class="pl-k">+=</span> map<span class="pl-k">.</span>get(c);
                <span class="pl-k">continue</span>;
            }
            <span class="pl-k">if</span>(i <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> map<span class="pl-k">.</span>get(s<span class="pl-k">.</span>charAt(i<span class="pl-k">-</span><span class="pl-c1">1</span>)) <span class="pl-k">&lt;</span> map<span class="pl-k">.</span>get(c)) res <span class="pl-k">=</span> res <span class="pl-k">+</span> map<span class="pl-k">.</span>get(c) <span class="pl-k">-</span> <span class="pl-c1">2</span> <span class="pl-k">*</span> map<span class="pl-k">.</span>get(s<span class="pl-k">.</span>charAt(i<span class="pl-k">-</span><span class="pl-c1">1</span>));
            <span class="pl-k">else</span> res <span class="pl-k">+=</span> map<span class="pl-k">.</span>get(c);
        }
        <span class="pl-k">return</span> res;
    }
</pre></div>

<p><br></p>

<p><br></p>

<h3><a id="user-content-13-roman-to-integer" class="anchor" href="https://github.com/wishyouhappy/Algorithm#13-roman-to-integer" aria-hidden="true"><span class="octicon octicon-link"></span></a>13 Roman to Integer</h3>

<p><strong>Rules</strong>:</p>

<p>See detailed rules at <a href="https://github.com/wishyouhappy/Algorithm#12-integer-to-roman">12 Integer to Roman</a></p>

<p><strong>Idea</strong>: Just calculate each digit and append it to result string.</p>

<p><strong>Code</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-smi">String</span> intToRoman1(<span class="pl-k">int</span> num) {
        <span class="pl-k">if</span>(num <span class="pl-k">&lt;=</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> num <span class="pl-k">&gt;=</span> <span class="pl-c1">4000</span>) <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>;
        <span class="pl-k">int</span> divide <span class="pl-k">=</span> <span class="pl-c1">1000</span>;
        <span class="pl-k">int</span>[] digits <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[<span class="pl-c1">4</span>];
        <span class="pl-smi">StringBuilder</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">StringBuilder</span>();
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">3</span>; i <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> num <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>; i<span class="pl-k">--</span>){
            digits[i] <span class="pl-k">=</span> num<span class="pl-k">/</span>divide;
            num <span class="pl-k">=</span> num <span class="pl-k">%</span> divide;
            divide <span class="pl-k">/=</span> <span class="pl-c1">10</span>;
        }
        res<span class="pl-k">.</span>append(helper(digits[<span class="pl-c1">3</span>], <span class="pl-s"><span class="pl-pds">'</span>M<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span> <span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span> <span class="pl-pds">'</span></span>));
        res<span class="pl-k">.</span>append(helper(digits[<span class="pl-c1">2</span>], <span class="pl-s"><span class="pl-pds">'</span>C<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>D<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>M<span class="pl-pds">'</span></span>));
        res<span class="pl-k">.</span>append(helper(digits[<span class="pl-c1">1</span>], <span class="pl-s"><span class="pl-pds">'</span>X<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>L<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>C<span class="pl-pds">'</span></span>));
        res<span class="pl-k">.</span>append(helper(digits[<span class="pl-c1">0</span>], <span class="pl-s"><span class="pl-pds">'</span>I<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>V<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>X<span class="pl-pds">'</span></span>));
        <span class="pl-k">return</span> res<span class="pl-k">.</span>toString();
    }

    <span class="pl-k">public</span> <span class="pl-smi">String</span> helper(<span class="pl-k">int</span> i, <span class="pl-k">char</span> one, <span class="pl-k">char</span> five, <span class="pl-k">char</span> ten){
        <span class="pl-smi">StringBuilder</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">StringBuilder</span>();
        <span class="pl-k">switch</span>(i){
            <span class="pl-k">case</span> <span class="pl-c1">9</span><span class="pl-k">:</span> res<span class="pl-k">.</span>append(one <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span> <span class="pl-k">+</span> ten); <span class="pl-k">break</span>;
            <span class="pl-k">case</span> <span class="pl-c1">8</span><span class="pl-k">:</span> res<span class="pl-k">.</span>append(five <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span> <span class="pl-k">+</span> one <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span> <span class="pl-k">+</span> one <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span> <span class="pl-k">+</span> one); <span class="pl-k">break</span>;
            <span class="pl-k">case</span> <span class="pl-c1">7</span><span class="pl-k">:</span> res<span class="pl-k">.</span>append(five <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span> <span class="pl-k">+</span> one <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span> <span class="pl-k">+</span> one); <span class="pl-k">break</span>;
            <span class="pl-k">case</span> <span class="pl-c1">6</span><span class="pl-k">:</span> res<span class="pl-k">.</span>append(five <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span> <span class="pl-k">+</span> one); <span class="pl-k">break</span>;
            <span class="pl-k">case</span> <span class="pl-c1">5</span><span class="pl-k">:</span> res<span class="pl-k">.</span>append(five); <span class="pl-k">break</span>;
            <span class="pl-k">case</span> <span class="pl-c1">4</span><span class="pl-k">:</span> res<span class="pl-k">.</span>append(one <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span> <span class="pl-k">+</span> five); <span class="pl-k">break</span>;
            <span class="pl-k">case</span> <span class="pl-c1">3</span><span class="pl-k">:</span> res<span class="pl-k">.</span>append(one <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span> <span class="pl-k">+</span> one <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span> <span class="pl-k">+</span> one); <span class="pl-k">break</span>;
            <span class="pl-k">case</span> <span class="pl-c1">2</span><span class="pl-k">:</span> res<span class="pl-k">.</span>append(one <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span> <span class="pl-k">+</span> one); <span class="pl-k">break</span>;
            <span class="pl-k">case</span> <span class="pl-c1">1</span><span class="pl-k">:</span> res<span class="pl-k">.</span>append(one);
        }
        <span class="pl-k">return</span> res<span class="pl-k">.</span>toString();
    }</pre></div>

<p><strong>Better code on appending part</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-smi">String</span> intToRoman(<span class="pl-k">int</span> num) {
        <span class="pl-k">if</span>(num <span class="pl-k">&lt;=</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> num <span class="pl-k">&gt;=</span> <span class="pl-c1">4000</span>) <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>;
        <span class="pl-k">int</span> divide <span class="pl-k">=</span> <span class="pl-c1">1000</span>;
        <span class="pl-k">int</span>[] digits <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[<span class="pl-c1">4</span>];
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">3</span>; i <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> num <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>; i<span class="pl-k">--</span>){
             digits[i] <span class="pl-k">=</span> num<span class="pl-k">/</span>divide;
             num <span class="pl-k">=</span> num <span class="pl-k">%</span> divide;
             divide <span class="pl-k">/=</span> <span class="pl-c1">10</span>;
         }
        <span class="pl-smi">StringBuilder</span> result <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">StringBuilder</span>();
        result<span class="pl-k">.</span>append(convert(digits[<span class="pl-c1">3</span>], <span class="pl-s"><span class="pl-pds">'</span>M<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span> <span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span> <span class="pl-pds">'</span></span>));
        result<span class="pl-k">.</span>append(convert(digits[<span class="pl-c1">2</span>], <span class="pl-s"><span class="pl-pds">'</span>C<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>D<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>M<span class="pl-pds">'</span></span>));
        result<span class="pl-k">.</span>append(convert(digits[<span class="pl-c1">1</span>], <span class="pl-s"><span class="pl-pds">'</span>X<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>L<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>C<span class="pl-pds">'</span></span>));
        result<span class="pl-k">.</span>append(convert(digits[<span class="pl-c1">0</span>], <span class="pl-s"><span class="pl-pds">'</span>I<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>V<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>X<span class="pl-pds">'</span></span>));

        <span class="pl-k">return</span> result<span class="pl-k">.</span>toString();
    }

    <span class="pl-k">public</span> <span class="pl-smi">String</span> convert(<span class="pl-k">int</span> digit, <span class="pl-k">char</span> one, <span class="pl-k">char</span> five, <span class="pl-k">char</span> ten){
        <span class="pl-smi">StringBuilder</span> result <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">StringBuilder</span>();
        <span class="pl-k">switch</span>(digit)
        {
            <span class="pl-k">case</span> <span class="pl-c1">9</span><span class="pl-k">:</span>
                result<span class="pl-k">.</span>append(one);
                result<span class="pl-k">.</span>append(ten);
                <span class="pl-k">break</span>;
            <span class="pl-k">case</span> <span class="pl-c1">8</span><span class="pl-k">:</span>
            <span class="pl-k">case</span> <span class="pl-c1">7</span><span class="pl-k">:</span>
            <span class="pl-k">case</span> <span class="pl-c1">6</span><span class="pl-k">:</span>
            <span class="pl-k">case</span> <span class="pl-c1">5</span><span class="pl-k">:</span>
                result<span class="pl-k">.</span>append(five);
                <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">5</span>; i <span class="pl-k">&lt;</span> digit; i<span class="pl-k">++</span>) result<span class="pl-k">.</span>append(one);
                <span class="pl-k">break</span>;
            <span class="pl-k">case</span> <span class="pl-c1">4</span><span class="pl-k">:</span> 
                result<span class="pl-k">.</span>append(one);
                result<span class="pl-k">.</span>append(five);
                <span class="pl-k">break</span>;
            <span class="pl-k">case</span> <span class="pl-c1">3</span><span class="pl-k">:</span>
            <span class="pl-k">case</span> <span class="pl-c1">2</span><span class="pl-k">:</span>
            <span class="pl-k">case</span> <span class="pl-c1">1</span><span class="pl-k">:</span>
                <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> digit; i<span class="pl-k">++</span>) result<span class="pl-k">.</span>append(one);
                <span class="pl-k">break</span>;
            <span class="pl-k">default</span><span class="pl-k">:</span>
                <span class="pl-k">break</span>;
        }
        <span class="pl-k">return</span> result<span class="pl-k">.</span>toString();
    }
</pre></div>

<p><br></p>

<p><br></p>

<h3><a id="user-content-14-longest-common-prefix" class="anchor" href="https://github.com/wishyouhappy/Algorithm#14-longest-common-prefix" aria-hidden="true"><span class="octicon octicon-link"></span></a>14 Longest Common Prefix</h3>

<blockquote>
<p>Write a function to find the longest common prefix string amongst an array of strings.</p>
</blockquote>

<p><strong>Idea</strong>: Choose the first string, then compare each of its character with the strings in strs. Return result when a mismatch happens.</p>

<p><strong>Time complexity</strong>: O(n * m), n is the length of prefix string. M is the length of strs. </p>

<p><strong>Java code</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-smi">String</span> longestCommonPrefix(<span class="pl-k">String</span>[] strs) {
        <span class="pl-k">if</span>(strs <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> strs<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>;
        <span class="pl-smi">StringBuilder</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">StringBuilder</span>();
        <span class="pl-smi">String</span> s <span class="pl-k">=</span> strs[<span class="pl-c1">0</span>];
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> s<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>){
            <span class="pl-k">char</span> c <span class="pl-k">=</span> s<span class="pl-k">.</span>charAt(i);
            <span class="pl-k">for</span>(<span class="pl-k">int</span> j<span class="pl-k">=</span> <span class="pl-c1">1</span>; j <span class="pl-k">&lt;</span> strs<span class="pl-k">.</span>length; j<span class="pl-k">++</span>){
                <span class="pl-k">if</span>((i <span class="pl-k">&lt;</span> strs[j]<span class="pl-k">.</span>length() <span class="pl-k">&amp;&amp;</span> c <span class="pl-k">!=</span> strs[j]<span class="pl-k">.</span>charAt(i)) <span class="pl-k">||</span> i <span class="pl-k">&gt;=</span> strs[j]<span class="pl-k">.</span>length()) <span class="pl-k">return</span> res<span class="pl-k">.</span>toString();
            }
            res<span class="pl-k">.</span>append(c);
        }
        <span class="pl-k">return</span> res<span class="pl-k">.</span>toString();
    }

</pre></div>

<p><br></p>

<p><br></p>

<h3><a id="user-content-15-3sum" class="anchor" href="https://github.com/wishyouhappy/Algorithm#15-3sum" aria-hidden="true"><span class="octicon octicon-link"></span></a>15 3Sum</h3>

<blockquote>
<p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p>

<p>Note:</p>
</blockquote>

<ul>
<li><p>Elements in a triplet (a,b,c) must be in <strong>non-descending order</strong>. (ie, a ≤ b ≤ c)</p></li>
<li><p>The solution set <strong>must not contain duplicate triplets</strong>.</p>

<pre><code>For example, given array S = {-1 0 1 2 -1 -4},
A solution set is:
(-1, 0, 1)
(-1, -1, 2)
</code></pre></li>
</ul>

<p><strong>Idea</strong>: We need to find the three numbers triplets that sum to 0. We can change to this problem to two subproblems. Target + (-target) = 0, num1 + num2 = - target.
Thus we can use the method in two sum to solve this problem. For each number num1 in the array, we find the other two numbers that sum to -num1. </p>

<p>We first need to sort the array, then use two pointers to find the two sum numbers sum to -num1.</p>

<p><strong>Time</strong> O(n ^ 2)</p>

<p><strong>Space</strong> O(n ^ 2)</p>

<p><strong>Attention</strong>: </p>

<p>1) Silly check: num is null or num's length less than 3</p>

<p>2) <em>Duplication</em>: Both the threeSum and twoSum helper function need to check the duplication. If just need to check if the current is equal to the number before it. </p>

<p>3) Non-descending order</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> threeSum(<span class="pl-k">int</span>[] num) {
        <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> list <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>();
        <span class="pl-k">if</span>(num <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> num<span class="pl-k">.</span>length <span class="pl-k">&lt;</span> <span class="pl-c1">3</span>) <span class="pl-k">return</span> list;
        <span class="pl-smi">Arrays</span><span class="pl-k">.</span>sort(num);
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;=</span> num<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">3</span>; i<span class="pl-k">++</span>){
            <span class="pl-k">if</span>(i <span class="pl-k">!=</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> num[i] <span class="pl-k">==</span> num[i<span class="pl-k">-</span><span class="pl-c1">1</span>]) <span class="pl-k">continue</span>;
            <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> current <span class="pl-k">=</span> twoSum(num, i<span class="pl-k">+</span><span class="pl-c1">1</span>, <span class="pl-k">-</span>num[i]);
            <span class="pl-k">for</span>(<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> l <span class="pl-k">:</span> current ){
                l<span class="pl-k">.</span>add(<span class="pl-c1">0</span>, num[i]);
            }
            list<span class="pl-k">.</span>addAll(current);
        }
        <span class="pl-k">return</span> list;
    }

    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> twoSum(<span class="pl-k">int</span>[] num, <span class="pl-k">int</span> start, <span class="pl-k">int</span> target){
        <span class="pl-k">int</span> r <span class="pl-k">=</span> num<span class="pl-k">.</span>length <span class="pl-k">-</span><span class="pl-c1">1</span>;
        <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> list <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>();
        <span class="pl-k">int</span> l <span class="pl-k">=</span> start;
        <span class="pl-k">while</span>(l <span class="pl-k">&lt;</span> r){
            <span class="pl-k">if</span>(target <span class="pl-k">==</span> num[l] <span class="pl-k">+</span> num[r]){
                <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> cur <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
                cur<span class="pl-k">.</span>add(num[l]);
                cur<span class="pl-k">.</span>add(num[r]);
                list<span class="pl-k">.</span>add(cur);
                l<span class="pl-k">++</span>;
                r<span class="pl-k">--</span>;
                <span class="pl-k">while</span>(l <span class="pl-k">&lt;</span> r <span class="pl-k">&amp;&amp;</span> num[l] <span class="pl-k">==</span> num[l<span class="pl-k">-</span><span class="pl-c1">1</span>]) l<span class="pl-k">++</span>;
                <span class="pl-k">while</span>(l <span class="pl-k">&lt;</span> r <span class="pl-k">&amp;&amp;</span> num[r] <span class="pl-k">==</span> num[r<span class="pl-k">+</span><span class="pl-c1">1</span>]) r<span class="pl-k">--</span>;
            }<span class="pl-k">else</span> <span class="pl-k">if</span>(target <span class="pl-k">&lt;</span> num[l] <span class="pl-k">+</span> num[r])
                r<span class="pl-k">--</span>;
            <span class="pl-k">else</span> l<span class="pl-k">++</span>;
        }
        <span class="pl-k">return</span> list;
    }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-16-3sum-closest" class="anchor" href="https://github.com/wishyouhappy/Algorithm#16-3sum-closest" aria-hidden="true"><span class="octicon octicon-link"></span></a>16 3Sum Closest</h3>

<blockquote>
<p>Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. <strong>You may assume that each input would have exactly one solution</strong>.</p>
</blockquote>

<pre><code>For example, given array S = {-1 2 1 -4}, and target = 1.

The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
</code></pre>

<p><strong>Idea</strong>: It's much similar with the method in three sum, the only difference here is that we calculate the minimum difference use the twosum helper funtion for each item in the array. </p>

<p><strong>Attention</strong>: </p>

<p>1) Each time we compare the <strong>abs</strong> of the difference </p>

<p><strong>Time</strong> O(n ^ 2)</p>

<p><strong>Space</strong> O(1)</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> threeSumClosest(<span class="pl-k">int</span>[] num, <span class="pl-k">int</span> target) {
        <span class="pl-k">if</span>(num <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> num<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> res <span class="pl-k">=</span> <span class="pl-smi">Integer</span><span class="pl-c1"><span class="pl-k">.</span>MAX_VALUE</span>;
        <span class="pl-smi">Arrays</span><span class="pl-k">.</span>sort(num);
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;=</span> num<span class="pl-k">.</span>length <span class="pl-k">-</span><span class="pl-c1">3</span>; i<span class="pl-k">++</span>){
            <span class="pl-k">if</span>(i <span class="pl-k">!=</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> num[i] <span class="pl-k">==</span> num[i<span class="pl-k">-</span><span class="pl-c1">1</span>]) <span class="pl-k">continue</span>;
            <span class="pl-k">int</span> dif <span class="pl-k">=</span> twoSumClosest(num, i <span class="pl-k">+</span> <span class="pl-c1">1</span>, target<span class="pl-k">-</span>num[i]);
            <span class="pl-k">if</span>(<span class="pl-smi">Math</span><span class="pl-k">.</span>abs(dif) <span class="pl-k">&lt;</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>abs(res)) res <span class="pl-k">=</span> dif;
        }
        <span class="pl-k">return</span> res<span class="pl-k">+</span>target;
    }

    <span class="pl-k">public</span> <span class="pl-k">int</span> twoSumClosest(<span class="pl-k">int</span>[] num, <span class="pl-k">int</span> start, <span class="pl-k">int</span> target){
        <span class="pl-k">int</span> r <span class="pl-k">=</span> num<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>;
        <span class="pl-k">int</span> l <span class="pl-k">=</span> start;
        <span class="pl-k">int</span> res <span class="pl-k">=</span> <span class="pl-smi">Integer</span><span class="pl-c1"><span class="pl-k">.</span>MAX_VALUE</span>;
        <span class="pl-k">while</span>(l <span class="pl-k">&lt;</span> r){
            <span class="pl-k">if</span>(<span class="pl-smi">Math</span><span class="pl-k">.</span>abs(num[l] <span class="pl-k">+</span> num[r] <span class="pl-k">-</span> target) <span class="pl-k">&lt;</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>abs(res))
                res <span class="pl-k">=</span> num[l] <span class="pl-k">+</span> num[r] <span class="pl-k">-</span> target;
            <span class="pl-k">if</span>(num[l] <span class="pl-k">+</span> num[r] <span class="pl-k">==</span> target)
                <span class="pl-k">return</span> <span class="pl-c1">0</span>;
            <span class="pl-k">else</span> <span class="pl-k">if</span>(num[l] <span class="pl-k">+</span> num[r] <span class="pl-k">&gt;</span> target)
                r<span class="pl-k">--</span>;
            <span class="pl-k">else</span> 
                l<span class="pl-k">++</span>;

        }
        <span class="pl-k">return</span> res;
    }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-17-number-combinations-of-a-phone-number" class="anchor" href="https://github.com/wishyouhappy/Algorithm#17-number-combinations-of-a-phone-number" aria-hidden="true"><span class="octicon octicon-link"></span></a>17 Number Combinations of a Phone Number</h3>

<blockquote>
<p>Given a digit string, return all possible letter combinations that the number could represent.</p>

<p>A mapping of digit to letters (just like on the telephone buttons) is given below.</p>
</blockquote>

<pre>Input:Digit string "23"
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].

</pre>

<blockquote>
<p>Note:</p>

<p>Although the above answer is in lexicographical order, your answer could be in any order you want.</p>
</blockquote>

<p><strong>Idea</strong>: This problem is much similar to calculate the combinations. Each time we add each character of a string to all existing strings in the set. Then we go to the next String.</p>

<p><strong>Time Complexity</strong> : O(k ^ n), k is possible choice of each digit, n is the length of digits</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> letterCombinations(<span class="pl-smi">String</span> digits) {
        <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">String</span>&gt;</span>();
        <span class="pl-k">if</span>(digits <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> digits<span class="pl-k">.</span>length() <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> res;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> digits<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>){
            <span class="pl-smi">String</span> cur <span class="pl-k">=</span> getLetters(digits<span class="pl-k">.</span>charAt(i));
            <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> temp <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">String</span>&gt;</span>();
            <span class="pl-k">if</span>(res<span class="pl-k">.</span>size() <span class="pl-k">==</span> <span class="pl-c1">0</span>){
                <span class="pl-k">for</span>(<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;</span> cur<span class="pl-k">.</span>length(); j<span class="pl-k">++</span>){
                    res<span class="pl-k">.</span>add(cur<span class="pl-k">.</span>charAt(j) <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>);
                }
            }<span class="pl-k">else</span>{
                <span class="pl-k">for</span>(<span class="pl-smi">String</span> s <span class="pl-k">:</span> res){
                    <span class="pl-k">for</span>(<span class="pl-k">int</span> k <span class="pl-k">=</span> <span class="pl-c1">0</span>; k <span class="pl-k">&lt;</span> cur<span class="pl-k">.</span>length(); k<span class="pl-k">++</span>){
                        temp<span class="pl-k">.</span>add(s <span class="pl-k">+</span> cur<span class="pl-k">.</span>charAt(k));
                    }
                }
                res <span class="pl-k">=</span> temp;      
            }
        }
        <span class="pl-k">return</span> res;

    }

    <span class="pl-k">public</span> <span class="pl-smi">String</span> getLetters(<span class="pl-k">char</span> digit){
        <span class="pl-k">switch</span>(digit){
            <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">'</span>9<span class="pl-pds">'</span></span> <span class="pl-k">:</span> <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>wxyz<span class="pl-pds">"</span></span>;
            <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">'</span>8<span class="pl-pds">'</span></span> <span class="pl-k">:</span> <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>tuv<span class="pl-pds">"</span></span>;
            <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">'</span>7<span class="pl-pds">'</span></span> <span class="pl-k">:</span> <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>pqrs<span class="pl-pds">"</span></span>;
            <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">'</span>6<span class="pl-pds">'</span></span> <span class="pl-k">:</span> <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>mno<span class="pl-pds">"</span></span>;
            <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">'</span>5<span class="pl-pds">'</span></span> <span class="pl-k">:</span> <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>jkl<span class="pl-pds">"</span></span>;
            <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">'</span>4<span class="pl-pds">'</span></span> <span class="pl-k">:</span> <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>ghi<span class="pl-pds">"</span></span>;
            <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">'</span>3<span class="pl-pds">'</span></span> <span class="pl-k">:</span> <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>def<span class="pl-pds">"</span></span>;
         <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">'</span>2<span class="pl-pds">'</span></span> <span class="pl-k">:</span> <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>;
            <span class="pl-k">default</span><span class="pl-k">:</span> <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>;
        }
    }
</pre></div>

<p><br></p>

<p><br></p>

<h3><a id="user-content-18-4sum" class="anchor" href="https://github.com/wishyouhappy/Algorithm#18-4sum" aria-hidden="true"><span class="octicon octicon-link"></span></a>18 4Sum</h3>

<blockquote>
<p>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p>

<p>Note:</p>
</blockquote>

<ul>
<li><p>Elements in a quadruplet (a,b,c,d) must be in <strong>non-descending order</strong>. (ie, a ≤ b ≤ c ≤ d)</p></li>
<li><p>The solution set must <strong>not contain duplicate quadruplets</strong>.</p>

<p>For example, given array S = {1 0 -1 0 -2 2}, and target = 0.</p>

<pre><code>  A solution set is:
  (-1,  0, 0, 1)
  (-2, -1, 1, 2)
  (-2,  0, 0, 2)
</code></pre></li>
</ul>

<p><br></p>

<p><strong>Idea</strong>: Use the 3Sum to calculate 4Sum. </p>

<p><strong>Time</strong> O(n ^ 3)</p>

<p><strong>Space</strong> O(n ^ 2)</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> fourSum(<span class="pl-k">int</span>[] num, <span class="pl-k">int</span> target) {
        <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> list <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>();
        <span class="pl-k">if</span>(num <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> num<span class="pl-k">.</span>length <span class="pl-k">&lt;=</span> <span class="pl-c1">3</span>) <span class="pl-k">return</span> list;
        <span class="pl-smi">Arrays</span><span class="pl-k">.</span>sort(num);
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;=</span> num<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">4</span>; i<span class="pl-k">++</span>){
            <span class="pl-k">if</span>(i <span class="pl-k">!=</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> num[i] <span class="pl-k">==</span> num[i<span class="pl-k">-</span><span class="pl-c1">1</span>]) <span class="pl-k">continue</span>;
            <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> current <span class="pl-k">=</span> threeSum(num, i<span class="pl-k">+</span><span class="pl-c1">1</span>, target <span class="pl-k">-</span> num[i]);
            <span class="pl-k">for</span>(<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> l <span class="pl-k">:</span> current){
                l<span class="pl-k">.</span>add(<span class="pl-c1">0</span>, num[i]);
            }
            list<span class="pl-k">.</span>addAll(current);
        }
        <span class="pl-k">return</span> list;
    }

    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> threeSum(<span class="pl-k">int</span>[] num, <span class="pl-k">int</span> start, <span class="pl-k">int</span> target){
         <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> list <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>();
         <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> start; i <span class="pl-k">&lt;=</span> num<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">3</span>; i<span class="pl-k">++</span>){
             <span class="pl-k">if</span>(i <span class="pl-k">!=</span> start <span class="pl-k">&amp;&amp;</span> num[i] <span class="pl-k">==</span> num[i<span class="pl-k">-</span><span class="pl-c1">1</span>]) <span class="pl-k">continue</span>;
             <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> current <span class="pl-k">=</span> twoSum(num, i<span class="pl-k">+</span><span class="pl-c1">1</span>, target <span class="pl-k">-</span> num[i]);
              <span class="pl-k">for</span>(<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> l <span class="pl-k">:</span> current){
                l<span class="pl-k">.</span>add(<span class="pl-c1">0</span>, num[i]);
            }
            list<span class="pl-k">.</span>addAll(current);
         }
         <span class="pl-k">return</span> list;
    }

    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> twoSum(<span class="pl-k">int</span>[] num, <span class="pl-k">int</span> start, <span class="pl-k">int</span> target){
         <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> list <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>();
         <span class="pl-k">int</span> r <span class="pl-k">=</span> num<span class="pl-k">.</span>length <span class="pl-k">-</span><span class="pl-c1">1</span>;
         <span class="pl-k">int</span> l <span class="pl-k">=</span> start;
         <span class="pl-k">while</span>(l <span class="pl-k">&lt;</span> r){
             <span class="pl-k">if</span>(num[l] <span class="pl-k">+</span> num[r] <span class="pl-k">==</span> target){
                 <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> cur <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
                 cur<span class="pl-k">.</span>add(num[l]);
                 cur<span class="pl-k">.</span>add(num[r]);
                 list<span class="pl-k">.</span>add(cur);
                 l<span class="pl-k">++</span>;
                 r<span class="pl-k">--</span>;
                 <span class="pl-k">while</span>(l <span class="pl-k">&lt;</span> r <span class="pl-k">&amp;&amp;</span> num[l] <span class="pl-k">==</span> num[l<span class="pl-k">-</span><span class="pl-c1">1</span>]) l<span class="pl-k">++</span>;
                 <span class="pl-k">while</span>(l <span class="pl-k">&lt;</span> r <span class="pl-k">&amp;&amp;</span> num[r] <span class="pl-k">==</span> num[r<span class="pl-k">+</span><span class="pl-c1">1</span>]) r<span class="pl-k">--</span>;
             }<span class="pl-k">else</span> <span class="pl-k">if</span>(num[l] <span class="pl-k">+</span> num[r] <span class="pl-k">&lt;</span> target) l<span class="pl-k">++</span>;
             <span class="pl-k">else</span> r<span class="pl-k">--</span>;
         }
         <span class="pl-k">return</span> list;
    }
</pre></div>

<p><strong>Other Idea</strong>: </p>

<p>we can twoSum combine twoSum to calculate 4Sum. Time complexity would be O(n^2 * lgn)</p>

<p><br>
<br></p>

<h3><a id="user-content-19-remove-nth-node-from-end-of-list" class="anchor" href="https://github.com/wishyouhappy/Algorithm#19-remove-nth-node-from-end-of-list" aria-hidden="true"><span class="octicon octicon-link"></span></a>19 Remove Nth Node From End of List</h3>

<blockquote>
<p>Given a linked list, remove the nth node from the end of list and return its head.</p>
</blockquote>

<p>For example,</p>

<p>Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</p>

<p>After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.
Note:</p>

<p>Given n will always be valid.
Try to do this in one pass.</p>

<p><strong>Idea</strong>: Use two pointers, p1, p2. First move p1 k steps, then move p1 and p2 together until p1 change to null. At this time, p2 points to the node we need to delete. </p>

<p><strong>Attention</strong>: </p>

<ul>
<li>1) if after k steps, p1 is null, then return head.next</li>
<li>2) record pre</li>
</ul>

<p><br></p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-smi">ListNode</span> removeNthFromEnd(<span class="pl-smi">ListNode</span> head, <span class="pl-k">int</span> n) {
        <span class="pl-k">if</span>(head <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">return</span> <span class="pl-c1">null</span>;
        <span class="pl-smi">ListNode</span> l1 <span class="pl-k">=</span> head;
        <span class="pl-smi">ListNode</span> l2 <span class="pl-k">=</span> head;
        <span class="pl-k">while</span>(n <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>){
            l1 <span class="pl-k">=</span> l1<span class="pl-k">.</span>next;
            n<span class="pl-k">--</span>;
        }
        <span class="pl-k">if</span>(l1 <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">return</span> head<span class="pl-k">.</span>next;
        <span class="pl-smi">ListNode</span> pre <span class="pl-k">=</span> <span class="pl-c1">null</span>;
        <span class="pl-k">while</span>(l1 <span class="pl-k">!=</span> <span class="pl-c1">null</span>){
            pre <span class="pl-k">=</span> l2;
            l2 <span class="pl-k">=</span> l2<span class="pl-k">.</span>next;
            l1 <span class="pl-k">=</span> l1<span class="pl-k">.</span>next;
        }
        pre<span class="pl-k">.</span>next <span class="pl-k">=</span> l2<span class="pl-k">.</span>next;
        <span class="pl-k">return</span> head;
    }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-20-valid-parentheses" class="anchor" href="https://github.com/wishyouhappy/Algorithm#20-valid-parentheses" aria-hidden="true"><span class="octicon octicon-link"></span></a>20 Valid Parentheses</h3>

<blockquote>
<p>Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.</p>

<p>The brackets must close in the correct order, "()" and "()[]{}" are all valid but "(]" and "([)]" are not.</p>
</blockquote>

<p><strong>Idea</strong>: Use a stack to record parentheses. When encounter ( , [, { push to stack.
when encounter ), ], } pop corresponding parentheses.</p>

<p><strong>Java code</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">boolean</span> isValid(<span class="pl-smi">String</span> s) {
        <span class="pl-k">if</span>(s <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> s<span class="pl-k">.</span>length() <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">true</span>;
        <span class="pl-k">Stack&lt;<span class="pl-smi">Character</span>&gt;</span> stack <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">Stack&lt;<span class="pl-smi">Character</span>&gt;</span>();
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> s<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>){
            <span class="pl-k">char</span> c <span class="pl-k">=</span> s<span class="pl-k">.</span>charAt(i);
            <span class="pl-k">if</span>(stack<span class="pl-k">.</span>isEmpty() <span class="pl-k">&amp;&amp;</span> (c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>)<span class="pl-pds">'</span></span> <span class="pl-k">||</span> c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>]<span class="pl-pds">'</span></span> <span class="pl-k">||</span> c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>}<span class="pl-pds">'</span></span>)) <span class="pl-k">return</span> <span class="pl-c1">false</span>;
            <span class="pl-k">if</span>(c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>(<span class="pl-pds">'</span></span> <span class="pl-k">||</span> c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>[<span class="pl-pds">'</span></span> <span class="pl-k">||</span> c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>{<span class="pl-pds">'</span></span>) stack<span class="pl-k">.</span>push(c);
            <span class="pl-k">else</span> <span class="pl-k">if</span>(c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>)<span class="pl-pds">'</span></span> <span class="pl-k">||</span> c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>]<span class="pl-pds">'</span></span> <span class="pl-k">||</span> c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>}<span class="pl-pds">'</span></span>){
                <span class="pl-k">if</span>((c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>)<span class="pl-pds">'</span></span> <span class="pl-k">&amp;&amp;</span> stack<span class="pl-k">.</span>peek() <span class="pl-k">!=</span> <span class="pl-s"><span class="pl-pds">'</span>(<span class="pl-pds">'</span></span>) <span class="pl-k">||</span> (c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>]<span class="pl-pds">'</span></span> <span class="pl-k">&amp;&amp;</span> stack<span class="pl-k">.</span>peek() <span class="pl-k">!=</span> <span class="pl-s"><span class="pl-pds">'</span>[<span class="pl-pds">'</span></span>) <span class="pl-k">||</span> (c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>}<span class="pl-pds">'</span></span> <span class="pl-k">&amp;&amp;</span> stack<span class="pl-k">.</span>peek() <span class="pl-k">!=</span> <span class="pl-s"><span class="pl-pds">'</span>{<span class="pl-pds">'</span></span>)) 
                    <span class="pl-k">return</span> <span class="pl-c1">false</span>;
                <span class="pl-k">else</span> stack<span class="pl-k">.</span>pop();
            }
        }
        <span class="pl-k">return</span> stack<span class="pl-k">.</span>isEmpty();
    }

</pre></div>

<p><br></p>

<p><br></p>

<h3><a id="user-content-21-merge-two-sorted-lists" class="anchor" href="https://github.com/wishyouhappy/Algorithm#21-merge-two-sorted-lists" aria-hidden="true"><span class="octicon octicon-link"></span></a>21 Merge Two Sorted Lists</h3>

<blockquote>
<p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
</blockquote>

<p><strong>Attention</strong>:</p>

<ul>
<li>1) Use a fake head, thus we don't need to check if head is null</li>
</ul>

<div class="highlight highlight-java"><pre>       <span class="pl-k">public</span> <span class="pl-smi">ListNode</span> mergeTwoLists(<span class="pl-smi">ListNode</span> l1, <span class="pl-smi">ListNode</span> l2) {
        <span class="pl-k">if</span>(l1 <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">return</span> l2;
        <span class="pl-k">if</span>(l2 <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">return</span> l1;
        <span class="pl-smi">ListNode</span> fakeHead <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">ListNode</span>(<span class="pl-k">-</span><span class="pl-c1">1</span>);
        <span class="pl-smi">ListNode</span> temp <span class="pl-k">=</span> fakeHead;
        <span class="pl-k">while</span>(l1 <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> l2 <span class="pl-k">!=</span> <span class="pl-c1">null</span>){
            <span class="pl-k">if</span>(l1<span class="pl-k">.</span>val <span class="pl-k">&gt;</span> l2<span class="pl-k">.</span>val){
                temp<span class="pl-k">.</span>next <span class="pl-k">=</span> l2;
                l2 <span class="pl-k">=</span> l2<span class="pl-k">.</span>next;
            }<span class="pl-k">else</span>{
                temp<span class="pl-k">.</span>next <span class="pl-k">=</span> l1;
                l1 <span class="pl-k">=</span> l1<span class="pl-k">.</span>next;
            }
            temp <span class="pl-k">=</span> temp<span class="pl-k">.</span>next;
        }
        <span class="pl-k">if</span>(l1 <span class="pl-k">!=</span> <span class="pl-c1">null</span>) temp<span class="pl-k">.</span>next <span class="pl-k">=</span> l1;
        <span class="pl-k">if</span>(l2 <span class="pl-k">!=</span> <span class="pl-c1">null</span>) temp<span class="pl-k">.</span>next <span class="pl-k">=</span> l2;
        <span class="pl-k">return</span> fakeHead<span class="pl-k">.</span>next;
    }  </pre></div>

<p><br>
<br></p>

<h3><a id="user-content-22-generate-parentheses" class="anchor" href="https://github.com/wishyouhappy/Algorithm#22-generate-parentheses" aria-hidden="true"><span class="octicon octicon-link"></span></a>22 Generate Parentheses</h3>

<blockquote>
<p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>

<p>For example, given n = 3, a solution set is:</p>

<p>"((()))", "(()())", "(())()", "()(())", "()()()"</p>
</blockquote>

<p><strong>Idea</strong>: insert "()" to possible spots of every parentheses string. eg : (), we have three spaces to insert. Inspite of duplicates, there are two possible ()() or (()). </p>

<p>*<em>Iterative code *</em>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> generateParenthesis(<span class="pl-k">int</span> n) {
        <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">String</span>&gt;</span>();
        res<span class="pl-k">.</span>add(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>);
        <span class="pl-k">if</span>(n <span class="pl-k">&lt;=</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> res;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> n; i<span class="pl-k">++</span>){
            <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> cur <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">String</span>&gt;</span>();
            <span class="pl-k">for</span>(<span class="pl-smi">String</span> s <span class="pl-k">:</span> res){
                <span class="pl-k">for</span>(<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;=</span> s<span class="pl-k">.</span>length(); j<span class="pl-k">++</span>){
                    <span class="pl-smi">String</span> temp <span class="pl-k">=</span>  s<span class="pl-k">.</span>substring(<span class="pl-c1">0</span>, j) <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>()<span class="pl-pds">"</span></span> <span class="pl-k">+</span> s<span class="pl-k">.</span>substring(j, s<span class="pl-k">.</span>length());
                    <span class="pl-k">if</span>(<span class="pl-k">!</span>cur<span class="pl-k">.</span>contains(temp)) cur<span class="pl-k">.</span>add(temp);
                }
            }
            res <span class="pl-k">=</span> cur;
        }
        <span class="pl-k">return</span> res;
    }
</pre></div>

<p><strong>Recursion</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> generateParenthesis1(<span class="pl-k">int</span> n) {
        <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> list <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">String</span>&gt;</span>();
        <span class="pl-k">if</span>(n <span class="pl-k">==</span> <span class="pl-c1">0</span>){
            list<span class="pl-k">.</span>add(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>);
            <span class="pl-k">return</span> list;
        }<span class="pl-k">else</span> <span class="pl-k">if</span> (n <span class="pl-k">==</span> <span class="pl-c1">1</span>){
            list<span class="pl-k">.</span>add(<span class="pl-s"><span class="pl-pds">"</span>()<span class="pl-pds">"</span></span>);
            <span class="pl-k">return</span> list;
        }

        <span class="pl-k">return</span> helper(n);

    }

    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> helper(<span class="pl-k">int</span> n){
        <span class="pl-k">if</span>(n <span class="pl-k">==</span> <span class="pl-c1">0</span>){
            <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> list <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">String</span>&gt;</span>();
            list<span class="pl-k">.</span>add(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>);
            <span class="pl-k">return</span> list;
        }
        <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> list  <span class="pl-k">=</span> helper(n<span class="pl-k">-</span><span class="pl-c1">1</span>);
        <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> result <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">String</span>&gt;</span>();
        <span class="pl-k">for</span>(<span class="pl-smi">String</span> s <span class="pl-k">:</span> list){
            <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>, len <span class="pl-k">=</span> s<span class="pl-k">.</span>length(); i <span class="pl-k">&lt;=</span> len; i<span class="pl-k">++</span>){
                <span class="pl-smi">String</span> newS <span class="pl-k">=</span> s<span class="pl-k">.</span>substring(<span class="pl-c1">0</span>, i) <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>()<span class="pl-pds">"</span></span> <span class="pl-k">+</span> s<span class="pl-k">.</span>substring(i, s<span class="pl-k">.</span>length());
                <span class="pl-k">if</span>(<span class="pl-k">!</span>result<span class="pl-k">.</span>contains(newS)) result<span class="pl-k">.</span>add(newS);
            }
        }
        <span class="pl-k">return</span> result;
    }
</pre></div>

<p><br></p>

<p><br></p>

<h3><a id="user-content-23-merge-k-sorted-lists" class="anchor" href="https://github.com/wishyouhappy/Algorithm#23-merge-k-sorted-lists" aria-hidden="true"><span class="octicon octicon-link"></span></a>23 Merge k Sorted Lists</h3>

<blockquote>
<p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p>
</blockquote>

<p><strong>Idea</strong>:</p>

<p>1) Solution1:</p>

<p>Use priorityqueue, add the head of k lists two queue, each time poll the smallest element from the queue then add the smallest.next to the queue until queue is empty. We need to to give another another parameter to priorityqueue when initialize.</p>

<div class="highlight highlight-java"><pre>    <span class="pl-smi">PriorityQueue</span> queue <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">PriorityQueue</span>(size, <span class="pl-k">new</span> <span class="pl-k">Comparator&lt;<span class="pl-smi">ListNode</span>&gt;</span>(){
        <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">compare</span>(<span class="pl-smi">ListNode</span> <span class="pl-v">arg1</span>, <span class="pl-smi">ListNode</span> <span class="pl-v">arg2</span>){
            <span class="pl-k">return</span> arg1 <span class="pl-k">-</span> arg2;
        }
    });
</pre></div>

<p><strong>Time complexity: nklgk</strong> (lgk for insert element, nk elements).</p>

<p><strong>Space</strong> O(k)</p>

<p>2) Solution2:</p>

<p>Use the idea in merge sort and use the method in <a href="https://github.com/wishyouhappy/Algorithm#21-merge-two-sorted-lists">21 Merge Two Sorted Lists</a> to merge two elements.</p>

<p><strong>Time</strong>: O(knlgk)</p>

<p><strong>Solution1 code</strong>:</p>

<p><br></p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">ListNode</span> mergeKLists(<span class="pl-k">List&lt;<span class="pl-smi">ListNode</span>&gt;</span> lists){
        <span class="pl-k">if</span>(lists <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> lists<span class="pl-k">.</span>size() <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">null</span>;
        <span class="pl-smi">ListNode</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">ListNode</span>(<span class="pl-k">-</span><span class="pl-c1">1</span>);
        <span class="pl-smi">ListNode</span> h1 <span class="pl-k">=</span> res;
        <span class="pl-k">PriorityQueue&lt;<span class="pl-smi">ListNode</span>&gt;</span> queue <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">PriorityQueue&lt;<span class="pl-smi">ListNode</span>&gt;</span>(lists<span class="pl-k">.</span>size(),<span class="pl-k">new</span> <span class="pl-k">Comparator&lt;<span class="pl-smi">ListNode</span>&gt;</span>(){
            <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">compare</span>(<span class="pl-smi">ListNode</span> <span class="pl-v">l1</span>, <span class="pl-smi">ListNode</span> <span class="pl-v">l2</span>){
                <span class="pl-k">return</span> l1<span class="pl-k">.</span>val <span class="pl-k">-</span> l2<span class="pl-k">.</span>val;
            }
        });
        <span class="pl-k">for</span>(<span class="pl-smi">ListNode</span> l <span class="pl-k">:</span> lists){
            <span class="pl-k">if</span>(l <span class="pl-k">!=</span> <span class="pl-c1">null</span>) queue<span class="pl-k">.</span>add(l);
        }
        <span class="pl-k">while</span>(<span class="pl-k">!</span>queue<span class="pl-k">.</span>isEmpty()){
            <span class="pl-smi">ListNode</span> current <span class="pl-k">=</span> queue<span class="pl-k">.</span>poll();
            h1<span class="pl-k">.</span>next <span class="pl-k">=</span> current;
            h1 <span class="pl-k">=</span> h1<span class="pl-k">.</span>next;
            <span class="pl-k">if</span>(current<span class="pl-k">.</span>next <span class="pl-k">!=</span> <span class="pl-c1">null</span>)
                queue<span class="pl-k">.</span>offer(current<span class="pl-k">.</span>next);
        }
        <span class="pl-k">return</span> res<span class="pl-k">.</span>next;
    }</pre></div>

<p><strong>Solution 2 code</strong></p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span>  <span class="pl-smi">ListNode</span> mergeKLists1(<span class="pl-k">List&lt;<span class="pl-smi">ListNode</span>&gt;</span> lists){
          <span class="pl-k">if</span>(lists <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> lists<span class="pl-k">.</span>size() <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">null</span>;
          <span class="pl-k">return</span> helper(lists, <span class="pl-c1">0</span>, lists<span class="pl-k">.</span>size()<span class="pl-k">-</span><span class="pl-c1">1</span>);
        }
        <span class="pl-k">public</span> <span class="pl-smi">ListNode</span> helper(<span class="pl-k">List&lt;<span class="pl-smi">ListNode</span>&gt;</span> lists, <span class="pl-k">int</span> start, <span class="pl-k">int</span> end){
            <span class="pl-k">if</span>(start <span class="pl-k">&gt;=</span> end) <span class="pl-k">return</span> lists<span class="pl-k">.</span>get(start);
            <span class="pl-k">int</span> mid <span class="pl-k">=</span> (start <span class="pl-k">+</span> end)<span class="pl-k">/</span><span class="pl-c1">2</span>;
            <span class="pl-k">return</span> mergeTwoLists(helper(lists, start, mid), helper(lists, mid<span class="pl-k">+</span><span class="pl-c1">1</span>, end));
        }

    <span class="pl-k">public</span> <span class="pl-smi">ListNode</span> mergeTwoLists(<span class="pl-smi">ListNode</span> l1, <span class="pl-smi">ListNode</span> l2) {
        <span class="pl-k">if</span>(l1 <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">return</span> l2;
        <span class="pl-k">if</span>(l2 <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">return</span> l1;
        <span class="pl-smi">ListNode</span> fakeHead <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">ListNode</span>(<span class="pl-k">-</span><span class="pl-c1">1</span>);
        <span class="pl-smi">ListNode</span> temp <span class="pl-k">=</span> fakeHead;
        <span class="pl-k">while</span>(l1 <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> l2 <span class="pl-k">!=</span> <span class="pl-c1">null</span>){
            <span class="pl-k">if</span>(l1<span class="pl-k">.</span>val <span class="pl-k">&gt;</span> l2<span class="pl-k">.</span>val){
                temp<span class="pl-k">.</span>next <span class="pl-k">=</span> l2;
                l2 <span class="pl-k">=</span> l2<span class="pl-k">.</span>next;
            }<span class="pl-k">else</span>{
                temp<span class="pl-k">.</span>next <span class="pl-k">=</span> l1;
                l1 <span class="pl-k">=</span> l1<span class="pl-k">.</span>next;
            }
            temp <span class="pl-k">=</span> temp<span class="pl-k">.</span>next;
        }
        <span class="pl-k">if</span>(l1 <span class="pl-k">!=</span> <span class="pl-c1">null</span>) temp<span class="pl-k">.</span>next <span class="pl-k">=</span> l1;
        <span class="pl-k">if</span>(l2 <span class="pl-k">!=</span> <span class="pl-c1">null</span>) temp<span class="pl-k">.</span>next <span class="pl-k">=</span> l2;
        <span class="pl-k">return</span> fakeHead<span class="pl-k">.</span>next;
    }</pre></div>

<p><strong>Brute force</strong> time limit exceeded</p>

<div class="highlight highlight-java"><pre>method1<span class="pl-k">:</span> each time find the minimum from the k nodes, and add it to the result list. <span class="pl-smi">Time</span> k <span class="pl-k">*</span> n <span class="pl-k">*</span> k <span class="pl-k">=</span> O(k<span class="pl-k">^</span><span class="pl-c1">2</span><span class="pl-k">*</span>n)

     <span class="pl-c">/* Brute force: time limit exceeded*/</span>
        <span class="pl-k">public</span>  <span class="pl-smi">ListNode</span> mergeKLists2(<span class="pl-k">List&lt;<span class="pl-smi">ListNode</span>&gt;</span> lists){
            <span class="pl-k">if</span>(lists <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> lists<span class="pl-k">.</span>size() <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">null</span>;
            <span class="pl-smi">ListNode</span> head <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">ListNode</span>(<span class="pl-k">-</span><span class="pl-c1">1</span>);
            <span class="pl-smi">ListNode</span> temp <span class="pl-k">=</span> head;
            <span class="pl-k">List&lt;<span class="pl-smi">ListNode</span>&gt;</span> l <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">ListNode</span>&gt;</span>();
            <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> lists<span class="pl-k">.</span>size(); i<span class="pl-k">++</span>){
                <span class="pl-k">if</span>(lists<span class="pl-k">.</span>get(i) <span class="pl-k">!=</span> <span class="pl-c1">null</span>) l<span class="pl-k">.</span>add(lists<span class="pl-k">.</span>get(i));
            }
            <span class="pl-k">while</span>(l<span class="pl-k">.</span>size() <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>){
                <span class="pl-k">int</span> min <span class="pl-k">=</span> <span class="pl-c1">0</span>;
                <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> l<span class="pl-k">.</span>size(); i<span class="pl-k">++</span>){
                    <span class="pl-k">if</span>(l<span class="pl-k">.</span>get(i) <span class="pl-k">==</span> <span class="pl-c1">null</span>) l<span class="pl-k">.</span>remove(i);
                    <span class="pl-k">else</span> {
                        <span class="pl-k">if</span>(l<span class="pl-k">.</span>get(i)<span class="pl-k">.</span>val <span class="pl-k">&lt;</span> l<span class="pl-k">.</span>get(min)<span class="pl-k">.</span>val) min <span class="pl-k">=</span> i;
                    }
                }
                <span class="pl-k">if</span>(l<span class="pl-k">.</span>size() <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>){
                    temp<span class="pl-k">.</span>next <span class="pl-k">=</span> l<span class="pl-k">.</span>get(min);
                    <span class="pl-k">if</span>(l<span class="pl-k">.</span>get(min)<span class="pl-k">.</span>next <span class="pl-k">!=</span> <span class="pl-c1">null</span>) l<span class="pl-k">.</span>set(min,l<span class="pl-k">.</span>get(min)<span class="pl-k">.</span>next);
                    <span class="pl-k">else</span> l<span class="pl-k">.</span>remove(min);
                    temp <span class="pl-k">=</span> temp<span class="pl-k">.</span>next;
                }
            }
            <span class="pl-k">return</span> head<span class="pl-k">.</span>next;
        }
</pre></div>

<p>method2: each time merge two lists, until all lists are merged.</p>

<div class="highlight highlight-java"><pre>    <span class="pl-c">/*Brute force, use merge2 method */</span>
    <span class="pl-k">public</span>  <span class="pl-smi">ListNode</span> mergeKLists3(<span class="pl-k">List&lt;<span class="pl-smi">ListNode</span>&gt;</span> lists) {
        <span class="pl-k">if</span>( lists <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> lists<span class="pl-k">.</span>size() <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">null</span>;
        <span class="pl-smi">ListNode</span> result <span class="pl-k">=</span> lists<span class="pl-k">.</span>get(<span class="pl-c1">0</span>);
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;</span> lists<span class="pl-k">.</span>size(); i<span class="pl-k">++</span>){
            <span class="pl-smi">ListNode</span> currentList <span class="pl-k">=</span> lists<span class="pl-k">.</span>get(i);
            result <span class="pl-k">=</span> mergeTwoLists(result, currentList);

        }

        <span class="pl-k">return</span> result;
    }
</pre></div>

<p><br></p>

<p><strong>Related</strong>: Merge k sorted array.</p>

<p><strong>Idea</strong>: for array, there is a difference with linkedlist, since linkedlist has the next pointer, which let us easily find the next element. For array, we need to record the index.</p>

<p><strong>Solution</strong>:</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Solution</span> {
  <span class="pl-k">class</span> <span class="pl-en">Element</span> {
    <span class="pl-k">int</span> row;
    <span class="pl-k">int</span> col;
    <span class="pl-k">int</span> val;
    <span class="pl-en">Element</span>(<span class="pl-k">int</span> <span class="pl-v">row</span>, <span class="pl-k">int</span> <span class="pl-v">col</span>, <span class="pl-k">int</span> <span class="pl-v">val</span>) {
      <span class="pl-v">this</span><span class="pl-k">.</span>row <span class="pl-k">=</span> row;
      <span class="pl-v">this</span><span class="pl-k">.</span>col <span class="pl-k">=</span> col;
      <span class="pl-v">this</span><span class="pl-k">.</span>val <span class="pl-k">=</span> val;
    }
  }
  <span class="pl-k">public</span> <span class="pl-k">int</span>[] <span class="pl-en">merge</span>(<span class="pl-k">int</span>[][] <span class="pl-v">arrayOfArrays</span>) {
    <span class="pl-k">if</span> (arrayOfArrays <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span> <span class="pl-c1">null</span>;
    }
    <span class="pl-k">if</span> (arrayOfArrays<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
      <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[<span class="pl-c1">0</span>];
    }
    <span class="pl-k">PriorityQueue&lt;<span class="pl-smi">Element</span>&gt;</span> queue <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">PriorityQueue&lt;<span class="pl-smi">Element</span>&gt;</span>(arrayOfArrays<span class="pl-k">.</span>length, <span class="pl-k">new</span> <span class="pl-k">Comparator&lt;<span class="pl-smi">Element</span>&gt;</span>() {
      <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">compare</span>(<span class="pl-smi">Element</span> <span class="pl-v">e1</span>, <span class="pl-smi">Element</span> <span class="pl-v">e2</span>) {
        <span class="pl-k">return</span> e1<span class="pl-k">.</span>val <span class="pl-k">-</span> e2<span class="pl-k">.</span>val;
      }
    });
    <span class="pl-k">int</span> len <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> arrayOfArrays<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
      <span class="pl-k">if</span> (arrayOfArrays[i] <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> arrayOfArrays[i]<span class="pl-k">.</span>length <span class="pl-k">!=</span> <span class="pl-c1">0</span>) {
        len <span class="pl-k">+=</span> arrayOfArrays[i]<span class="pl-k">.</span>length;
        queue<span class="pl-k">.</span>offer(<span class="pl-k">new</span> <span class="pl-smi">Element</span>(i, <span class="pl-c1">0</span>, arrayOfArrays[i][<span class="pl-c1">0</span>]));
      }
    }
    <span class="pl-k">int</span>[] res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[len];
    <span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">while</span>(<span class="pl-k">!</span>queue<span class="pl-k">.</span>isEmpty()) {
      <span class="pl-smi">Element</span> e <span class="pl-k">=</span> queue<span class="pl-k">.</span>poll();
      res[i<span class="pl-k">++</span>] <span class="pl-k">=</span> e<span class="pl-k">.</span>val;
      <span class="pl-k">if</span> (e<span class="pl-k">.</span>col <span class="pl-k">+</span> <span class="pl-c1">1</span> <span class="pl-k">&lt;</span> arrayOfArrays[e<span class="pl-k">.</span>row]<span class="pl-k">.</span>length) {
        queue<span class="pl-k">.</span>offer(<span class="pl-k">new</span> <span class="pl-smi">Element</span>(e<span class="pl-k">.</span>row, e<span class="pl-k">.</span>col <span class="pl-k">+</span> <span class="pl-c1">1</span>, arrayOfArrays[e<span class="pl-k">.</span>row][e<span class="pl-k">.</span>col <span class="pl-k">+</span> <span class="pl-c1">1</span>]));
      }
    }
    <span class="pl-k">return</span> res;
  }
}
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-24-swap-nodes-in-pairs" class="anchor" href="https://github.com/wishyouhappy/Algorithm#24-swap-nodes-in-pairs" aria-hidden="true"><span class="octicon octicon-link"></span></a>24 Swap Nodes in Pairs</h3>

<blockquote>
<p>Given a linked list, swap every two adjacent nodes and return its head.</p>
</blockquote>

<p>For example,
Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</p>

<p>Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.</p>

<p><strong>Idea</strong>: Just swap pair each time until end. </p>

<p><strong>Attention</strong>: If the number of nodes is odd, we need to add the last node to the list.</p>

<div class="highlight highlight-java"><pre>   <span class="pl-k">public</span> <span class="pl-smi">ListNode</span> swapPairs(<span class="pl-smi">ListNode</span> head) {
        <span class="pl-k">if</span>(head <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> head<span class="pl-k">.</span>next <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">return</span> head;
        <span class="pl-smi">ListNode</span> fakeHead <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">ListNode</span>(<span class="pl-k">-</span><span class="pl-c1">1</span>);
        <span class="pl-smi">ListNode</span> temp <span class="pl-k">=</span> fakeHead;
        <span class="pl-k">while</span>(head <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> head<span class="pl-k">.</span>next <span class="pl-k">!=</span> <span class="pl-c1">null</span>){
            <span class="pl-smi">ListNode</span> nextnext <span class="pl-k">=</span> head<span class="pl-k">.</span>next<span class="pl-k">.</span>next;
            temp<span class="pl-k">.</span>next <span class="pl-k">=</span> head<span class="pl-k">.</span>next;
            temp<span class="pl-k">.</span>next<span class="pl-k">.</span>next <span class="pl-k">=</span> head;
            temp <span class="pl-k">=</span> head;
            head <span class="pl-k">=</span> nextnext;
        }
        temp<span class="pl-k">.</span>next <span class="pl-k">=</span> head;
        <span class="pl-k">return</span> fakeHead<span class="pl-k">.</span>next;
      }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-25-reverse-nodes-in-kgroup" class="anchor" href="https://github.com/wishyouhappy/Algorithm#25-reverse-nodes-in-kgroup" aria-hidden="true"><span class="octicon octicon-link"></span></a>25 Reverse Nodes in kGroup</h3>

<blockquote>
<p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p>

<p>If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p>

<p>You may not alter the values in the nodes, only nodes itself may be changed.</p>

<p>Only constant memory is allowed.</p>

<p>For example,</p>

<p>Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</p>

<p>For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</p>

<p>For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5r</p>
</blockquote>

<p><strong>Idea</strong>: Reverse k nodes each time then catenenate the current reverse list with the previous reverse list.</p>

<p><strong>Attention</strong>:</p>

<ul>
<li>1)the left-out nodes less than k nodes should remain the same.</li>
<li>2)For the first node of each reverse list, we should set it's next to null to avoid cycle or double linked list. </li>
</ul>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-smi">ListNode</span> reverseKGroup(<span class="pl-smi">ListNode</span> head, <span class="pl-k">int</span> k) {
        <span class="pl-k">if</span>(head <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> head<span class="pl-k">.</span>next <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> k <span class="pl-k">&lt;=</span> <span class="pl-c1">1</span>) <span class="pl-k">return</span> head;
        <span class="pl-k">int</span> len <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-smi">ListNode</span> temp <span class="pl-k">=</span> head;
        <span class="pl-k">while</span>(temp <span class="pl-k">!=</span> <span class="pl-c1">null</span>){
            len<span class="pl-k">++</span>;
            temp <span class="pl-k">=</span> temp<span class="pl-k">.</span>next;
        }
        <span class="pl-k">if</span>(k <span class="pl-k">&gt;</span> len) <span class="pl-k">return</span> head;
        <span class="pl-smi">ListNode</span> res <span class="pl-k">=</span> <span class="pl-c1">null</span>, cur <span class="pl-k">=</span> <span class="pl-c1">null</span>, pre <span class="pl-k">=</span> <span class="pl-c1">null</span>, next <span class="pl-k">=</span> <span class="pl-c1">null</span>, savehead <span class="pl-k">=</span> <span class="pl-c1">null</span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;=</span> len <span class="pl-k">&amp;&amp;</span> i <span class="pl-k">+</span> k <span class="pl-k">&lt;=</span> len<span class="pl-k">+</span><span class="pl-c1">1</span>; i <span class="pl-k">+=</span> k){
            savehead <span class="pl-k">=</span> head;
            <span class="pl-k">for</span>(<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">1</span>; j <span class="pl-k">&lt;=</span> k; j<span class="pl-k">++</span>){
                next <span class="pl-k">=</span> head<span class="pl-k">.</span>next;
                <span class="pl-k">if</span>(cur <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
                    cur <span class="pl-k">=</span> head;
                    cur<span class="pl-k">.</span>next <span class="pl-k">=</span> <span class="pl-c1">null</span>;
                }<span class="pl-k">else</span>{
                    head<span class="pl-k">.</span>next <span class="pl-k">=</span> cur;
                    cur <span class="pl-k">=</span> head;
                }
                head <span class="pl-k">=</span> next;
            }
            <span class="pl-k">if</span>(res <span class="pl-k">==</span> <span class="pl-c1">null</span>) res <span class="pl-k">=</span> cur;
            <span class="pl-k">else</span>{
                pre<span class="pl-k">.</span>next <span class="pl-k">=</span> cur;
            }
            pre <span class="pl-k">=</span> savehead;
            cur <span class="pl-k">=</span> <span class="pl-c1">null</span>;
        }

        <span class="pl-k">if</span>(head <span class="pl-k">!=</span> <span class="pl-c1">null</span>) pre<span class="pl-k">.</span>next <span class="pl-k">=</span> head;
        <span class="pl-k">return</span> res;
    }
</pre></div>

<p><br></p>

<p><br></p>

<h3><a id="user-content-26-remove-duplicates-from-sorted-array" class="anchor" href="https://github.com/wishyouhappy/Algorithm#26-remove-duplicates-from-sorted-array" aria-hidden="true"><span class="octicon octicon-link"></span></a>26 Remove Duplicates from Sorted Array</h3>

<blockquote>
<p>Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.</p>

<p>Do not allocate extra space for another array, you must do this in place with constant memory.</p>

<p>For example,</p>

<p>Given input array A = [1,1,2],</p>

<p>Your function should return length = 2, and A is now [1,2].</p>
</blockquote>

<p><strong>Idea</strong>: Record an index, all element before this index contains no duplicates. Insert the new unduplicate element at index. </p>

<p><strong>Java code</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> removeDuplicates(<span class="pl-k">int</span>[] <span class="pl-smi">A</span>) {
        <span class="pl-k">if</span>(<span class="pl-smi">A</span> <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        <span class="pl-k">if</span>(<span class="pl-smi">A</span><span class="pl-k">.</span>length <span class="pl-k">&lt;=</span> <span class="pl-c1">1</span>) <span class="pl-k">return</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length;
        <span class="pl-k">int</span> count <span class="pl-k">=</span> <span class="pl-c1">1</span>;
        <span class="pl-k">int</span> pre <span class="pl-k">=</span> <span class="pl-k">A</span>[<span class="pl-c1">0</span>];
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length; i<span class="pl-k">++</span>){
            <span class="pl-k">if</span>(<span class="pl-k">A</span>[i] <span class="pl-k">==</span> pre) <span class="pl-k">continue</span>;
            <span class="pl-k">A</span>[count<span class="pl-k">++</span>] <span class="pl-k">=</span> <span class="pl-k">A</span>[i];
            pre <span class="pl-k">=</span> <span class="pl-k">A</span>[i];
        }
        <span class="pl-k">return</span> count;
    }
</pre></div>

<p><br></p>

<p><br></p>

<h3><a id="user-content-27-remove-element" class="anchor" href="https://github.com/wishyouhappy/Algorithm#27-remove-element" aria-hidden="true"><span class="octicon octicon-link"></span></a>27 Remove Element</h3>

<blockquote>
<p>Given an array and a value, remove all instances of that value in place and return the new length.</p>

<p>The order of elements can be changed. It doesn't matter what you leave beyond the new length</p>
</blockquote>

<p><strong>Idea</strong>: if A[i] != elem, copy element to record index. </p>

<p><strong>Java Code</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> removeElement(<span class="pl-k">int</span>[] <span class="pl-smi">A</span>, <span class="pl-k">int</span> elem) {
        <span class="pl-k">if</span>(<span class="pl-smi">A</span> <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> count <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length; i<span class="pl-k">++</span>){
            <span class="pl-k">if</span>(<span class="pl-k">A</span>[i] <span class="pl-k">==</span> elem) <span class="pl-k">continue</span>;
            <span class="pl-k">A</span>[count<span class="pl-k">++</span>] <span class="pl-k">=</span> <span class="pl-k">A</span>[i];
        }
        <span class="pl-k">return</span> count;
    }

</pre></div>

<p><br></p>

<p><strong>Related</strong>: Remove Adjacent Repeated Characters</p>

<blockquote>
<p>eg: “aaaabbbc” : “abc”</p>
</blockquote>

<p><strong>Idea</strong>: Left and right pointer</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-smi">String</span> deDup(<span class="pl-smi">String</span> input) {
    <span class="pl-k">if</span> (input <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> input<span class="pl-k">.</span>length() <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
      <span class="pl-k">return</span> input;
    }
    <span class="pl-k">char</span>[] arr <span class="pl-k">=</span> input<span class="pl-k">.</span>toCharArray();
    <span class="pl-k">int</span> l <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">int</span> r <span class="pl-k">=</span> <span class="pl-c1">1</span>;
    <span class="pl-k">while</span> (r <span class="pl-k">&lt;</span> input<span class="pl-k">.</span>length()) {
      <span class="pl-k">if</span> (arr[r] <span class="pl-k">==</span> arr[l]) {
        r<span class="pl-k">++</span>;
      } <span class="pl-k">else</span> {
        arr[l <span class="pl-k">+</span> <span class="pl-c1">1</span>] <span class="pl-k">=</span> arr[r<span class="pl-k">++</span>];
        l<span class="pl-k">++</span>;
      }
    } 
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-smi">String</span>(arr, <span class="pl-c1">0</span>, l<span class="pl-k">+</span><span class="pl-c1">1</span>);
  } 
</pre></div>

<p><br></p>

<p><strong>Related</strong>: Remove spaces</p>

<blockquote>
<p>eg: “   I     love MTV ” --&gt; “I love MTV”</p>
</blockquote>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-smi">String</span> removeSpaces(<span class="pl-smi">String</span> input) {
    <span class="pl-k">if</span> (input <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> input<span class="pl-k">.</span>length() <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
      <span class="pl-k">return</span> input;
    }
    <span class="pl-k">char</span>[] arr <span class="pl-k">=</span> input<span class="pl-k">.</span>toCharArray();
    <span class="pl-k">int</span> r <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> arr<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
      <span class="pl-k">if</span> ((i <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> arr[i<span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span> <span class="pl-pds">'</span></span>) <span class="pl-k">&amp;&amp;</span> arr[i] <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span> <span class="pl-pds">'</span></span>) {
        <span class="pl-k">continue</span>;
      }
      arr[r<span class="pl-k">++</span>] <span class="pl-k">=</span> arr[i];
    }
    <span class="pl-c">// check if last character is " "</span>
    <span class="pl-k">if</span> (r <span class="pl-k">!=</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> arr[r <span class="pl-k">-</span> <span class="pl-c1">1</span>] <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span> <span class="pl-pds">'</span></span>) {
      <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-smi">String</span>(arr, <span class="pl-c1">0</span>, r <span class="pl-k">-</span> <span class="pl-c1">1</span>);
    }
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-smi">String</span>(arr, <span class="pl-c1">0</span>, r);
  }
</pre></div>

<p><br></p>

<p><strong>Related</strong>: remove certain characters:</p>

<blockquote>
<p>eg: input = "abcd", t = "ab" ===&gt; "cd".</p>
</blockquote>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-smi">String</span> remove(<span class="pl-smi">String</span> input, <span class="pl-smi">String</span> t) {
    <span class="pl-k">if</span> (input <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> t <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> t<span class="pl-k">.</span>length() <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
      <span class="pl-k">return</span> input;
    }
    <span class="pl-k">char</span>[] arr <span class="pl-k">=</span> input<span class="pl-k">.</span>toCharArray();
    <span class="pl-k">int</span> r <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> input<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>) {
      <span class="pl-k">boolean</span> found <span class="pl-k">=</span> <span class="pl-c1">false</span>;
      <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;</span> t<span class="pl-k">.</span>length(); j<span class="pl-k">++</span>) {
        <span class="pl-k">if</span> (arr[i] <span class="pl-k">==</span> t<span class="pl-k">.</span>charAt(j)) {
          found <span class="pl-k">=</span> <span class="pl-c1">true</span>;
          <span class="pl-k">break</span>;
        }
      }
      <span class="pl-k">if</span> (<span class="pl-k">!</span>found) {
        arr[r<span class="pl-k">++</span>] <span class="pl-k">=</span> arr[i];
      }
    }
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-smi">String</span>(arr, <span class="pl-c1">0</span>, r);
  }
</pre></div>

<p><br>
<strong>Related</strong>: Remove Adjacent Repeated Characters</p>

<blockquote>
<p>eg: "abbbaaccz" → "aaaccz" → "ccz" → "z"</p>
</blockquote>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-smi">String</span> deDup(<span class="pl-smi">String</span> input) {
    <span class="pl-k">if</span> (input <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> input<span class="pl-k">.</span>length() <span class="pl-k">&lt;=</span> <span class="pl-c1">1</span>) {
      <span class="pl-k">return</span> input;
    }
    <span class="pl-k">char</span>[] arr <span class="pl-k">=</span> input<span class="pl-k">.</span>toCharArray();
    <span class="pl-k">int</span> r <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;</span> input<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>) {
      <span class="pl-k">if</span> (r <span class="pl-k">==</span> <span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-k">||</span> arr[i] <span class="pl-k">!=</span> arr[r]) {
        arr[<span class="pl-k">++</span>r] <span class="pl-k">=</span> arr[i];
      } <span class="pl-k">else</span> {
        <span class="pl-k">--</span>r;
        <span class="pl-k">while</span> (i <span class="pl-k">&lt;</span> input<span class="pl-k">.</span>length() <span class="pl-k">-</span> <span class="pl-c1">1</span> <span class="pl-k">&amp;&amp;</span> arr[i] <span class="pl-k">==</span> arr[i<span class="pl-k">+</span><span class="pl-c1">1</span>]) {
          i<span class="pl-k">++</span>;
        } 
      }
    }
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-smi">String</span>(arr, <span class="pl-c1">0</span>, r <span class="pl-k">+</span> <span class="pl-c1">1</span>);
  }</pre></div>

<p><br></p>

<p><br></p>

<h3><a id="user-content-28-implement-strstr" class="anchor" href="https://github.com/wishyouhappy/Algorithm#28-implement-strstr" aria-hidden="true"><span class="octicon octicon-link"></span></a>28 Implement strStr</h3>

<blockquote>
<p>Implement strStr().</p>

<p>Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>

<p>Update (2014-11-02):</p>

<p>The signature of the function had been updated to return the index instead of the pointer. If you still see your function signature returns a char * or String, please click the reload button  to reset your code definition.</p>
</blockquote>

<p><strong>Idea</strong>: It asks us to implement a function like indexOf(string) in java. The easiest way is a O(n^2) solution, just like the time complexity of indexOf. We begin from the first chracter of haystack, check if it has the needle begin at index i. We can also use KMP string match algorithm to implement it in O(n) time. See detail at <a href="http://wishyouhappy.github.io/2014/12/26/kmp%20algorithm(knuth-morris-pratt)">kmp</a>.</p>

<p><strong>Code of solution1</strong>: O(n^2)</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> strStr(<span class="pl-smi">String</span> haystack, <span class="pl-smi">String</span> needle) {
        <span class="pl-k">if</span> (haystack <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> needle <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
            <span class="pl-k">return</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
        }
        <span class="pl-k">boolean</span> contain <span class="pl-k">=</span> <span class="pl-c1">true</span>;
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;=</span> haystack<span class="pl-k">.</span>length() <span class="pl-k">-</span> needle<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>){
            <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> i; j <span class="pl-k">&lt;</span> i <span class="pl-k">+</span> needle<span class="pl-k">.</span>length(); j<span class="pl-k">++</span>){
                <span class="pl-k">if</span> (haystack<span class="pl-k">.</span>charAt(j) <span class="pl-k">!=</span> needle<span class="pl-k">.</span>charAt(j<span class="pl-k">-</span>i)){
                    contain <span class="pl-k">=</span> <span class="pl-c1">false</span>;
                    <span class="pl-k">break</span>;
                } 
            }
            <span class="pl-k">if</span> (contain) {
                <span class="pl-k">return</span> i;
            }
            contain <span class="pl-k">=</span> <span class="pl-c1">true</span>;
        }
        <span class="pl-k">return</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
    }
</pre></div>

<p><strong>Code of solution2</strong>: O(n^2), use the library substring method</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> strStr(<span class="pl-smi">String</span> haystack, <span class="pl-smi">String</span> needle) {
       <span class="pl-k">if</span> (haystack <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> needle <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
           <span class="pl-k">return</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
       }
       <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;=</span> haystack<span class="pl-k">.</span>length() <span class="pl-k">-</span> needle<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>) {
           <span class="pl-smi">String</span> temp <span class="pl-k">=</span> haystack<span class="pl-k">.</span>substring(i, needle<span class="pl-k">.</span>length() <span class="pl-k">+</span> i);
           <span class="pl-k">if</span> (temp<span class="pl-k">.</span>equals(needle)) {
               <span class="pl-k">return</span> i;
           }
       }
       <span class="pl-k">return</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
    }
</pre></div>

<p><strong>Code of solution3</strong>: O(n)</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> strStr(<span class="pl-smi">String</span> haystack, <span class="pl-smi">String</span> needle){
        <span class="pl-k">if</span> (haystack <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> needle <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> (haystack<span class="pl-k">.</span>length() <span class="pl-k">&lt;</span> needle<span class="pl-k">.</span>length())) { 
            <span class="pl-k">return</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
        }
        <span class="pl-k">if</span> (needle<span class="pl-k">.</span>equals(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>)) {
            <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        }
        <span class="pl-k">int</span>[] helper <span class="pl-k">=</span> getHelperArray(needle);
        <span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> textLen <span class="pl-k">=</span> haystack<span class="pl-k">.</span>length();
        <span class="pl-k">int</span> patternLen <span class="pl-k">=</span> needle<span class="pl-k">.</span>length();
        <span class="pl-k">while</span> (i <span class="pl-k">&lt;</span> textLen <span class="pl-k">&amp;&amp;</span> j <span class="pl-k">&lt;</span> patternLen){
            <span class="pl-k">if</span>(haystack<span class="pl-k">.</span>charAt(i) <span class="pl-k">==</span> needle<span class="pl-k">.</span>charAt(j)){
                j<span class="pl-k">++</span>;
                i<span class="pl-k">++</span>;
            }
            <span class="pl-k">if</span>(j <span class="pl-k">==</span> patternLen){
                <span class="pl-k">return</span> i <span class="pl-k">-</span> patternLen;
                <span class="pl-c">//j = helper[j-1]; //if we want find all matches. </span>
            } <span class="pl-k">else</span> <span class="pl-k">if</span> ((i <span class="pl-k">&lt;</span> textLen <span class="pl-k">&amp;&amp;</span> j <span class="pl-k">&lt;</span> patternLen) <span class="pl-k">&amp;&amp;</span>haystack<span class="pl-k">.</span>charAt(i) <span class="pl-k">!=</span> needle<span class="pl-k">.</span>charAt(j)){
                <span class="pl-k">if</span>(j <span class="pl-k">!=</span> <span class="pl-c1">0</span>) {
                    j <span class="pl-k">=</span> helper[j<span class="pl-k">-</span><span class="pl-c1">1</span>];
                } <span class="pl-k">else</span> {
                    i<span class="pl-k">++</span>;
                }
            }
        }
        <span class="pl-k">return</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
    }

    <span class="pl-k">public</span> <span class="pl-k">int</span>[] getHelperArray(<span class="pl-smi">String</span> pattern){
        <span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; <span class="pl-c">//suffix</span>
        <span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; <span class="pl-c">//prefix</span>
        <span class="pl-k">int</span> len <span class="pl-k">=</span> pattern<span class="pl-k">.</span>length();
        <span class="pl-k">int</span>[] helper <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[len];
        helper[<span class="pl-c1">0</span>] <span class="pl-k">=</span> <span class="pl-c1">0</span>;

        <span class="pl-k">while</span> (i <span class="pl-k">&lt;</span> len){
            <span class="pl-k">if</span> (pattern<span class="pl-k">.</span>charAt(i) <span class="pl-k">==</span> pattern<span class="pl-k">.</span>charAt(j)) {
                j<span class="pl-k">++</span>;
                helper[i] <span class="pl-k">=</span> j;
                i<span class="pl-k">++</span>;
            } <span class="pl-k">else</span> {
                <span class="pl-k">if</span> (j <span class="pl-k">!=</span> <span class="pl-c1">0</span>) {
                    j <span class="pl-k">=</span> helper[j<span class="pl-k">-</span><span class="pl-c1">1</span>];
                } <span class="pl-k">else</span>{
                    helper[i] <span class="pl-k">=</span> <span class="pl-c1">0</span>;
                    i<span class="pl-k">++</span>;
                }
            }
        }
        <span class="pl-k">return</span> helper; 
    }
</pre></div>

<p><br></p>

<p><br></p>

<h3><a id="user-content-29-divide-two-integers" class="anchor" href="https://github.com/wishyouhappy/Algorithm#29-divide-two-integers" aria-hidden="true"><span class="octicon octicon-link"></span></a>29 Divide Two Integers</h3>

<blockquote>
<p>Divide two integers without using multiplication, division and mod operator.</p>
</blockquote>

<p>If it is overflow, return MAX_INT.</p>

<p><strong>Idea</strong>: Each integer can be represent as binary format, so n = (0 or 1) * 2 ^ n +(0 or 1) * 2 ^ (n-1) + ......</p>

<p>We can respresent the result = (0 or 1) * 2 ^ n +(0 or 1) * 2 ^ (n-1) + ......</p>

<p>Thus [(0 or 1) * 2 ^ n +(0 or 1) * 2 ^ (n-1) + ......)] * divisor = dividend</p>

<p>Thus, we can calculate (0 or 1) * 2 ^ i, i from n to 0, and combine them together.</p>

<p><strong>Time complexity</strong> : O(lgn)</p>

<p><strong>Space</strong>: O(1)</p>

<p><strong>Attention</strong>:</p>

<ul>
<li>abs (Integer.MIN_VALUE) = Integer.MIN_VALUE</li>
<li>when calculate n, eg:  while(divisor &lt;= (dividend &gt;&gt; 1)) we can not change to while((divisor&lt;&lt;1) &lt;= dividend). It might overflow and keep loop forever.</li>
<li>Take care of some corner case, eg: dividend = Integer.MIN_VALUE or divisor = Integer.MIN_VALUE</li>
</ul>

<p><br></p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> divide( <span class="pl-k">int</span> dividend, <span class="pl-k">int</span> divisor){
           <span class="pl-k">if</span>(divisor <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-smi">Integer</span><span class="pl-c1"><span class="pl-k">.</span>MAX_VALUE</span>;
           <span class="pl-k">int</span> result <span class="pl-k">=</span> <span class="pl-c1">0</span>;
           <span class="pl-k">boolean</span> positive <span class="pl-k">=</span> ((dividend <span class="pl-k">^</span> divisor) <span class="pl-k">&gt;&gt;&gt;</span> <span class="pl-c1">31</span>) <span class="pl-k">==</span> <span class="pl-c1">0</span>;
           <span class="pl-k">if</span>(divisor <span class="pl-k">==</span> <span class="pl-smi">Integer</span><span class="pl-c1"><span class="pl-k">.</span>MIN_VALUE</span>){
               <span class="pl-k">if</span>(dividend <span class="pl-k">==</span> <span class="pl-smi">Integer</span><span class="pl-c1"><span class="pl-k">.</span>MIN_VALUE</span>) <span class="pl-k">return</span> <span class="pl-c1">1</span>;
               <span class="pl-k">else</span> <span class="pl-k">return</span> <span class="pl-c1">0</span>;
           }
           <span class="pl-k">if</span>(dividend <span class="pl-k">==</span> <span class="pl-smi">Integer</span><span class="pl-c1"><span class="pl-k">.</span>MIN_VALUE</span>){
               <span class="pl-k">if</span>(divisor <span class="pl-k">==</span> <span class="pl-c1">1</span>) <span class="pl-k">return</span> <span class="pl-smi">Integer</span><span class="pl-c1"><span class="pl-k">.</span>MIN_VALUE</span>;
               <span class="pl-k">else</span> <span class="pl-k">if</span>(divisor <span class="pl-k">==</span> <span class="pl-k">-</span><span class="pl-c1">1</span>) <span class="pl-k">return</span> <span class="pl-smi">Integer</span><span class="pl-c1"><span class="pl-k">.</span>MAX_VALUE</span>;
               dividend <span class="pl-k">+=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>abs(divisor);
               result <span class="pl-k">+=</span> <span class="pl-c1">1</span>;
           }

           dividend <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>abs(dividend);
           divisor <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>abs(divisor);

           <span class="pl-k">int</span> count <span class="pl-k">=</span> <span class="pl-c1">0</span>;
           <span class="pl-k">while</span>(divisor <span class="pl-k">&lt;=</span> (dividend <span class="pl-k">&gt;&gt;</span> <span class="pl-c1">1</span>)){
               count<span class="pl-k">++</span>;
               divisor <span class="pl-k">&lt;&lt;</span><span class="pl-k">=</span> <span class="pl-c1">1</span>;
           }

           <span class="pl-k">while</span>(count <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>){
               <span class="pl-k">if</span>(dividend <span class="pl-k">&gt;=</span> divisor){
                   result <span class="pl-k">+=</span> <span class="pl-c1">1</span> <span class="pl-k">&lt;&lt;</span> count;
                   dividend <span class="pl-k">-=</span> divisor;
               }
               divisor <span class="pl-k">&gt;&gt;</span><span class="pl-k">=</span> <span class="pl-c1">1</span>;
               count <span class="pl-k">--</span>;
           }
           <span class="pl-k">return</span> positive <span class="pl-k">?</span> result <span class="pl-k">:</span> <span class="pl-k">-</span>result;
        }

</pre></div>

<p><br></p>

<p><br></p>

<h3><a id="user-content-30-substring-with-concatenation-of-all-words" class="anchor" href="https://github.com/wishyouhappy/Algorithm#30-substring-with-concatenation-of-all-words" aria-hidden="true"><span class="octicon octicon-link"></span></a>30 SubString with Concatenation of All Words</h3>

<blockquote>
<p>You are given a string, S, and a list of words, L, that are all of the same length. Find all starting indices of substring(s) in S that is a concatenation of each word in L exactly once and without any intervening characters.</p>
</blockquote>

<pre>For example, given:
S: "barfoothefoobarman"
L: ["foo", "bar"]
</pre>

<p>You should return the indices: [0,9].
(order does not matter).</p>

<p><strong>Idea</strong>: Store a dictionary of L. We use map to record each word of L and their occurence. Then for each index of S from 0, check if there is matches. </p>

<p><strong>Java Code</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> findSubstring(<span class="pl-smi">String</span> <span class="pl-smi">S</span>, <span class="pl-k">String</span>[] <span class="pl-smi">L</span>) {
        <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> list <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>();

        <span class="pl-k">if</span>(<span class="pl-smi">S</span> <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> <span class="pl-smi">S</span><span class="pl-k">.</span>length() <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> <span class="pl-smi">L</span> <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> <span class="pl-smi">L</span><span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> list;
        <span class="pl-k">if</span>(<span class="pl-smi">S</span><span class="pl-k">.</span>length() <span class="pl-k">&lt;</span> <span class="pl-smi">L</span><span class="pl-k">.</span>length <span class="pl-k">*</span> <span class="pl-k">L</span>[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length()) <span class="pl-k">return</span> list;

        <span class="pl-k">Map&lt;<span class="pl-smi">String</span>, <span class="pl-smi">Integer</span>&gt;</span> map <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashMap&lt;<span class="pl-smi">String</span>, <span class="pl-smi">Integer</span>&gt;</span>();
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>, len <span class="pl-k">=</span> <span class="pl-smi">L</span><span class="pl-k">.</span>length; i <span class="pl-k">&lt;</span> len; i<span class="pl-k">++</span>){
            <span class="pl-smi">String</span> current <span class="pl-k">=</span> <span class="pl-k">L</span>[i];
            <span class="pl-k">if</span>(map<span class="pl-k">.</span>containsKey(current)) map<span class="pl-k">.</span>put(current, map<span class="pl-k">.</span>get(current)<span class="pl-k">+</span><span class="pl-c1">1</span>);
            <span class="pl-k">else</span> map<span class="pl-k">.</span>put(current, <span class="pl-c1">1</span>);
        }

        <span class="pl-k">int</span> unitLen <span class="pl-k">=</span> <span class="pl-k">L</span>[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length();
        <span class="pl-k">int</span> sLen <span class="pl-k">=</span> <span class="pl-smi">S</span><span class="pl-k">.</span>length();
        <span class="pl-k">int</span> totalStr <span class="pl-k">=</span> <span class="pl-smi">L</span><span class="pl-k">.</span>length;
        <span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>;

        <span class="pl-k">while</span>(sLen <span class="pl-k">-</span> i <span class="pl-k">&gt;=</span> unitLen <span class="pl-k">*</span> totalStr){
            <span class="pl-k">Map&lt;<span class="pl-smi">String</span>, <span class="pl-smi">Integer</span>&gt;</span> tempMap <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashMap&lt;<span class="pl-smi">String</span>, <span class="pl-smi">Integer</span>&gt;</span>(map);
            <span class="pl-k">for</span>(<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;</span> totalStr; j<span class="pl-k">++</span>){
                <span class="pl-smi">String</span> current <span class="pl-k">=</span> <span class="pl-smi">S</span><span class="pl-k">.</span>substring(i<span class="pl-k">+</span>j<span class="pl-k">*</span>unitLen, i <span class="pl-k">+</span> (j<span class="pl-k">+</span><span class="pl-c1">1</span>)<span class="pl-k">*</span>unitLen);
                <span class="pl-k">if</span>(<span class="pl-k">!</span>tempMap<span class="pl-k">.</span>containsKey(current)) <span class="pl-k">break</span>;
                <span class="pl-k">if</span>(tempMap<span class="pl-k">.</span>get(current) <span class="pl-k">==</span> <span class="pl-c1">1</span>) tempMap<span class="pl-k">.</span>remove(current);
                <span class="pl-k">else</span> tempMap<span class="pl-k">.</span>put(current,tempMap<span class="pl-k">.</span>get(current)<span class="pl-k">-</span><span class="pl-c1">1</span>);
            }
            <span class="pl-k">if</span>(tempMap<span class="pl-k">.</span>size() <span class="pl-k">==</span> <span class="pl-c1">0</span>) list<span class="pl-k">.</span>add(i);
            i<span class="pl-k">++</span>;
        }

        <span class="pl-k">return</span> list;   
    }

</pre></div>

<p><br></p>

<p><br></p>

<h3><a id="user-content-31-next-permutation" class="anchor" href="https://github.com/wishyouhappy/Algorithm#31-next-permutation" aria-hidden="true"><span class="octicon octicon-link"></span></a>31 Next Permutation</h3>

<blockquote>
<p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>

<p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>

<p>The replacement must be in-place, do not allocate extra memory.</p>

<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p>
</blockquote>

<pre>1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
</pre>

<p><strong>Idea</strong>: The next permutation is the permutation that larger than the original permutation and the immediate larger one. We can also think this as a successor. We can find the next permutation by the following steps:</p>

<ul>
<li><p>1) from the end, find the first non-increasing element, eg 1 2 3 5 4. Then we need to find is 3. Record this index. If it's -1, say 5, 4, 3, 2, 1., in this case we can reverse the array to 1, 2, 3, 4, 5 and end the function.</p></li>
<li><p>2) from the index1 we record in step 1, we find the smallest element larger than num[index1]. Record this index2.</p></li>
<li><p>3) swap element at index1 and index2, then reverse element after index1. </p></li>
</ul>

<p>For example. a permutation of 1 2 3 4 5 would be:</p>

<p>1 2 3 4 5</p>

<p>1 2 3 5 4</p>

<p>1 2 4 3 5</p>

<p>1 2 4 5 3</p>

<p>1 2 5 3 4</p>

<p>1 2 5 4 3</p>

<p>1 3 2 4 5</p>

<p>1 3 2 5 4</p>

<p>1 3 4 2 5</p>

<p>1 3 4 5 2 </p>

<p>.......</p>

<p><strong>Attention</strong></p>

<ul>
<li>1) for step 1, when find the non-inceasing element we allow the equal element. eg: 1 2 5 4 4 3. We should find 2, the index1. Consider test case "[1 1]"</li>
<li>2) for step 2, we should find element larger than num[index1]. If change to &gt;=, then it doesn't work. Consider test case "[1, 5, 1]"</li>
</ul>

<p><strong>Java code</strong>:</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">void</span> nextPermutation(<span class="pl-k">int</span>[] num) {
    <span class="pl-k">if</span>(num <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> num<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
        <span class="pl-k">return</span>;
    }
    <span class="pl-k">int</span> i <span class="pl-k">=</span> num<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">2</span>;
    <span class="pl-k">while</span> (i <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> num[i] <span class="pl-k">&gt;=</span> num[i<span class="pl-k">+</span><span class="pl-c1">1</span>]) {
        i<span class="pl-k">--</span>;
    }
    <span class="pl-k">int</span> index1 <span class="pl-k">=</span> i;
    <span class="pl-k">if</span> (i <span class="pl-k">==</span> <span class="pl-k">-</span><span class="pl-c1">1</span>) {
        reverse(num, <span class="pl-c1">0</span>);
        <span class="pl-k">return</span>;
    }
    i <span class="pl-k">=</span> num<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>;
    <span class="pl-k">while</span> (i <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> num[i] <span class="pl-k">&lt;=</span> num[index1]) {
        i<span class="pl-k">--</span>;
    }
    swap(num, index1, i);
    reverse(num, index1 <span class="pl-k">+</span> <span class="pl-c1">1</span>);
}

<span class="pl-k">public</span> <span class="pl-k">void</span> reverse(<span class="pl-k">int</span>[] num, <span class="pl-k">int</span> i) {
    <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> i; j <span class="pl-k">&lt;</span> (num<span class="pl-k">.</span>length <span class="pl-k">-</span> i) <span class="pl-k">/</span> <span class="pl-c1">2</span> <span class="pl-k">+</span> i; j<span class="pl-k">++</span>) {
        swap(num, j, num<span class="pl-k">.</span>length <span class="pl-k">+</span> i <span class="pl-k">-</span> j <span class="pl-k">-</span> <span class="pl-c1">1</span>);
    }
}
<span class="pl-k">public</span> <span class="pl-k">void</span> swap(<span class="pl-k">int</span>[] num, <span class="pl-k">int</span> i, <span class="pl-k">int</span> j) {
    <span class="pl-k">int</span> temp <span class="pl-k">=</span> num[i];
    num[i] <span class="pl-k">=</span> num[j];
    num[j] <span class="pl-k">=</span> temp;
}
</pre></div>

<p><br></p>

<p><br></p>

<h3><a id="user-content-32-longest-valid-parentheses" class="anchor" href="https://github.com/wishyouhappy/Algorithm#32-longest-valid-parentheses" aria-hidden="true"><span class="octicon octicon-link"></span></a>32 Longest Valid Parentheses</h3>

<blockquote>
<p>Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.</p>

<p>For "(()", the longest valid parentheses substring is "()", which has length = 2.</p>

<p>Another example is ")()())", where the longest valid parentheses substring is "()()", which has length = 4.</p>
</blockquote>

<p><strong>Idea</strong>: This problem has some similarities with the valid parentheses, we need to use the method in that problem to check if the current sequence of parentheses is valid. We use a stack to match the parentheses. The difference is that we store the <strong>index</strong> of the parenthese other than index. Because there is only one type of parentheses, so it's ok to store just the index. </p>

<p>Then how to calculate the longest valid parentheses? Like the valid parentheses problem, everytime, we encounter a '(', we push the current index. Then if the parentheses is ')', Obviously, if the stack is empty, then the previous parentheses sequence cannot be a valid parentheses, so we update the valid parentheses start position. Otherwise, we need to calculate the local longest parentheses. </p>

<p><strong>Attention</strong>: When we calculate the local longest, we need to compare the max with i-stack.peek() after we pop an element from the stack because we need to count in the previous valid sequences. Eg: (()(). </p>

<p><strong>Java code</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> longestValidParentheses(<span class="pl-smi">String</span> s) {
        <span class="pl-k">if</span>(s <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> s<span class="pl-k">.</span>length() <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> max <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> start <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">Stack&lt;<span class="pl-smi">Integer</span>&gt;</span> stack <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">Stack&lt;<span class="pl-smi">Integer</span>&gt;</span>();
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> s<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>){
            <span class="pl-k">if</span>(stack<span class="pl-k">.</span>isEmpty() <span class="pl-k">&amp;&amp;</span> s<span class="pl-k">.</span>charAt(i) <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>)<span class="pl-pds">'</span></span>) start <span class="pl-k">=</span> i<span class="pl-k">+</span><span class="pl-c1">1</span>;
            <span class="pl-k">else</span> <span class="pl-k">if</span>(s<span class="pl-k">.</span>charAt(i) <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>)<span class="pl-pds">'</span></span>){
                stack<span class="pl-k">.</span>pop();
                max <span class="pl-k">=</span> stack<span class="pl-k">.</span>isEmpty()<span class="pl-k">?</span><span class="pl-smi">Math</span><span class="pl-k">.</span>max(max, i <span class="pl-k">-</span>start<span class="pl-k">+</span><span class="pl-c1">1</span>) <span class="pl-k">:</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(max, i<span class="pl-k">-</span>stack<span class="pl-k">.</span>peek());
            } 
            <span class="pl-k">else</span> <span class="pl-k">if</span>(s<span class="pl-k">.</span>charAt(i) <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>(<span class="pl-pds">'</span></span>) stack<span class="pl-k">.</span>push(i);
        }
        <span class="pl-k">return</span> max;
    }

</pre></div>

<p><br></p>

<p><br></p>

<h3><a id="user-content-33-search-in-rotated-sorted-array" class="anchor" href="https://github.com/wishyouhappy/Algorithm#33-search-in-rotated-sorted-array" aria-hidden="true"><span class="octicon octicon-link"></span></a>33 Search in Rotated Sorted Array</h3>

<blockquote>
<p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>

<p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>

<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>

<p>You may assume no duplicate exists in the array.</p>
</blockquote>

<p><strong>Idea</strong>: There is no duplicate, so after rotation, the array can be look as two parts, and these two parts are all in ascending order. Thus we can use the binary search method, and update the l and r pointer based on the comparison. See details of comparison on the code.</p>

<p><strong>Java code</strong>: </p>

<p><strong>Time</strong>: O(lgn)</p>

<div class="highlight highlight-java"><pre>        <span class="pl-k">public</span> <span class="pl-k">int</span> search(<span class="pl-k">int</span>[] <span class="pl-smi">A</span>, <span class="pl-k">int</span> target) {
        <span class="pl-k">if</span>(<span class="pl-smi">A</span> <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
        }
        <span class="pl-k">int</span> l <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> r <span class="pl-k">=</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length<span class="pl-k">-</span><span class="pl-c1">1</span>;
        <span class="pl-k">while</span>(l <span class="pl-k">&lt;=</span> r){
           <span class="pl-k">int</span> mid <span class="pl-k">=</span> l <span class="pl-k">+</span> (r <span class="pl-k">-</span> l) <span class="pl-k">/</span> <span class="pl-c1">2</span>;
           <span class="pl-k">if</span> (<span class="pl-k">A</span>[mid] <span class="pl-k">==</span> target) {
               <span class="pl-k">return</span> mid;
           } <span class="pl-k">else</span> <span class="pl-k">if</span> (<span class="pl-k">A</span>[mid] <span class="pl-k">&gt;=</span> <span class="pl-k">A</span>[l]) {
               <span class="pl-k">if</span> (<span class="pl-k">A</span>[l] <span class="pl-k">&lt;=</span> target <span class="pl-k">&amp;&amp;</span> <span class="pl-k">A</span>[mid] <span class="pl-k">&gt;</span> target) {
                   r <span class="pl-k">=</span> mid <span class="pl-k">-</span> <span class="pl-c1">1</span>;
               } <span class="pl-k">else</span> {
                   l <span class="pl-k">=</span> mid <span class="pl-k">+</span> <span class="pl-c1">1</span>;
               }
           } <span class="pl-k">else</span> {
               <span class="pl-k">if</span> (<span class="pl-k">A</span>[mid] <span class="pl-k">&lt;</span> target <span class="pl-k">&amp;&amp;</span> <span class="pl-k">A</span>[r] <span class="pl-k">&gt;=</span> target) {
                   l <span class="pl-k">=</span> mid <span class="pl-k">+</span> <span class="pl-c1">1</span>;
               } <span class="pl-k">else</span> {
                   r <span class="pl-k">=</span> mid <span class="pl-k">-</span> <span class="pl-c1">1</span>;
               }
           }
        }
        <span class="pl-k">return</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
    }
</pre></div>

<p><strong>Another way</strong>: It can handle duplicates, but this is not lg(n) at worst case. </p>

<div class="highlight highlight-java"><pre>       <span class="pl-k">public</span> <span class="pl-k">int</span> search(<span class="pl-k">int</span>[] <span class="pl-smi">A</span>, <span class="pl-k">int</span> target) {
        <span class="pl-k">if</span>(<span class="pl-smi">A</span> <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
        }
        <span class="pl-k">int</span> l <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> r <span class="pl-k">=</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length<span class="pl-k">-</span><span class="pl-c1">1</span>;
        <span class="pl-k">while</span>(l <span class="pl-k">&lt;=</span> r){
            <span class="pl-k">int</span> mid <span class="pl-k">=</span> (l<span class="pl-k">+</span>r)<span class="pl-k">/</span><span class="pl-c1">2</span>;
            <span class="pl-k">if</span>(<span class="pl-k">A</span>[mid] <span class="pl-k">==</span> target) {
                <span class="pl-k">return</span> mid;
            } <span class="pl-k">else</span> <span class="pl-k">if</span>(<span class="pl-k">A</span>[mid] <span class="pl-k">&gt;</span> target <span class="pl-k">&amp;&amp;</span> <span class="pl-k">A</span>[mid] <span class="pl-k">&lt;</span> <span class="pl-k">A</span>[r]) {
                r <span class="pl-k">=</span> mid<span class="pl-k">-</span><span class="pl-c1">1</span>;
            } <span class="pl-k">else</span> <span class="pl-k">if</span>(<span class="pl-k">A</span>[mid] <span class="pl-k">&lt;</span> target <span class="pl-k">&amp;&amp;</span> <span class="pl-k">A</span>[mid] <span class="pl-k">&gt;</span> <span class="pl-k">A</span>[l]) {
                l <span class="pl-k">=</span> mid <span class="pl-k">+</span> <span class="pl-c1">1</span>;
            } <span class="pl-k">else</span> <span class="pl-k">if</span> (<span class="pl-k">A</span>[l] <span class="pl-k">!=</span> target) {
                l<span class="pl-k">++</span>;
            } <span class="pl-k">else</span> {
                <span class="pl-k">return</span> l;
            }
        }
        <span class="pl-k">return</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
    }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-34-search-for-a-range" class="anchor" href="https://github.com/wishyouhappy/Algorithm#34-search-for-a-range" aria-hidden="true"><span class="octicon octicon-link"></span></a>34 Search for a Range</h3>

<blockquote>
<p>Given a sorted array of integers, find the starting and ending position of a given target value.</p>

<p>Your algorithm's runtime complexity must be in the order of O(log n).</p>

<p>If the target is not found in the array, return [-1, -1].</p>

<p>For example,</p>

<p>Given [5, 7, 7, 8, 8, 10] and target value 8,</p>

<p>return [3, 4].</p>
</blockquote>

<p><br></p>

<p><strong>Idea</strong>: We need to find the range in O(lgn), thus binary search comes to mind. We could use binary search to find the target, then for the left and right part, we do binary search again to find the left boundary and right boundary.</p>

<p>The second solution is similar to the first one, the differce is that we do twice binary search to do the left boundary and right boundary. Remember to check the value of the two boundaries. Because in this method, we might not find the target element. </p>

<p><strong>Solution1</strong>:</p>

<div class="highlight highlight-java"><pre>     <span class="pl-k">public</span> <span class="pl-k">int</span>[] searchRange(<span class="pl-k">int</span>[] <span class="pl-smi">A</span>, <span class="pl-k">int</span> target) {
       <span class="pl-k">int</span>[] res <span class="pl-k">=</span> {<span class="pl-k">-</span><span class="pl-c1">1</span>, <span class="pl-k">-</span><span class="pl-c1">1</span>};
       <span class="pl-k">int</span> l <span class="pl-k">=</span> <span class="pl-c1">0</span>;
       <span class="pl-k">int</span> r <span class="pl-k">=</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>;
       <span class="pl-k">while</span> ( l <span class="pl-k">&lt;=</span> r) {
           <span class="pl-k">int</span> mid <span class="pl-k">=</span> l <span class="pl-k">+</span> (r <span class="pl-k">-</span> l) <span class="pl-k">/</span> <span class="pl-c1">2</span>;
           <span class="pl-k">if</span> (target <span class="pl-k">&gt;</span> <span class="pl-k">A</span>[mid]) {
               l <span class="pl-k">=</span> mid <span class="pl-k">+</span> <span class="pl-c1">1</span>;
           } <span class="pl-k">else</span> <span class="pl-k">if</span> (target <span class="pl-k">&lt;</span> <span class="pl-k">A</span>[mid]) {
               r <span class="pl-k">=</span> mid <span class="pl-k">-</span> <span class="pl-c1">1</span>;
           } <span class="pl-k">else</span> {
               <span class="pl-k">int</span> lr <span class="pl-k">=</span> mid;
               <span class="pl-k">int</span> rl <span class="pl-k">=</span> mid;
               <span class="pl-k">while</span> (l <span class="pl-k">&lt;=</span> lr) {
                   <span class="pl-k">int</span> mid1 <span class="pl-k">=</span> l <span class="pl-k">+</span> (lr <span class="pl-k">-</span> l) <span class="pl-k">/</span> <span class="pl-c1">2</span>;
                   <span class="pl-k">if</span> (target <span class="pl-k">&lt;=</span> <span class="pl-k">A</span>[mid1]) {
                       lr <span class="pl-k">=</span> mid1 <span class="pl-k">-</span> <span class="pl-c1">1</span>;
                   } <span class="pl-k">else</span> {
                       l <span class="pl-k">=</span> mid1 <span class="pl-k">+</span> <span class="pl-c1">1</span>;
                   }
               }
               res[<span class="pl-c1">0</span>] <span class="pl-k">=</span> l;
               <span class="pl-k">while</span> (rl <span class="pl-k">&lt;=</span> r) {
                   <span class="pl-k">int</span> mid2 <span class="pl-k">=</span> rl <span class="pl-k">+</span> (r <span class="pl-k">-</span> rl) <span class="pl-k">/</span> <span class="pl-c1">2</span>;
                   <span class="pl-k">if</span> (target <span class="pl-k">&gt;=</span> <span class="pl-k">A</span>[mid2]) {
                       rl <span class="pl-k">=</span> mid2 <span class="pl-k">+</span> <span class="pl-c1">1</span>;
                   } <span class="pl-k">else</span> {
                       r <span class="pl-k">=</span> mid2 <span class="pl-k">-</span> <span class="pl-c1">1</span>;
                   }
               }
               res[<span class="pl-c1">1</span>] <span class="pl-k">=</span> r;
               <span class="pl-k">return</span> res;
           }

       }
       <span class="pl-k">return</span> res;
    }    
</pre></div>

<p><strong>Solution 2</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span>[] searchRange(<span class="pl-k">int</span>[] <span class="pl-smi">A</span>, <span class="pl-k">int</span> target) {
       <span class="pl-k">int</span>[] res <span class="pl-k">=</span> {<span class="pl-k">-</span><span class="pl-c1">1</span>, <span class="pl-k">-</span><span class="pl-c1">1</span>};
       <span class="pl-k">int</span> ll <span class="pl-k">=</span> <span class="pl-c1">0</span>;
       <span class="pl-k">int</span> lr <span class="pl-k">=</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>;
       <span class="pl-k">int</span> rl <span class="pl-k">=</span> <span class="pl-c1">0</span>;
       <span class="pl-k">int</span> rr <span class="pl-k">=</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>;
       <span class="pl-k">while</span> (ll <span class="pl-k">&lt;=</span> lr) {
           <span class="pl-k">int</span> mid1 <span class="pl-k">=</span> ll <span class="pl-k">+</span> (lr <span class="pl-k">-</span> ll) <span class="pl-k">/</span> <span class="pl-c1">2</span>;
           <span class="pl-k">if</span> (<span class="pl-k">A</span>[mid1] <span class="pl-k">&gt;=</span> target) {
               lr <span class="pl-k">=</span> mid1 <span class="pl-k">-</span> <span class="pl-c1">1</span>;
           } <span class="pl-k">else</span> {
               ll <span class="pl-k">=</span> mid1 <span class="pl-k">+</span> <span class="pl-c1">1</span>;
           }
       }
       <span class="pl-k">while</span> (rl <span class="pl-k">&lt;=</span> rr) {
           <span class="pl-k">int</span> mid2 <span class="pl-k">=</span> rl <span class="pl-k">+</span> (rr <span class="pl-k">-</span> rl) <span class="pl-k">/</span> <span class="pl-c1">2</span>;
           <span class="pl-k">if</span> (<span class="pl-k">A</span>[mid2] <span class="pl-k">&lt;=</span> target) {
               rl <span class="pl-k">=</span> mid2 <span class="pl-k">+</span> <span class="pl-c1">1</span>;
           } <span class="pl-k">else</span> {
               rr <span class="pl-k">=</span> mid2 <span class="pl-k">-</span> <span class="pl-c1">1</span>;
           }
       }
       <span class="pl-k">if</span> (ll <span class="pl-k">&lt;=</span> rr) {
           res[<span class="pl-c1">0</span>] <span class="pl-k">=</span> ll;
           res[<span class="pl-c1">1</span>] <span class="pl-k">=</span> rr;
       }
       <span class="pl-k">return</span> res;
    }</pre></div>

<p><strong>Related: first occurrence:</strong></p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">int</span> firstOccur(<span class="pl-k">int</span>[] array, <span class="pl-k">int</span> target) {
    <span class="pl-c">// Write your solution here</span>
    <span class="pl-k">if</span> (array <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> array<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
      <span class="pl-k">return</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
    }
    <span class="pl-k">int</span> l <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">int</span> r <span class="pl-k">=</span> array<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>;
    <span class="pl-k">while</span> (l <span class="pl-k">&lt;=</span> r) {
      <span class="pl-k">int</span> mid <span class="pl-k">=</span> l <span class="pl-k">+</span> (r <span class="pl-k">-</span> l) <span class="pl-k">/</span> <span class="pl-c1">2</span>;
      <span class="pl-k">if</span> (array[mid] <span class="pl-k">&gt;=</span> target) {
        r <span class="pl-k">=</span> mid <span class="pl-k">-</span> <span class="pl-c1">1</span>;
      } <span class="pl-k">else</span> {
        l <span class="pl-k">=</span> mid <span class="pl-k">+</span> <span class="pl-c1">1</span>;
      }
    }
    <span class="pl-k">return</span> (l <span class="pl-k">&lt;</span> array<span class="pl-k">.</span>length <span class="pl-k">&amp;&amp;</span> array[l] <span class="pl-k">==</span> target) <span class="pl-k">?</span> l <span class="pl-k">:</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
}
</pre></div>

<p><strong>Related: last occurrence</strong>:</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">int</span> lastOccur(<span class="pl-k">int</span>[] array, <span class="pl-k">int</span> target) {
    <span class="pl-c">// Write your solution here</span>
    <span class="pl-k">if</span> (array <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> array<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
      <span class="pl-k">return</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
    }
    <span class="pl-k">int</span> l <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">int</span> r <span class="pl-k">=</span> array<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>;
    <span class="pl-k">while</span> (l <span class="pl-k">&lt;=</span> r) {
      <span class="pl-k">int</span> mid <span class="pl-k">=</span> l <span class="pl-k">+</span> (r <span class="pl-k">-</span> l) <span class="pl-k">/</span> <span class="pl-c1">2</span>;
      <span class="pl-k">if</span> (array[mid] <span class="pl-k">&lt;=</span> target) {
        l <span class="pl-k">=</span> mid <span class="pl-k">+</span> <span class="pl-c1">1</span>;
      } <span class="pl-k">else</span> {
        r <span class="pl-k">=</span> mid <span class="pl-k">-</span> <span class="pl-c1">1</span>;
      }
    }
    <span class="pl-k">return</span> (r <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> array[r] <span class="pl-k">==</span> target) <span class="pl-k">?</span> r <span class="pl-k">:</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
}</pre></div>

<p><strong>Related: find k closest</strong>:</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">int</span>[] kClosest(<span class="pl-k">int</span>[] array, <span class="pl-k">int</span> target, <span class="pl-k">int</span> k) {
    <span class="pl-c">// Write your solution here</span>
    <span class="pl-k">if</span> (array <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> array<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
      <span class="pl-k">return</span> array;
    }
    <span class="pl-k">int</span>[] res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[k];
    <span class="pl-k">int</span> l <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">int</span> r <span class="pl-k">=</span> array<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>;
    <span class="pl-k">while</span> (l <span class="pl-k">&lt;=</span> r) {
      <span class="pl-k">int</span> mid <span class="pl-k">=</span> l <span class="pl-k">+</span> (r <span class="pl-k">-</span> l) <span class="pl-k">/</span> <span class="pl-c1">2</span>;
      <span class="pl-k">if</span> (array[mid] <span class="pl-k">==</span> target) {
        l <span class="pl-k">=</span> mid;
        <span class="pl-k">break</span>;
      } <span class="pl-k">else</span> <span class="pl-k">if</span> (array[mid] <span class="pl-k">&gt;</span> target) {
        r <span class="pl-k">=</span> mid <span class="pl-k">-</span> <span class="pl-c1">1</span>;
      } <span class="pl-k">else</span> {
        l <span class="pl-k">=</span> mid <span class="pl-k">+</span> <span class="pl-c1">1</span>;
      }
    }
    <span class="pl-k">int</span> indexL <span class="pl-k">=</span> l <span class="pl-k">-</span> <span class="pl-c1">1</span>;
    <span class="pl-k">int</span> indexR <span class="pl-k">=</span> l;

    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> k; i<span class="pl-k">++</span>) {
      <span class="pl-k">if</span> (indexL <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> indexR <span class="pl-k">&lt;</span> array<span class="pl-k">.</span>length) {
        res[i] <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>abs(array[indexL] <span class="pl-k">-</span> target) <span class="pl-k">-</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>abs(array[indexR] <span class="pl-k">-</span> target) <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">?</span> array[indexR<span class="pl-k">++</span>] <span class="pl-k">:</span> array[indexL<span class="pl-k">--</span>];
      } <span class="pl-k">else</span> <span class="pl-k">if</span> (indexL <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>) {
        res[i] <span class="pl-k">=</span> array[indexL<span class="pl-k">--</span>];
      } <span class="pl-k">else</span> {
        res[i] <span class="pl-k">=</span> array[indexR<span class="pl-k">++</span>];
      }
    }

    <span class="pl-k">return</span> res;
  }</pre></div>

<p><strong>Related: search in unknown size sorted array</strong>:</p>

<div class="highlight highlight-java"><pre><span class="pl-k">class</span> <span class="pl-en">Dictionary</span>{
    <span class="pl-k">int</span>[] array <span class="pl-k">=</span> {<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span>, <span class="pl-c1">6</span>, <span class="pl-c1">7</span>, <span class="pl-c1">8</span>, <span class="pl-c1">9</span>, <span class="pl-c1">10</span>};
    <span class="pl-k">public</span> <span class="pl-smi">Integer</span> <span class="pl-en">get</span>(<span class="pl-k">int</span> <span class="pl-v">index</span>){
        <span class="pl-k">if</span> (index <span class="pl-k">&gt;=</span> array<span class="pl-k">.</span>length) {
            <span class="pl-k">return</span> <span class="pl-c1">null</span>;
        }
        <span class="pl-k">return</span> array[index];
    }
}

<span class="pl-k">public</span> <span class="pl-k">int</span> search(<span class="pl-smi">Dictionary</span> dict, <span class="pl-k">int</span> target) {
    <span class="pl-c">// Write your solution here</span>
    <span class="pl-k">int</span> bounds <span class="pl-k">=</span> findBound(dict, target);
    <span class="pl-k">int</span> l <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">int</span> r <span class="pl-k">=</span> bounds;
    <span class="pl-k">while</span> (l <span class="pl-k">&lt;=</span> r) {
      <span class="pl-k">int</span> mid <span class="pl-k">=</span> l <span class="pl-k">+</span> (r <span class="pl-k">-</span> l) <span class="pl-k">/</span> <span class="pl-c1">2</span>;
      <span class="pl-k">if</span> (dict<span class="pl-k">.</span>get(mid) <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> dict<span class="pl-k">.</span>get(mid) <span class="pl-k">&gt;</span> target) {
        r <span class="pl-k">=</span> mid <span class="pl-k">-</span> <span class="pl-c1">1</span>;
      } <span class="pl-k">else</span> <span class="pl-k">if</span> (dict<span class="pl-k">.</span>get(mid) <span class="pl-k">==</span> target) {
        <span class="pl-k">return</span> mid;
      } <span class="pl-k">else</span>{
        l <span class="pl-k">=</span> mid <span class="pl-k">+</span> <span class="pl-c1">1</span>;
      }
    }
    <span class="pl-k">return</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
  }

  <span class="pl-k">public</span> <span class="pl-k">int</span> findBound(<span class="pl-smi">Dictionary</span> dict, <span class="pl-k">int</span> target) {
    <span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>;
    <span class="pl-k">while</span>(<span class="pl-c1">true</span>) {
      <span class="pl-k">if</span> (dict<span class="pl-k">.</span>get(i) <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> dict<span class="pl-k">.</span>get(i) <span class="pl-k">&gt;</span> target) {
        <span class="pl-k">return</span> i;
      } <span class="pl-k">else</span> {
        i <span class="pl-k">*=</span> <span class="pl-c1">2</span>;
      }
    }
  }</pre></div>

<p><strong>Related: total occurrence</strong>:</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">int</span> totalOccurrence(<span class="pl-k">int</span>[] array, <span class="pl-k">int</span> target) {
    <span class="pl-c">// Write your solution here</span>
    <span class="pl-k">if</span> (array <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> array<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
      <span class="pl-k">return</span> <span class="pl-c1">0</span>;
    }
    <span class="pl-k">int</span> l <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">int</span> r <span class="pl-k">=</span> array<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>;
    <span class="pl-k">while</span> (l <span class="pl-k">&lt;=</span> r) {
      <span class="pl-k">int</span> mid <span class="pl-k">=</span> l <span class="pl-k">+</span> (r <span class="pl-k">-</span> l) <span class="pl-k">/</span> <span class="pl-c1">2</span>;
      <span class="pl-k">if</span> (array[mid] <span class="pl-k">&gt;=</span> target) {
        r <span class="pl-k">=</span> mid <span class="pl-k">-</span> <span class="pl-c1">1</span>;
      } <span class="pl-k">else</span> {
        l <span class="pl-k">=</span> mid <span class="pl-k">+</span> <span class="pl-c1">1</span>;
      }
    }
    <span class="pl-k">int</span> l1 <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">int</span> r1 <span class="pl-k">=</span> array<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>;
    <span class="pl-k">while</span> (l1 <span class="pl-k">&lt;=</span> r1) {
      <span class="pl-k">int</span> mid <span class="pl-k">=</span> l1 <span class="pl-k">+</span> (r1 <span class="pl-k">-</span> l1) <span class="pl-k">/</span> <span class="pl-c1">2</span>;
      <span class="pl-k">if</span> (array[mid] <span class="pl-k">&lt;=</span> target) {
        l1 <span class="pl-k">=</span> mid <span class="pl-k">+</span> <span class="pl-c1">1</span>;
      } <span class="pl-k">else</span> {
        r1 <span class="pl-k">=</span> mid <span class="pl-k">-</span> <span class="pl-c1">1</span>;
      }
    }
    <span class="pl-k">if</span> (l <span class="pl-k">&lt;=</span> r1) {
      <span class="pl-k">return</span> r1 <span class="pl-k">-</span> l <span class="pl-k">+</span> <span class="pl-c1">1</span>;
    }
    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
  }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-35-search-insert-position" class="anchor" href="https://github.com/wishyouhappy/Algorithm#35-search-insert-position" aria-hidden="true"><span class="octicon octicon-link"></span></a>35 Search Insert Position</h3>

<blockquote>
<p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>

<p>You may assume no duplicates in the array.</p>

<p>Here are few examples.</p>
</blockquote>

<pre>[1,3,5,6], 5 → 2
[1,3,5,6], 2 → 1
[1,3,5,6], 7 → 4
[1,3,5,6], 0 → 0
</pre>

<p><br>
<strong>Idea</strong>: Just like the method used in search range, we use binary search, when l &gt; r, l is the first element larger then the target. </p>

<p><strong>Time</strong> : log(n)</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> searchInsert(<span class="pl-k">int</span>[] <span class="pl-smi">A</span>, <span class="pl-k">int</span> target) {
        <span class="pl-k">if</span> (<span class="pl-smi">A</span> <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        }
        <span class="pl-k">int</span> l <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> r <span class="pl-k">=</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>;
        <span class="pl-k">while</span> (l <span class="pl-k">&lt;=</span> r) {
            <span class="pl-k">int</span> mid <span class="pl-k">=</span> l <span class="pl-k">+</span> (r <span class="pl-k">-</span> l)<span class="pl-k">/</span><span class="pl-c1">2</span>;
            <span class="pl-k">if</span> (<span class="pl-k">A</span>[mid] <span class="pl-k">==</span> target) {
                <span class="pl-k">return</span> mid;
            } <span class="pl-k">else</span> <span class="pl-k">if</span> (<span class="pl-k">A</span>[mid] <span class="pl-k">&lt;</span> target) {
                l <span class="pl-k">=</span> mid <span class="pl-k">+</span> <span class="pl-c1">1</span>;
            } <span class="pl-k">else</span> {
                r <span class="pl-k">=</span> mid <span class="pl-k">-</span> <span class="pl-c1">1</span>;
            }
        }
        <span class="pl-k">return</span> l;
    }
</pre></div>

<p><br></p>

<p><br></p>

<h3><a id="user-content-36-valid-sudoku" class="anchor" href="https://github.com/wishyouhappy/Algorithm#36-valid-sudoku" aria-hidden="true"><span class="octicon octicon-link"></span></a>36 Valid Sudoku</h3>

<blockquote>
<p>Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules.</p>

<p>The Sudoku board could be partially filled, where empty cells are filled with the character '.'.</p>
</blockquote>

<p><strong>Rules about sudoku</strong>:</p>

<ul>
<li>1) 9×9 grid</li>
<li>2) each column, each row, and each of the nine 3×3 sub-grids that compose the grid (also called "boxes", "blocks", "regions", or "sub-squares") contains all of the digits from 1 to 9</li>
</ul>

<p><strong>Idea</strong>: Check each row, each column and each 3*3 blocks.</p>

<p><strong>Java code</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">boolean</span> isValidSudoku(<span class="pl-k">char</span>[][] board) {
        <span class="pl-k">if</span>(board <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> board<span class="pl-k">.</span>length <span class="pl-k">!=</span> <span class="pl-c1">9</span> <span class="pl-k">||</span> board[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length <span class="pl-k">!=</span> <span class="pl-c1">9</span>) <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> board<span class="pl-k">.</span>length; i<span class="pl-k">++</span>){
            <span class="pl-k">Set&lt;<span class="pl-smi">Character</span>&gt;</span> rset <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashSet&lt;<span class="pl-smi">Character</span>&gt;</span>();
            <span class="pl-k">Set&lt;<span class="pl-smi">Character</span>&gt;</span> cset <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashSet&lt;<span class="pl-smi">Character</span>&gt;</span>();
            <span class="pl-k">for</span>(<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;</span> board[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length; j<span class="pl-k">++</span>){
                <span class="pl-k">char</span> rc <span class="pl-k">=</span> board[i][j];
                <span class="pl-k">if</span>((rc <span class="pl-k">!=</span> <span class="pl-s"><span class="pl-pds">'</span>.<span class="pl-pds">'</span></span> <span class="pl-k">&amp;&amp;</span> (rc <span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">'</span>9<span class="pl-pds">'</span></span> <span class="pl-k">||</span> rc <span class="pl-k">&lt;</span> <span class="pl-s"><span class="pl-pds">'</span>1<span class="pl-pds">'</span></span>)) <span class="pl-k">||</span> rset<span class="pl-k">.</span>contains(rc)) <span class="pl-k">return</span> <span class="pl-c1">false</span>;
                <span class="pl-k">if</span>(rc <span class="pl-k">!=</span> <span class="pl-s"><span class="pl-pds">'</span>.<span class="pl-pds">'</span></span>) rset<span class="pl-k">.</span>add(rc);
                <span class="pl-k">char</span> cc <span class="pl-k">=</span> board[j][i];
                <span class="pl-k">if</span>((cc <span class="pl-k">!=</span> <span class="pl-s"><span class="pl-pds">'</span>.<span class="pl-pds">'</span></span> <span class="pl-k">&amp;&amp;</span> (cc <span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">'</span>9<span class="pl-pds">'</span></span> <span class="pl-k">||</span> cc <span class="pl-k">&lt;</span> <span class="pl-s"><span class="pl-pds">'</span>1<span class="pl-pds">'</span></span>)) <span class="pl-k">||</span> cset<span class="pl-k">.</span>contains(cc)) <span class="pl-k">return</span> <span class="pl-c1">false</span>;
                <span class="pl-k">if</span>(cc <span class="pl-k">!=</span> <span class="pl-s"><span class="pl-pds">'</span>.<span class="pl-pds">'</span></span>) cset<span class="pl-k">.</span>add(cc);
            }
        }
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-c1">3</span>; i<span class="pl-k">++</span>){
            <span class="pl-k">for</span>(<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;</span> <span class="pl-c1">3</span>; j<span class="pl-k">++</span>){
                <span class="pl-k">if</span>(<span class="pl-k">!</span>helper(i, j, board)) <span class="pl-k">return</span> <span class="pl-c1">false</span>;
            }
        }
        <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }
    <span class="pl-k">public</span> <span class="pl-k">boolean</span> helper(<span class="pl-k">int</span> i, <span class="pl-k">int</span> j, <span class="pl-k">char</span>[][] board){
        <span class="pl-k">Set&lt;<span class="pl-smi">Character</span>&gt;</span> set <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashSet&lt;<span class="pl-smi">Character</span>&gt;</span>();
        <span class="pl-k">for</span>(<span class="pl-k">int</span> k <span class="pl-k">=</span> <span class="pl-c1">3</span><span class="pl-k">*</span>i; k <span class="pl-k">&lt;</span> <span class="pl-c1">3</span><span class="pl-k">*</span>i<span class="pl-k">+</span><span class="pl-c1">3</span>; k<span class="pl-k">++</span>){
            <span class="pl-k">for</span>(<span class="pl-k">int</span> l <span class="pl-k">=</span> <span class="pl-c1">3</span><span class="pl-k">*</span>j; l <span class="pl-k">&lt;</span><span class="pl-c1">3</span><span class="pl-k">*</span>j<span class="pl-k">+</span><span class="pl-c1">3</span>; l<span class="pl-k">++</span>){
                <span class="pl-k">char</span> c <span class="pl-k">=</span> board[k][l];
                <span class="pl-k">if</span>((c <span class="pl-k">!=</span> <span class="pl-s"><span class="pl-pds">'</span>.<span class="pl-pds">'</span></span> <span class="pl-k">&amp;&amp;</span>(c <span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">'</span>9<span class="pl-pds">'</span></span> <span class="pl-k">||</span> c <span class="pl-k">&lt;</span> <span class="pl-s"><span class="pl-pds">'</span>1<span class="pl-pds">'</span></span>)) <span class="pl-k">||</span> set<span class="pl-k">.</span>contains(c)) <span class="pl-k">return</span> <span class="pl-c1">false</span>;
                <span class="pl-k">if</span>(c <span class="pl-k">!=</span> <span class="pl-s"><span class="pl-pds">'</span>.<span class="pl-pds">'</span></span>) set<span class="pl-k">.</span>add(c);
            }
        }
        <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }
</pre></div>

<p><br></p>

<p><br></p>

<h3><a id="user-content-37-sudoku-solver" class="anchor" href="https://github.com/wishyouhappy/Algorithm#37-sudoku-solver" aria-hidden="true"><span class="octicon octicon-link"></span></a>37 Sudoku Solver</h3>

<blockquote>
<p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p>

<p>Empty cells are indicated by the character '.'.</p>

<p>You may assume that there will be only one unique solution.</p>
</blockquote>

<p><strong>Idea</strong>: we solve the sudoku line by line, every time we fill in a filed, we check if is valid. We can use the method in * <a href="https://github.com/wishyouhappy/Algorithm#36-valid-sudoku">36 Valid Sudoku</a> to check the sudoku</p>

<p><strong>Java code</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">void</span> solveSudoku(<span class="pl-k">char</span>[][] board) {
        <span class="pl-k">if</span>(board <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> board<span class="pl-k">.</span>length <span class="pl-k">!=</span> <span class="pl-c1">9</span> <span class="pl-k">|</span> board[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length <span class="pl-k">!=</span> <span class="pl-c1">9</span>) <span class="pl-k">return</span>;
        solverHelper(board, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>);
    }

    <span class="pl-k">public</span> <span class="pl-k">boolean</span> solverHelper(<span class="pl-k">char</span>[][] board, <span class="pl-k">int</span> i, <span class="pl-k">int</span> j){
        <span class="pl-k">if</span>(j <span class="pl-k">==</span> <span class="pl-c1">9</span>) <span class="pl-k">return</span> solverHelper(board, i<span class="pl-k">+</span><span class="pl-c1">1</span>, <span class="pl-c1">0</span>);
        <span class="pl-k">if</span>(i <span class="pl-k">==</span> <span class="pl-c1">9</span>) <span class="pl-k">return</span> <span class="pl-c1">true</span>;
        <span class="pl-k">if</span>(board[i][j] <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>.<span class="pl-pds">'</span></span>){
            <span class="pl-k">for</span>(<span class="pl-k">int</span> k <span class="pl-k">=</span> <span class="pl-c1">1</span>; k <span class="pl-k">&lt;=</span><span class="pl-c1">9</span>; k<span class="pl-k">++</span>){
                board[i][j] <span class="pl-k">=</span> (<span class="pl-k">char</span>)(k<span class="pl-k">+</span><span class="pl-s"><span class="pl-pds">'</span>0<span class="pl-pds">'</span></span>);
                <span class="pl-k">if</span>(isValid(board, i, j)){
                   <span class="pl-k">if</span>(solverHelper(board, i, j<span class="pl-k">+</span><span class="pl-c1">1</span>)) <span class="pl-k">return</span> <span class="pl-c1">true</span>;
                }
            }
            board[i][j] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>.<span class="pl-pds">'</span></span>;
        }<span class="pl-k">else</span> <span class="pl-k">return</span>  solverHelper(board, i, j<span class="pl-k">+</span><span class="pl-c1">1</span>);
        <span class="pl-k">return</span> <span class="pl-c1">false</span>;
    }
    <span class="pl-k">public</span> <span class="pl-k">boolean</span> isValid(<span class="pl-k">char</span>[][] board, <span class="pl-k">int</span> i, <span class="pl-k">int</span> j) {
         <span class="pl-k">for</span>(<span class="pl-k">int</span> k <span class="pl-k">=</span> <span class="pl-c1">0</span>; k <span class="pl-k">&lt;</span> <span class="pl-c1">9</span>; k<span class="pl-k">++</span>){
             <span class="pl-k">if</span>(k <span class="pl-k">!=</span> j <span class="pl-k">&amp;&amp;</span> board[i][k] <span class="pl-k">==</span> board[i][j]) <span class="pl-k">return</span> <span class="pl-c1">false</span>;
             <span class="pl-k">if</span>(k <span class="pl-k">!=</span> i <span class="pl-k">&amp;&amp;</span> board[i][j] <span class="pl-k">==</span> board[k][j]) <span class="pl-k">return</span> <span class="pl-c1">false</span>;
         }

         <span class="pl-k">for</span>(<span class="pl-k">int</span> r <span class="pl-k">=</span> i<span class="pl-k">/</span><span class="pl-c1">3</span> <span class="pl-k">*</span><span class="pl-c1">3</span>; r <span class="pl-k">&lt;</span> i<span class="pl-k">/</span><span class="pl-c1">3</span> <span class="pl-k">*</span><span class="pl-c1">3</span> <span class="pl-k">+</span><span class="pl-c1">3</span>; r<span class="pl-k">++</span>){
             <span class="pl-k">for</span>(<span class="pl-k">int</span> c <span class="pl-k">=</span> j<span class="pl-k">/</span><span class="pl-c1">3</span> <span class="pl-k">*</span> <span class="pl-c1">3</span>; c <span class="pl-k">&lt;</span> j<span class="pl-k">/</span><span class="pl-c1">3</span> <span class="pl-k">*</span> <span class="pl-c1">3</span><span class="pl-k">+</span><span class="pl-c1">3</span>; c<span class="pl-k">++</span>){
                 <span class="pl-k">if</span>((r <span class="pl-k">!=</span> i <span class="pl-k">||</span> c <span class="pl-k">!=</span> j) <span class="pl-k">&amp;&amp;</span> board[r][c] <span class="pl-k">==</span> board[i][j]) <span class="pl-k">return</span> <span class="pl-c1">false</span>;
             }
         }
         <span class="pl-k">return</span> <span class="pl-c1">true</span>;
     }
</pre></div>

<p><br></p>

<p><br></p>

<h3><a id="user-content-38-count-and-say" class="anchor" href="https://github.com/wishyouhappy/Algorithm#38-count-and-say" aria-hidden="true"><span class="octicon octicon-link"></span></a>38 Count and Say</h3>

<blockquote>
<p>The count-and-say sequence is the sequence of integers beginning as follows:</p>

<p>1, 11, 21, 1211, 111221, ...</p>

<p>1 is read off as "one 1" or 11.</p>

<p>11 is read off as "two 1s" or 21.</p>

<p>21 is read off as "one 2, then one 1" or 1211.</p>

<p>Given an integer n, generate the nth sequence.</p>

<p>Note: The sequence of integers will be represented as a string.</p>
</blockquote>

<p><strong>Idea</strong>: Calculate the string based on the previous one. Each time count the repeating times of each character. It's similar to compress string based on its repeating times.</p>

<p><strong>Java code</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-smi">String</span> countAndSay(<span class="pl-k">int</span> n) {
        <span class="pl-k">if</span>(n <span class="pl-k">&lt;=</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>;
        <span class="pl-k">if</span>(n <span class="pl-k">==</span> <span class="pl-c1">1</span>) <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>;
        <span class="pl-smi">StringBuilder</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">StringBuilder</span>();
        res<span class="pl-k">.</span>append(<span class="pl-c1">1</span>);
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">2</span>; i <span class="pl-k">&lt;=</span> n; i<span class="pl-k">++</span>){
            <span class="pl-smi">String</span> temp <span class="pl-k">=</span> res<span class="pl-k">.</span>toString();
            <span class="pl-smi">StringBuilder</span> cur <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">StringBuilder</span>();
            <span class="pl-k">char</span> pre <span class="pl-k">=</span> temp<span class="pl-k">.</span>charAt(<span class="pl-c1">0</span>);
            <span class="pl-k">int</span> count <span class="pl-k">=</span> <span class="pl-c1">1</span>;
            <span class="pl-k">for</span>(<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">1</span>; j <span class="pl-k">&lt;</span> temp<span class="pl-k">.</span>length(); j<span class="pl-k">++</span>){
                <span class="pl-k">if</span>(pre <span class="pl-k">!=</span> temp<span class="pl-k">.</span>charAt(j)){
                    cur<span class="pl-k">.</span>append(count);
                    cur<span class="pl-k">.</span>append(pre);
                    pre <span class="pl-k">=</span> temp<span class="pl-k">.</span>charAt(j);
                    count <span class="pl-k">=</span> <span class="pl-c1">1</span>;
                }<span class="pl-k">else</span> count<span class="pl-k">++</span>;
            }
            cur<span class="pl-k">.</span>append(count);
            cur<span class="pl-k">.</span>append(pre);
            res <span class="pl-k">=</span> cur;
        }
        <span class="pl-k">return</span> res<span class="pl-k">.</span>toString();
    }

</pre></div>

<p><br></p>

<p><br></p>

<h3><a id="user-content-39-combination-sum" class="anchor" href="https://github.com/wishyouhappy/Algorithm#39-combination-sum" aria-hidden="true"><span class="octicon octicon-link"></span></a>39 Combination Sum</h3>

<blockquote>
<p>Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.</p>

<p><strong>The same repeated number may be chosen from C unlimited number of times.</strong></p>

<p>Note:</p>

<p>All numbers (including target) will be positive integers.</p>

<p>Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).</p>

<p>The solution set must not contain duplicate combinations.</p>

<p>For example, given candidate set 2,3,6,7 and target 7, </p>
</blockquote>

<pre>A solution set is: 
[7] 
[2, 2, 3] 

</pre>

<p><strong>Idea</strong>: We need to add combination in non-descending order, thus its better to first sort candidates. Off course, we can handle the duplicates and sequence in latter if we don't sort it. Then we add element to list, minus the current and go to the next recursion.</p>

<p><strong>Java code</strong>:</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> combinationSum(<span class="pl-k">int</span>[] candidates, <span class="pl-k">int</span> target) {
    <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>();
    <span class="pl-k">if</span>(candidates <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> candidates<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
        <span class="pl-k">return</span> res;
    }
    <span class="pl-smi">Arrays</span><span class="pl-k">.</span>sort(candidates);
    combinationSum(candidates, target, res, <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>(), <span class="pl-c1">0</span>);
    <span class="pl-k">return</span> res;
}
<span class="pl-k">public</span> <span class="pl-k">void</span> combinationSum(<span class="pl-k">int</span>[] candidates, <span class="pl-k">int</span> target, <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> res, <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> cur, <span class="pl-k">int</span> start){
    <span class="pl-k">if</span> (target <span class="pl-k">&lt;</span> <span class="pl-c1">0</span>) {
        <span class="pl-k">return</span>;
    }
    <span class="pl-k">if</span> (target <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
        res<span class="pl-k">.</span>add(<span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>(cur));
        <span class="pl-k">return</span>;
    }
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> start; i <span class="pl-k">&lt;</span> candidates<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
        cur<span class="pl-k">.</span>add(candidates[i]);
        combinationSum(candidates, target<span class="pl-k">-</span>candidates[i], res, cur, i);
        cur<span class="pl-k">.</span>remove(cur<span class="pl-k">.</span>size()<span class="pl-k">-</span><span class="pl-c1">1</span>);
    }
}
</pre></div>

<p><br></p>

<p><br></p>

<h3><a id="user-content-40-combination-sum-ii" class="anchor" href="https://github.com/wishyouhappy/Algorithm#40-combination-sum-ii" aria-hidden="true"><span class="octicon octicon-link"></span></a>40 Combination Sum II</h3>

<blockquote>
<p>Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.</p>

<p><strong>Each number in C may only be used once in the combination.</strong></p>

<p>Note:</p>

<p>All numbers (including target) will be positive integers.</p>

<p>Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).</p>
</blockquote>

<pre>The solution set must not contain duplicate combinations.
For example, given candidate set 10,1,2,7,6,1,5 and target 8, 
A solution set is: 
[1, 7] 
[1, 2, 5] 
[2, 6] 
[1, 1, 6] 

</pre>

<p><strong>Idea</strong>: The difference with <a href="https://github.com/wishyouhappy/Algorithm#39-combination-Sum">39 Combination Sum</a>] is that in ths problem we can only use each number once. So when go to next recursion, the start position should change to i+1, so that it will add itself again. </p>

<p><strong>Java code</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> combinationSum2(<span class="pl-k">int</span>[] candidates, <span class="pl-k">int</span> target) {
        <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>();
        <span class="pl-k">if</span>(candidates <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> candidates<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> res;
        }
        <span class="pl-smi">Arrays</span><span class="pl-k">.</span>sort(candidates);
        combinationSum(candidates, target, res, <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>(), <span class="pl-c1">0</span>);
        <span class="pl-k">return</span> res;
    }
    <span class="pl-k">public</span> <span class="pl-k">void</span> combinationSum(<span class="pl-k">int</span>[] candidates, <span class="pl-k">int</span> target, <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> res, <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> cur, <span class="pl-k">int</span> start){
        <span class="pl-k">if</span> (target <span class="pl-k">&lt;</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span>;
        }
        <span class="pl-k">if</span> (target <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            res<span class="pl-k">.</span>add(<span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>(cur));
            <span class="pl-k">return</span>;
        }
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> start; i <span class="pl-k">&lt;</span> candidates<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
            <span class="pl-k">if</span> (i <span class="pl-k">&gt;</span> start <span class="pl-k">&amp;&amp;</span> candidates[i] <span class="pl-k">==</span> candidates[i <span class="pl-k">-</span> <span class="pl-c1">1</span>]) {
                <span class="pl-k">continue</span>;
            }
            cur<span class="pl-k">.</span>add(candidates[i]);
            combinationSum(candidates, target<span class="pl-k">-</span>candidates[i], res, cur, i <span class="pl-k">+</span> <span class="pl-c1">1</span>);
            cur<span class="pl-k">.</span>remove(cur<span class="pl-k">.</span>size()<span class="pl-k">-</span><span class="pl-c1">1</span>);
        }
    }
</pre></div>

<p><br></p>

<p><br></p>

<h3><a id="user-content-41-first-missing-positive" class="anchor" href="https://github.com/wishyouhappy/Algorithm#41-first-missing-positive" aria-hidden="true"><span class="octicon octicon-link"></span></a>41 First Missing Positive</h3>

<blockquote>
<p>Given an unsorted integer array, find the first missing positive integer.</p>

<p>For example,</p>

<p>Given [1,2,0] return 3,</p>

<p>and [3,4,-1,1] return 2.</p>

<p>Your algorithm should run in O(n) time and uses constant space.</p>
</blockquote>

<p><br></p>

<p><strong>Idea</strong>: This problem has the same idea with the counting sort problem. If no element is missing, then A[A[i]-1] = A[i]. Thus, we just need to put the element to its original place and have another pass to check the miss element.</p>

<p><strong>Java code</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> firstMissingPositive(<span class="pl-k">int</span>[] <span class="pl-smi">A</span>) {
        <span class="pl-k">if</span>(<span class="pl-smi">A</span> <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">1</span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length; i<span class="pl-k">++</span>){
            <span class="pl-k">if</span>(<span class="pl-k">A</span>[i] <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> <span class="pl-k">A</span>[i] <span class="pl-k">-</span> <span class="pl-c1">1</span> <span class="pl-k">&lt;</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length <span class="pl-k">&amp;&amp;</span> <span class="pl-k">A</span>[<span class="pl-k">A</span>[i]<span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">!=</span> <span class="pl-k">A</span>[i]){
                <span class="pl-k">int</span> temp <span class="pl-k">=</span> <span class="pl-k">A</span>[<span class="pl-k">A</span>[i]<span class="pl-k">-</span><span class="pl-c1">1</span>];
                <span class="pl-k">A</span>[<span class="pl-k">A</span>[i]<span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">=</span> <span class="pl-k">A</span>[i];
                <span class="pl-k">A</span>[i] <span class="pl-k">=</span> temp;
                i<span class="pl-k">--</span>;
            } 
        }
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length; i<span class="pl-k">++</span>){
            <span class="pl-k">if</span>(<span class="pl-k">A</span>[i] <span class="pl-k">!=</span> i<span class="pl-k">+</span><span class="pl-c1">1</span>) <span class="pl-k">return</span> i<span class="pl-k">+</span><span class="pl-c1">1</span>;
        }
        <span class="pl-k">return</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length<span class="pl-k">+</span><span class="pl-c1">1</span>;
    }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-42-trapping-rain-water" class="anchor" href="https://github.com/wishyouhappy/Algorithm#42-trapping-rain-water" aria-hidden="true"><span class="octicon octicon-link"></span></a>42 Trapping Rain Water</h3>

<blockquote>
<p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
</blockquote>

<p>For example, 
Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.</p>

<p><strong>Idea</strong>: </p>

<ul>
<li>1) Solution1: Like <a href="https://github.com/wishyouhappy/Algorithm#11-container-with-most-water">11 Container with Most Water</a>, we record two pointers, l and r, min = min(A[l], A[r]), if A[l] &lt; A[r], we move right, and add water if A[l] &lt; min; similarly, if A[l] &gt; A[r], we move r left, and if A[r] &lt; min, we add water. When l &gt;= r, we get the total volumn. </li>
</ul>

<div class="highlight highlight-java"><pre> <span class="pl-k">public</span> <span class="pl-k">int</span> trap(<span class="pl-k">int</span>[] <span class="pl-smi">A</span>) {
    <span class="pl-k">if</span>(<span class="pl-smi">A</span> <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
    <span class="pl-k">int</span> res <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">int</span> l <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">int</span> r <span class="pl-k">=</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>;
    <span class="pl-k">while</span>(l <span class="pl-k">&lt;</span> r){
        <span class="pl-k">int</span> min <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>min(<span class="pl-k">A</span>[l], <span class="pl-k">A</span>[r]);
        <span class="pl-k">if</span>(<span class="pl-k">A</span>[l] <span class="pl-k">&lt;</span> <span class="pl-k">A</span>[r]){
            l<span class="pl-k">++</span>;
            <span class="pl-k">while</span>(l <span class="pl-k">&lt;</span> r <span class="pl-k">&amp;&amp;</span> <span class="pl-k">A</span>[l] <span class="pl-k">&lt;</span> min){
                res <span class="pl-k">+=</span> min <span class="pl-k">-</span> <span class="pl-k">A</span>[l<span class="pl-k">++</span>];
            }
        }<span class="pl-k">else</span>{
            r<span class="pl-k">--</span>;
            <span class="pl-k">while</span>(l <span class="pl-k">&lt;</span> r <span class="pl-k">&amp;&amp;</span> <span class="pl-k">A</span>[r] <span class="pl-k">&lt;</span> min){
                res <span class="pl-k">+=</span> min <span class="pl-k">-</span> <span class="pl-k">A</span>[r<span class="pl-k">--</span>];
            }
        }
    }
    <span class="pl-k">return</span> res;
  }
</pre></div>

<p><br></p>

<ul>
<li>2)solution 2 : we traverse the array two times, left to right and right to left. Then we can get the min(max height on the left of A[i], max height on the right of A[i]). So add the capacity of each bar, we get the total capacity.</li>
</ul>

<div class="highlight highlight-java"><pre>      <span class="pl-k">public</span> <span class="pl-k">int</span> trap(<span class="pl-k">int</span>[] <span class="pl-smi">A</span>) {
        <span class="pl-k">if</span>(<span class="pl-smi">A</span> <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span>[] left <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[<span class="pl-smi">A</span><span class="pl-k">.</span>length];
        <span class="pl-k">int</span> max <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length; i<span class="pl-k">++</span>){
            left[i] <span class="pl-k">=</span> max;
            max <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(max, <span class="pl-k">A</span>[i]);
        }

        <span class="pl-k">int</span> res <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        max <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length<span class="pl-k">-</span><span class="pl-c1">1</span>; i<span class="pl-k">&gt;=</span><span class="pl-c1">0</span>; i<span class="pl-k">--</span>){
            res <span class="pl-k">+=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>min(max, left[i]) <span class="pl-k">-</span> <span class="pl-k">A</span>[i] <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">?</span> (<span class="pl-smi">Math</span><span class="pl-k">.</span>min(max, left[i]) <span class="pl-k">-</span> <span class="pl-k">A</span>[i])<span class="pl-k">:</span> <span class="pl-c1">0</span> ;
            max <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(max, <span class="pl-k">A</span>[i]);
        }
        <span class="pl-k">return</span> res;
    }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-43-multiply-strings" class="anchor" href="https://github.com/wishyouhappy/Algorithm#43-multiply-strings" aria-hidden="true"><span class="octicon octicon-link"></span></a>43 Multiply Strings</h3>

<blockquote>
<p>Given two numbers represented as strings, return multiplication of the numbers as a string.</p>

<p>Note: The numbers can be arbitrarily large and are non-negative.</p>
</blockquote>

<p><br></p>

<p><strong>Idea</strong>: If length is n and m, result's length is n+m or n+m-1, result of index i = 0 * i + 1 * i-1 ..... i * 0</p>

<p><strong>Attention</strong>: We should not add the leftmost zero.</p>

<p><strong>Java code</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-smi">String</span> multiply(<span class="pl-smi">String</span> num1, <span class="pl-smi">String</span> num2) {
        <span class="pl-k">if</span>(num1 <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> num2 <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">return</span> <span class="pl-c1">null</span>;
        <span class="pl-k">if</span>(num1<span class="pl-k">.</span>equals(<span class="pl-s"><span class="pl-pds">"</span>0<span class="pl-pds">"</span></span>) <span class="pl-k">||</span> num2<span class="pl-k">.</span>equals(<span class="pl-s"><span class="pl-pds">"</span>0<span class="pl-pds">"</span></span>)) <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>0<span class="pl-pds">"</span></span>;
        <span class="pl-smi">StringBuilder</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">StringBuilder</span>();
        <span class="pl-k">int</span> cur <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i<span class="pl-k">=</span> num1<span class="pl-k">.</span>length() <span class="pl-k">+</span> num2<span class="pl-k">.</span>length() <span class="pl-k">-</span><span class="pl-c1">1</span>;i <span class="pl-k">&gt;=</span><span class="pl-c1">0</span>; i<span class="pl-k">--</span>){
            <span class="pl-k">for</span>(<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>min(i<span class="pl-k">-</span><span class="pl-c1">1</span>, num1<span class="pl-k">.</span>length()<span class="pl-k">-</span><span class="pl-c1">1</span>);j <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>; j<span class="pl-k">--</span>){
                <span class="pl-k">if</span>(j <span class="pl-k">&lt;</span> num1<span class="pl-k">.</span>length() <span class="pl-k">&amp;&amp;</span> ((i<span class="pl-k">-</span>j<span class="pl-k">-</span><span class="pl-c1">1</span>) <span class="pl-k">&lt;</span> num2<span class="pl-k">.</span>length())) {
                    cur <span class="pl-k">+=</span> (<span class="pl-k">int</span>)(num1<span class="pl-k">.</span>charAt(j) <span class="pl-k">-</span> <span class="pl-s"><span class="pl-pds">'</span>0<span class="pl-pds">'</span></span>) <span class="pl-k">*</span> (<span class="pl-k">int</span>)(num2<span class="pl-k">.</span>charAt(i<span class="pl-k">-</span>j<span class="pl-k">-</span><span class="pl-c1">1</span>) <span class="pl-k">-</span> <span class="pl-s"><span class="pl-pds">'</span>0<span class="pl-pds">'</span></span>);
                }
            }
            <span class="pl-k">if</span>(i <span class="pl-k">!=</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> cur <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>) res<span class="pl-k">.</span>insert(<span class="pl-c1">0</span>, cur <span class="pl-k">%</span> <span class="pl-c1">10</span>);
            cur <span class="pl-k">=</span> cur <span class="pl-k">/</span> <span class="pl-c1">10</span>;
        }
        <span class="pl-k">return</span> res<span class="pl-k">.</span>toString();
    }

</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-44-wildcard-matching" class="anchor" href="https://github.com/wishyouhappy/Algorithm#44-wildcard-matching" aria-hidden="true"><span class="octicon octicon-link"></span></a>44 Wildcard Matching</h3>

<blockquote>
<p>Implement wildcard pattern matching with support for '?' and '*'.</p>
</blockquote>

<pre>'?' Matches any single character.
'*' Matches any sequence of characters (including the empty sequence).

The matching should cover the entire input string (not partial).

The function prototype should be:
bool isMatch(const char *s, const char *p)

Some examples:
isMatch("aa","a") → false
isMatch("aa","aa") → true
isMatch("aaa","aa") → false
isMatch("aa", "*") → true
isMatch("aa", "a*") → true
isMatch("ab", "?*") → true
isMatch("aab", "c*a*b") → false

</pre>

<p><strong>Idea</strong>: This problem is similar with <a href="https://github.com/wishyouhappy/Algorithm#10-regular-expression-matching">10 Regular Expression Matching</a>. The difference is that '.' is replace with '?'. And '*' can match any sequence including empty. We can use the method in <a href="https://github.com/wishyouhappy/Algorithm#10-regular-expression-matching">10 Regular Expression Matching</a>. Or we use two pointers to record the return place in s and p when encounter a '*'</p>

<p><strong>Iterative Code</strong>:</p>

<div class="highlight highlight-java"><pre>     <span class="pl-k">public</span> <span class="pl-k">boolean</span> isMatch(<span class="pl-smi">String</span> s, <span class="pl-smi">String</span> p) {
        <span class="pl-k">if</span>(s <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> p <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> p<span class="pl-k">.</span>equals(<span class="pl-s"><span class="pl-pds">"</span>*<span class="pl-pds">"</span></span>)) <span class="pl-k">return</span> <span class="pl-c1">true</span>;
        <span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>, j <span class="pl-k">=</span> <span class="pl-c1">0</span>, savei <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">1</span>, savej <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
        <span class="pl-k">while</span>(i <span class="pl-k">&lt;</span> s<span class="pl-k">.</span>length()){
            <span class="pl-k">if</span>(j <span class="pl-k">&lt;</span> p<span class="pl-k">.</span>length() <span class="pl-k">&amp;&amp;</span> (s<span class="pl-k">.</span>charAt(i) <span class="pl-k">==</span> p<span class="pl-k">.</span>charAt(j) <span class="pl-k">||</span> p<span class="pl-k">.</span>charAt(j) <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>?<span class="pl-pds">'</span></span>)){
                i<span class="pl-k">++</span>;
                j<span class="pl-k">++</span>;
            }<span class="pl-k">else</span> <span class="pl-k">if</span>(j <span class="pl-k">&lt;</span> p<span class="pl-k">.</span>length() <span class="pl-k">&amp;&amp;</span> p<span class="pl-k">.</span>charAt(j) <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>*<span class="pl-pds">'</span></span>){
                savei <span class="pl-k">=</span> i;
                savej <span class="pl-k">=</span> j<span class="pl-k">++</span>;
            }<span class="pl-k">else</span> <span class="pl-k">if</span>(savej <span class="pl-k">!=</span> <span class="pl-k">-</span><span class="pl-c1">1</span>){
                j <span class="pl-k">=</span> savej <span class="pl-k">+</span> <span class="pl-c1">1</span>;
                i <span class="pl-k">=</span> <span class="pl-k">++</span>savei;
            }<span class="pl-k">else</span> <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        <span class="pl-k">while</span>(j <span class="pl-k">&lt;</span> p<span class="pl-k">.</span>length() <span class="pl-k">&amp;&amp;</span> p<span class="pl-k">.</span>charAt(j) <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>*<span class="pl-pds">'</span></span>) j<span class="pl-k">++</span>;
        <span class="pl-k">return</span> j <span class="pl-k">==</span> p<span class="pl-k">.</span>length();
    }
</pre></div>

<p><strong>Recursion</strong>: it might exceed the time limit</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">boolean</span> isMatch2(<span class="pl-smi">String</span> s, <span class="pl-smi">String</span> p) {
        <span class="pl-k">if</span>((s <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> p <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">||</span> p<span class="pl-k">.</span>equals(<span class="pl-s"><span class="pl-pds">"</span>*<span class="pl-pds">"</span></span>)) <span class="pl-k">return</span> <span class="pl-c1">true</span>;
        <span class="pl-k">return</span> helper(s, p, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>);
    }

    <span class="pl-k">public</span> <span class="pl-k">boolean</span> helper(<span class="pl-smi">String</span> s, <span class="pl-smi">String</span> p, <span class="pl-k">int</span> i, <span class="pl-k">int</span> j){
        <span class="pl-k">if</span>(j <span class="pl-k">==</span> p<span class="pl-k">.</span>length()) <span class="pl-k">return</span> i <span class="pl-k">==</span> s<span class="pl-k">.</span>length();
        <span class="pl-k">if</span>(p<span class="pl-k">.</span>charAt(j) <span class="pl-k">!=</span> <span class="pl-s"><span class="pl-pds">'</span>*<span class="pl-pds">'</span></span>){
            <span class="pl-k">if</span>(i <span class="pl-k">&lt;</span> s<span class="pl-k">.</span>length() <span class="pl-k">&amp;&amp;</span> (s<span class="pl-k">.</span>charAt(i) <span class="pl-k">==</span> p<span class="pl-k">.</span>charAt(j) <span class="pl-k">||</span> p<span class="pl-k">.</span>charAt(j) <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>?<span class="pl-pds">'</span></span>)) <span class="pl-k">return</span> helper(s, p, i<span class="pl-k">+</span><span class="pl-c1">1</span>, j<span class="pl-k">+</span><span class="pl-c1">1</span>);
            <span class="pl-k">else</span> <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }<span class="pl-k">else</span>{
            <span class="pl-k">while</span>(i <span class="pl-k">&lt;</span> s<span class="pl-k">.</span>length()){
                <span class="pl-k">if</span>(helper(s, p, i<span class="pl-k">++</span>, j<span class="pl-k">+</span><span class="pl-c1">1</span>)) <span class="pl-k">return</span> <span class="pl-c1">true</span>;
            }
            <span class="pl-k">return</span> helper(s, p, i, j<span class="pl-k">+</span><span class="pl-c1">1</span>);
        }
    }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-45-jump-game-ii" class="anchor" href="https://github.com/wishyouhappy/Algorithm#45-jump-game-ii" aria-hidden="true"><span class="octicon octicon-link"></span></a>45 Jump Game II</h3>

<blockquote>
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.Each element in the array represents your maximum jump length at that position.</p>

<p>Your goal is to reach the last index in the minimum number of jumps.</p>
</blockquote>

<pre>For example:
Given array A = [2,3,1,1,4]

The minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.)

</pre>

<p><br></p>

<p><strong>Idea</strong>: The basic idea is same with Jump Game. Difference is that in this problem we need to calculate the optimal steps. How can We get the minimum steps? The idea is that we only increase steps when we found that the <strong>current position i is greater than the previous step max</strong>, which means that if you want to reach further, you need to increase steps.  </p>

<p><strong>Java code</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> jump(<span class="pl-k">int</span>[] <span class="pl-smi">A</span>) {
        <span class="pl-k">if</span>(<span class="pl-smi">A</span> <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length <span class="pl-k">&lt;=</span> <span class="pl-c1">1</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> max <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> canReach <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> res <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length; i<span class="pl-k">++</span>){
            <span class="pl-k">if</span>(i <span class="pl-k">&gt;</span> max) <span class="pl-k">return</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;  <span class="pl-c">// check if you can reach to the end.</span>
            <span class="pl-k">if</span>(i <span class="pl-k">&gt;</span> canReach){
                res<span class="pl-k">++</span>;
                canReach <span class="pl-k">=</span> max;
            }
            max <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(max, i <span class="pl-k">+</span> <span class="pl-k">A</span>[i]);
        }
        <span class="pl-k">return</span> res;
    }
</pre></div>

<p><br></p>

<p><strong>Similar solution</strong>:</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">int</span> minJump(<span class="pl-k">int</span>[] array) {
    <span class="pl-k">int</span> res <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">int</span> currentMax <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">int</span> max <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> array<span class="pl-k">.</span>length <span class="pl-k">&amp;&amp;</span> i <span class="pl-k">&lt;=</span> max; i<span class="pl-k">++</span>) {
      <span class="pl-k">if</span> (currentMax <span class="pl-k">&lt;</span> i) {
        res<span class="pl-k">++</span>;
        currentMax <span class="pl-k">=</span> max;
      }
      max <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(max, array[i] <span class="pl-k">+</span> i);
    } 
    <span class="pl-k">return</span> max <span class="pl-k">&lt;</span> array<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span> <span class="pl-k">?</span> <span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-k">:</span> res;
  }</pre></div>

<p><br>
<strong>Related: min steps to jump out of the array</strong>
<strong>Idea</strong>: Based on the solution in jump game two, we need to check if the max can reach to the end of array. But this time we need to compare if max &lt;= array.length - 1, because we need to jump out of array.</p>

<p>Also, we need to return the min steps to jump out the array, thus we need to check if based on the min steps, if we can reach out to the end of the array. </p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">int</span> minJump(<span class="pl-k">int</span>[] array) {
    <span class="pl-k">int</span> res <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">int</span> currentMax <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">int</span> max <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> array<span class="pl-k">.</span>length <span class="pl-k">&amp;&amp;</span> i <span class="pl-k">&lt;=</span> max; i<span class="pl-k">++</span>) {
      <span class="pl-k">if</span> (currentMax <span class="pl-k">&lt;</span> i) {
        res<span class="pl-k">++</span>;
        currentMax <span class="pl-k">=</span> max;
      }
      <span class="pl-k">if</span> (currentMax <span class="pl-k">&gt;</span> array<span class="pl-k">.</span>length) {
          <span class="pl-k">return</span> res;
      }
      max <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(max, array[i] <span class="pl-k">+</span> i);
    } 
    <span class="pl-k">return</span> max <span class="pl-k">&lt;=</span> array<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span> <span class="pl-k">?</span> <span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-k">:</span> (currentMax <span class="pl-k">&gt;=</span> array<span class="pl-k">.</span>length <span class="pl-k">?</span> res <span class="pl-k">:</span> res <span class="pl-k">+</span> <span class="pl-c1">1</span>);
  }

</pre></div>

<p><br></p>

<h3><a id="user-content-46-permutations" class="anchor" href="https://github.com/wishyouhappy/Algorithm#46-permutations" aria-hidden="true"><span class="octicon octicon-link"></span></a>46 Permutations</h3>

<blockquote>
<p>Given a collection of numbers, return all possible permutations.</p>
</blockquote>

<p><strong>No duplicate number in collection</strong></p>

<pre>For example,
[1,2,3] have the following permutations:
[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], and [3,2,1].
</pre>

<p><strong>Idea</strong>:</p>

<p>Since there is no duplicate, we can add element one by one. For example:</p>

<p>1,</p>

<p>1 2, 2 1</p>

<p>3 1 2, 1 3 2, 1 2 3, 3 2 1, 2 3 1, 2 1 3</p>

<p><strong>Jave code</strong>:</p>

<p><em>Iterative</em>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> permute(<span class="pl-k">int</span>[] num) {
        <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>();
        <span class="pl-k">if</span> (num <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> num<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> res;
        }
        <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> first <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
        first<span class="pl-k">.</span>add(num[<span class="pl-c1">0</span>]);
        res<span class="pl-k">.</span>add(first);
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;</span> num<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
            <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> cur <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>();
            <span class="pl-k">for</span> (<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> l <span class="pl-k">:</span> res) {
                <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;=</span> l<span class="pl-k">.</span>size(); j<span class="pl-k">++</span>) {
                    <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> temp <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>(l);
                    temp<span class="pl-k">.</span>add(j, num[i]);
                    cur<span class="pl-k">.</span>add(temp);
                }
            }
            res <span class="pl-k">=</span> cur;
        }
        <span class="pl-k">return</span> res;
    } 
</pre></div>

<p><em>recursion</em>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> permute(<span class="pl-k">int</span>[] num) {
        <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> list <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>();
        <span class="pl-k">if</span> (num <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> num<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> list;
        }
        <span class="pl-k">return</span> permute(list, num, <span class="pl-c1">0</span>);
    }

    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> permute(<span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> list, <span class="pl-k">int</span>[] num, <span class="pl-k">int</span> i){
        <span class="pl-k">if</span> (i <span class="pl-k">==</span> num<span class="pl-k">.</span>length) {
            <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> arr <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
            list<span class="pl-k">.</span>add(arr);
            <span class="pl-k">return</span> list;
        }

        list <span class="pl-k">=</span> permute(list, num, i<span class="pl-k">+</span><span class="pl-c1">1</span>);
        <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> current <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>();
        <span class="pl-k">for</span> (<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> l <span class="pl-k">:</span> list) {
            <span class="pl-k">if</span> (l<span class="pl-k">.</span>size() <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
                <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> arr <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
                arr<span class="pl-k">.</span>add(num[i]);
                current<span class="pl-k">.</span>add(arr);
            } <span class="pl-k">else</span> {
                <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;=</span> l<span class="pl-k">.</span>size(); j<span class="pl-k">++</span>) {
                    <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> arr <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>(l);
                    arr<span class="pl-k">.</span>add(j, num[i]);
                    current<span class="pl-k">.</span>add(arr);
                }
            }
        }
        list <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>(current);
        <span class="pl-k">return</span> list;
    }
</pre></div>

<p><br></p>

<p><br></p>

<p><strong>Another way</strong>: use swap</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> permutations(<span class="pl-smi">String</span> set) {
    <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">String</span>&gt;</span>();
    <span class="pl-k">if</span> (set <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span> res;
    }
    permutations(res, <span class="pl-c1">0</span>, set<span class="pl-k">.</span>toCharArray());
    <span class="pl-k">return</span> res;
  }

  <span class="pl-k">public</span> <span class="pl-k">void</span> permutations(<span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> res, <span class="pl-k">int</span> index, <span class="pl-k">char</span>[] arr) {
    <span class="pl-k">if</span> (index <span class="pl-k">==</span> arr<span class="pl-k">.</span>length) {
      <span class="pl-smi">String</span> s <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">String</span>(arr);
      res<span class="pl-k">.</span>add(s);
      <span class="pl-k">return</span>;
    }
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> index; i <span class="pl-k">&lt;</span> arr<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
      swap(arr, i, index);
      permutations(res, index <span class="pl-k">+</span> <span class="pl-c1">1</span>, arr);
      swap(arr, i, index);
    }
  }

  <span class="pl-k">public</span> <span class="pl-k">void</span> swap(<span class="pl-k">char</span>[] arr, <span class="pl-k">int</span> i, <span class="pl-k">int</span> j) {
    <span class="pl-k">char</span> temp <span class="pl-k">=</span> arr[i];
    arr[i] <span class="pl-k">=</span> arr[j];
    arr[j] <span class="pl-k">=</span> temp;
  }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-47-permutations-ii" class="anchor" href="https://github.com/wishyouhappy/Algorithm#47-permutations-ii" aria-hidden="true"><span class="octicon octicon-link"></span></a>47 Permutations II</h3>

<blockquote>
<p>Given a collection of numbers that might <strong>contain duplicates</strong>, return all possible unique permutations.</p>
</blockquote>

<p>For example,
[1,1,2] have the following unique permutations:
[1,1,2], [1,2,1], and [2,1,1].
<br></p>

<p><strong>Idea</strong>: Since the collection has duplicates, thus each time when we add permutation, we need to consider if it already exists. </p>

<p>In the following code, the first code snippet use list.contains to check the duplicates. The second code snippet use set to avoid add dupilcates.</p>

<p>These two are accepted, the second one has better time complexity.</p>

<p><strong>Java code</strong>:</p>

<p><strong>M1</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> permuteUnique(<span class="pl-k">int</span>[] num) {
        <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>();
        <span class="pl-k">if</span> (num <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> num<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> res;
        }
        <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> first <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
        first<span class="pl-k">.</span>add(num[<span class="pl-c1">0</span>]);
        res<span class="pl-k">.</span>add(first);
        <span class="pl-k">Set&lt;<span class="pl-smi">String</span>&gt;</span> set <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashSet&lt;<span class="pl-smi">String</span>&gt;</span>();
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;</span> num<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
            <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> cur <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>();
            <span class="pl-k">for</span> (<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> l <span class="pl-k">:</span> res) {
                <span class="pl-k">for</span>(<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;=</span> l<span class="pl-k">.</span>size(); j<span class="pl-k">++</span>) {
                    <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> temp <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>(l);
                    temp<span class="pl-k">.</span>add(j, num[i]);
                    <span class="pl-k">if</span>(set<span class="pl-k">.</span>add(temp<span class="pl-k">.</span>toString())) {
                        cur<span class="pl-k">.</span>add(temp);
                    }
                }
            }
            res <span class="pl-k">=</span> cur;
        }
        <span class="pl-k">return</span> res;
    }
</pre></div>

<p><br></p>

<p><strong>M2: Use set, recursion</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> permuteUnique(<span class="pl-k">int</span>[] num) {
        <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> list <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>();
        <span class="pl-k">if</span> (num <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> num<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> list;
        }
        <span class="pl-k">return</span> permuteUnique(list, num, <span class="pl-c1">0</span>);
    }

    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> permuteUnique(<span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> list, <span class="pl-k">int</span>[] num, <span class="pl-k">int</span> i){
        <span class="pl-k">if</span> (i <span class="pl-k">==</span> num<span class="pl-k">.</span>length) {
            <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> arr <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
            list<span class="pl-k">.</span>add(arr);
            <span class="pl-k">return</span> list;
        }

        list <span class="pl-k">=</span> permuteUnique(list, num, i<span class="pl-k">+</span><span class="pl-c1">1</span>);
        <span class="pl-k">Set&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> current <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashSet&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>();
        <span class="pl-k">for</span> (<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> l <span class="pl-k">:</span> list) {
            <span class="pl-k">if</span>(l<span class="pl-k">.</span>size() <span class="pl-k">==</span> <span class="pl-c1">0</span>){
                <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> arr <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
                arr<span class="pl-k">.</span>add(num[i]);
                current<span class="pl-k">.</span>add(arr);
            } <span class="pl-k">else</span> {
                <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;=</span> l<span class="pl-k">.</span>size(); j<span class="pl-k">++</span>) {
                    <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> arr <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>(l);
                    arr<span class="pl-k">.</span>add(j, num[i]);
                    current<span class="pl-k">.</span>add(arr);
                }
            }
        }
        list <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>(current);
        <span class="pl-k">return</span> list;
    }
</pre></div>

<p><br></p>

<p><strong>M3</strong>: use swap, tle on leetcode</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> permutations(<span class="pl-smi">String</span> set) {
    <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">String</span>&gt;</span>();
    <span class="pl-k">if</span> (set <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span> res;
    }
    permutations(res, <span class="pl-c1">0</span>, set<span class="pl-k">.</span>toCharArray());
    <span class="pl-k">return</span> res;
  }

  <span class="pl-k">public</span> <span class="pl-k">void</span> permutations(<span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> res, <span class="pl-k">int</span> index, <span class="pl-k">char</span>[] arr) {
    <span class="pl-k">if</span> (index <span class="pl-k">==</span> arr<span class="pl-k">.</span>length) {
      <span class="pl-smi">String</span> s <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">String</span>(arr);
      res<span class="pl-k">.</span>add(s);
      <span class="pl-k">return</span>;
    }
    <span class="pl-k">Set&lt;<span class="pl-smi">Character</span>&gt;</span> myset <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashSet&lt;<span class="pl-smi">Character</span>&gt;</span>();
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> index; i <span class="pl-k">&lt;</span> arr<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
      <span class="pl-k">if</span> (<span class="pl-k">!</span>myset<span class="pl-k">.</span>contains(arr[i])) {
        myset<span class="pl-k">.</span>add(arr[i]);
        swap(arr, i, index);
        permutations(res, index <span class="pl-k">+</span> <span class="pl-c1">1</span>, arr);
        swap(arr, i, index);
      }
    }
  }

  <span class="pl-k">public</span> <span class="pl-k">void</span> swap(<span class="pl-k">char</span>[] arr, <span class="pl-k">int</span> i, <span class="pl-k">int</span> j) {
    <span class="pl-k">char</span> temp <span class="pl-k">=</span> arr[i];
    arr[i] <span class="pl-k">=</span> arr[j];
    arr[j] <span class="pl-k">=</span> temp;
  }</pre></div>

<p><br></p>

<p><strong>M4: use next permutation</strong>: tle on leetcode</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> permuteUnique(<span class="pl-k">int</span>[] num) {
        <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> list <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>();
        <span class="pl-k">if</span> (num <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> num<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> list;
        }
        <span class="pl-smi">Arrays</span><span class="pl-k">.</span>sort(num);
        list<span class="pl-k">.</span>add(<span class="pl-smi">IntStream</span><span class="pl-k">.</span>of(num)<span class="pl-k">.</span>boxed()<span class="pl-k">.</span>collect(<span class="pl-smi">Collectors</span><span class="pl-k">.</span>toList()));
        <span class="pl-k">while</span> (nextPermutation(num)) {
            list<span class="pl-k">.</span>add(<span class="pl-smi">IntStream</span><span class="pl-k">.</span>of(num)<span class="pl-k">.</span>boxed()<span class="pl-k">.</span>collect(<span class="pl-smi">Collectors</span><span class="pl-k">.</span>toList()));
        }
        <span class="pl-k">return</span> list;
    }

    <span class="pl-k">private</span> <span class="pl-k">boolean</span> nextPermutation(<span class="pl-k">int</span>[] num) {
        <span class="pl-k">if</span>(num <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> num<span class="pl-k">.</span>length <span class="pl-k">&lt;=</span> <span class="pl-c1">1</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        <span class="pl-k">int</span> i <span class="pl-k">=</span> num<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">2</span>;
        <span class="pl-k">while</span> (i <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> num[i] <span class="pl-k">&gt;=</span> num[i<span class="pl-k">+</span><span class="pl-c1">1</span>]) {
            i<span class="pl-k">--</span>;
        }
        <span class="pl-k">int</span> index1 <span class="pl-k">=</span> i;
        <span class="pl-k">if</span> (i <span class="pl-k">==</span> <span class="pl-k">-</span><span class="pl-c1">1</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        i <span class="pl-k">=</span> num<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>;
        <span class="pl-k">while</span> (i <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> num[i] <span class="pl-k">&lt;=</span> num[index1]) {
            i<span class="pl-k">--</span>;
        }
        swap(num, index1, i);
        reverse(num, index1 <span class="pl-k">+</span> <span class="pl-c1">1</span>);
        <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }

    <span class="pl-k">private</span> <span class="pl-k">void</span> reverse(<span class="pl-k">int</span>[] num, <span class="pl-k">int</span> i) {
        <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> i; j <span class="pl-k">&lt;</span> (num<span class="pl-k">.</span>length <span class="pl-k">-</span> i) <span class="pl-k">/</span> <span class="pl-c1">2</span> <span class="pl-k">+</span> i; j<span class="pl-k">++</span>) {
            swap(num, j, num<span class="pl-k">.</span>length <span class="pl-k">+</span> i <span class="pl-k">-</span> j <span class="pl-k">-</span> <span class="pl-c1">1</span>);
        }
    }

    <span class="pl-k">private</span> <span class="pl-k">void</span> swap(<span class="pl-k">int</span>[] num, <span class="pl-k">int</span> i, <span class="pl-k">int</span> j) {
        <span class="pl-k">int</span> temp <span class="pl-k">=</span> num[i];
        num[i] <span class="pl-k">=</span> num[j];
        num[j] <span class="pl-k">=</span> temp;
    }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-48-rotate-image" class="anchor" href="https://github.com/wishyouhappy/Algorithm#48-rotate-image" aria-hidden="true"><span class="octicon octicon-link"></span></a>48 Rotate Image</h3>

<blockquote>
<p>You are given an n x n 2D matrix representing an image.</p>

<p>Rotate the image by 90 degrees (clockwise).</p>

<p>Follow up:
Could you do this in-place?</p>
</blockquote>

<p><strong>Idea</strong>:The easiest way to solve this problem is draw a matrix and rotate it by 90 degrees. Then you'll find the following pattarn.</p>

<ul>
<li>  matrix[i][j] = matrix[n-j-1][i];</li>
<li>  matrix[n-j-1][i] = matrix[n-i-1][n-j-1]</li>
<li>  matrix[n-i-1][n-j-1] = matrix[j][n-i-1]; </li>
<li>  matrix[j][n-i-1] = matrix[i][j]</li>
</ul>

<p><strong>Attention</strong>: I made a mistake at the first time, matrix[i][j] should equal to matrix[n-j-1][i] other than matrix[n-j][i]. The other three should follow the same way.</p>

<p><strong>Java code</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">void</span> rotate(<span class="pl-k">int</span>[][] matrix) {
        <span class="pl-k">if</span>(matrix <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> matrix<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> matrix[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span>;
        <span class="pl-k">int</span> n <span class="pl-k">=</span> matrix<span class="pl-k">.</span>length;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> n<span class="pl-k">/</span><span class="pl-c1">2</span>; i<span class="pl-k">++</span>){
            <span class="pl-k">for</span>(<span class="pl-k">int</span> j <span class="pl-k">=</span> i; j <span class="pl-k">&lt;</span> n <span class="pl-k">-</span> i <span class="pl-k">-</span> <span class="pl-c1">1</span>; j<span class="pl-k">++</span>){
                <span class="pl-k">int</span> temp <span class="pl-k">=</span> matrix[i][j];
                matrix[i][j] <span class="pl-k">=</span> matrix[n<span class="pl-k">-</span>j<span class="pl-k">-</span><span class="pl-c1">1</span>][i];
                matrix[n<span class="pl-k">-</span>j<span class="pl-k">-</span><span class="pl-c1">1</span>][i] <span class="pl-k">=</span> matrix[n<span class="pl-k">-</span>i<span class="pl-k">-</span><span class="pl-c1">1</span>][n<span class="pl-k">-</span>j<span class="pl-k">-</span><span class="pl-c1">1</span>];
                matrix[n<span class="pl-k">-</span>i<span class="pl-k">-</span><span class="pl-c1">1</span>][n<span class="pl-k">-</span>j<span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">=</span> matrix[j][n<span class="pl-k">-</span>i<span class="pl-k">-</span><span class="pl-c1">1</span>];
                matrix[j][n<span class="pl-k">-</span>i<span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">=</span> temp;
            }
        }
    }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-49-anagrams" class="anchor" href="https://github.com/wishyouhappy/Algorithm#49-anagrams" aria-hidden="true"><span class="octicon octicon-link"></span></a>49 Anagrams</h3>

<blockquote>
<p>Given an array of strings, return all groups of strings that are anagrams.</p>

<p>Note: All inputs will be in lower-case.</p>
</blockquote>

<p><strong>Ideas</strong>: To solve this problem, we can divide it into two parts</p>

<ul>
<li><p>1) how to check if two strings are anagrams?</p>

<p>we can sort them and check if they are equal</p></li>
<li><p>2) for a certain string, how to decide if it has anagram in the strs?</p>

<p>Use hashmap.</p></li>
</ul>

<p><strong>Time complexity</strong>:</p>

<p>For the first solution use sort + hashmap, suppose string[] length is N, maximum string length is M, then the overall time complexity is O(N * MlgM)</p>

<p>For the second solution, the time complexity is O(N * M), but too many multiplications. </p>

<p><strong>Java code</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> anagrams(<span class="pl-k">String</span>[] strs) {
        <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">String</span>&gt;</span>();
        <span class="pl-k">if</span>(strs <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> strs<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> res;
        }
        <span class="pl-k">Map&lt;<span class="pl-smi">String</span>, <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span>&gt;</span> map <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashMap&lt;<span class="pl-smi">String</span>, <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span>&gt;</span>();
        <span class="pl-k">for</span> (<span class="pl-smi">String</span> s <span class="pl-k">:</span> strs){
            <span class="pl-k">char</span>[] arr <span class="pl-k">=</span> s<span class="pl-k">.</span>toCharArray();
            <span class="pl-smi">Arrays</span><span class="pl-k">.</span>sort(arr);
            <span class="pl-smi">String</span> sorted <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">String</span>(arr);
            <span class="pl-k">if</span> (map<span class="pl-k">.</span>containsKey(sorted)) {
                map<span class="pl-k">.</span>get(sorted)<span class="pl-k">.</span>add(s);
            } <span class="pl-k">else</span> {
                <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> list <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">String</span>&gt;</span>();
                list<span class="pl-k">.</span>add(s);
                map<span class="pl-k">.</span>put(sorted, list);
            }
        }
        <span class="pl-k">for</span> (<span class="pl-smi">Map</span><span class="pl-k">.</span><span class="pl-k">Entry&lt;<span class="pl-smi">String</span>, <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span>&gt;</span> e <span class="pl-k">:</span> map<span class="pl-k">.</span>entrySet()) {
            <span class="pl-k">if</span> (e<span class="pl-k">.</span>getValue()<span class="pl-k">.</span>size() <span class="pl-k">&gt;</span> <span class="pl-c1">1</span>) {
                res<span class="pl-k">.</span>addAll(e<span class="pl-k">.</span>getValue());
            }
        }
        <span class="pl-k">return</span> res;
    }
</pre></div>

<p>Here is another similar solution using hashmap, the difference is that it does not use Arrays.sort to sort the strings. It uses some primes numbers to calculate the hash value. This solution is from leetcode discussion. Even though it does not improve the time complexity too much, it's a pretty good idea. </p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> anagrams(<span class="pl-k">String</span>[] strs) {
        <span class="pl-k">int</span>[] <span class="pl-c1">PRIMES</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[]{<span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">5</span>, <span class="pl-c1">7</span>, <span class="pl-c1">11</span> ,<span class="pl-c1">13</span>, <span class="pl-c1">17</span>, <span class="pl-c1">19</span>, <span class="pl-c1">23</span>, <span class="pl-c1">29</span>, <span class="pl-c1">31</span>, <span class="pl-c1">37</span>, <span class="pl-c1">41</span>, <span class="pl-c1">43</span>, <span class="pl-c1">47</span>, <span class="pl-c1">53</span>, <span class="pl-c1">59</span>, <span class="pl-c1">61</span>, <span class="pl-c1">67</span>, <span class="pl-c1">71</span>, <span class="pl-c1">73</span>, <span class="pl-c1">79</span>, <span class="pl-c1">83</span>, <span class="pl-c1">89</span>, <span class="pl-c1">97</span>, <span class="pl-c1">101</span>, <span class="pl-c1">107</span>};
        <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> list <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">LinkedList&lt;&gt;</span>();
        <span class="pl-k">Map&lt;<span class="pl-smi">Integer</span>, <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span>&gt;</span> mapString <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashMap&lt;&gt;</span>();
        <span class="pl-k">int</span> result <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> strs<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
            <span class="pl-k">int</span> mapping <span class="pl-k">=</span> <span class="pl-c1">1</span>;
            <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>, max <span class="pl-k">=</span> strs[i]<span class="pl-k">.</span>length(); j <span class="pl-k">&lt;</span> max; j<span class="pl-k">++</span>) {
                mapping <span class="pl-k">*=</span> <span class="pl-c1">PRIMES</span>[strs[i]<span class="pl-k">.</span>charAt(j) <span class="pl-k">-</span> <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>];
            }
            <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> strings <span class="pl-k">=</span> mapString<span class="pl-k">.</span>get(mapping);
            <span class="pl-k">if</span> (strings <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
                strings <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">LinkedList&lt;&gt;</span>();
                mapString<span class="pl-k">.</span>put(mapping, strings);
            }
            strings<span class="pl-k">.</span>add(strs[i]);
        }
        <span class="pl-k">for</span> (<span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> mapList <span class="pl-k">:</span> mapString<span class="pl-k">.</span>values()) {
            <span class="pl-k">if</span> (mapList<span class="pl-k">.</span>size() <span class="pl-k">&gt;</span> <span class="pl-c1">1</span>) {
                list<span class="pl-k">.</span>addAll(mapList);
            }
        }
        <span class="pl-k">return</span> list;
    }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-50-pow" class="anchor" href="https://github.com/wishyouhappy/Algorithm#50-pow" aria-hidden="true"><span class="octicon octicon-link"></span></a>50 Pow</h3>

<blockquote>
<p>Implement pow(x, n).</p>
</blockquote>

<p><strong>Idea</strong>: Dichotomy and calculate recursively. </p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">double</span> myPow(<span class="pl-k">double</span> x, <span class="pl-k">int</span> n) {
        <span class="pl-k">if</span> (n <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">1</span>;
        }
        <span class="pl-k">double</span> result <span class="pl-k">=</span> myPow(x, n<span class="pl-k">/</span><span class="pl-c1">2</span>);
        <span class="pl-k">if</span> (n <span class="pl-k">%</span> <span class="pl-c1">2</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> result <span class="pl-k">*</span> result;
        } <span class="pl-k">else</span> <span class="pl-k">if</span> (n <span class="pl-k">%</span> <span class="pl-c1">2</span> <span class="pl-k">==</span> <span class="pl-c1">1</span>) {
             <span class="pl-k">return</span> result <span class="pl-k">*</span> result <span class="pl-k">*</span> x;
        } <span class="pl-k">else</span> {
            <span class="pl-k">return</span> result <span class="pl-k">*</span> result <span class="pl-k">/</span> x;
        }
    }</pre></div>

<p><br></p>

<p><br></p>

<h3><a id="user-content-51-n-queens" class="anchor" href="https://github.com/wishyouhappy/Algorithm#51-n-queens" aria-hidden="true"><span class="octicon octicon-link"></span></a>51 N Queens</h3>

<blockquote>
<p>The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.</p>

<p>Given an integer n, return all distinct solutions to the n-queens puzzle.</p>

<p>Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively.</p>
</blockquote>

<pre>For example,
There exist two distinct solutions to the 4-queens puzzle:

[
 [".Q..",  // Solution 1
  "...Q",
  "Q...",
  "..Q."],

 ["..Q.",  // Solution 2
  "Q...",
  "...Q",
  ".Q.."]
]

</pre>

<p><strong>Requirement</strong>: For n queen problem, we can not put queens in the same row or same column or diagonal.</p>

<p><strong>Idea</strong>: We can use the queen one by one, each one correspond to one row. To find all solutions, we need to try each column on a row. When we finish the last row, we find a solution. Use recursions inside the loops we can find all solutions.</p>

<p><strong>Java code</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-k">String</span>[]&gt;</span> solveNQueens(<span class="pl-k">int</span> n) {
        <span class="pl-k">List&lt;<span class="pl-k">String</span>[]&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-k">String</span>[]&gt;</span>();
        <span class="pl-k">if</span>(n <span class="pl-k">&lt;=</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> res;
        solve(<span class="pl-c1">0</span>,n,<span class="pl-k">new</span> <span class="pl-smi">int</span>[n],res);
        <span class="pl-k">return</span> res;
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> solve(<span class="pl-k">int</span> r, <span class="pl-k">int</span> n, <span class="pl-k">int</span>[] cols, <span class="pl-k">List&lt;<span class="pl-k">String</span>[]&gt;</span> list){
        <span class="pl-k">if</span>(r <span class="pl-k">==</span> n){
            <span class="pl-k">String</span>[] strs <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">String</span>[n];
            <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> n; i<span class="pl-k">++</span>){
                <span class="pl-smi">StringBuilder</span> s <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">StringBuilder</span>();
                <span class="pl-k">for</span>(<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;</span> n; j<span class="pl-k">++</span>){
                    <span class="pl-k">if</span>(j <span class="pl-k">==</span> cols[i]) s<span class="pl-k">.</span>append(<span class="pl-s"><span class="pl-pds">"</span>Q<span class="pl-pds">"</span></span>);
                    <span class="pl-k">else</span> s<span class="pl-k">.</span>append(<span class="pl-s"><span class="pl-pds">"</span>.<span class="pl-pds">"</span></span>);
                }
                strs[i] <span class="pl-k">=</span> s<span class="pl-k">.</span>toString();
            }
            list<span class="pl-k">.</span>add(strs);
            <span class="pl-k">return</span>;
        }
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> n; i<span class="pl-k">++</span>){
            <span class="pl-k">if</span>(isValid(r, i, cols)){
                cols[r] <span class="pl-k">=</span> i;
                solve(r<span class="pl-k">+</span><span class="pl-c1">1</span>, n, cols, list);
            }
        }  

    }

    <span class="pl-k">public</span> <span class="pl-k">boolean</span> isValid(<span class="pl-k">int</span> r, <span class="pl-k">int</span> c, <span class="pl-k">int</span>[] cols){
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> r; i<span class="pl-k">++</span>){
            <span class="pl-k">if</span>(c <span class="pl-k">==</span> cols[i] <span class="pl-k">||</span> r <span class="pl-k">-</span> i <span class="pl-k">==</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>abs(cols[i] <span class="pl-k">-</span> c)) <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }
</pre></div>

<p><br></p>

<p><br></p>

<h3><a id="user-content-52-n-queens-ii" class="anchor" href="https://github.com/wishyouhappy/Algorithm#52-n-queens-ii" aria-hidden="true"><span class="octicon octicon-link"></span></a>52 N Queens II</h3>

<blockquote>
<p>Follow up for N-Queens problem.</p>

<p>Now, instead outputting board configurations, return the total number of distinct solutions.</p>
</blockquote>

<p><strong>Idea</strong>: Same with n queen, difference is that we don't need to output the result, we just need to calculate the total number of solutions.</p>

<p><strong>Java code</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> totalNQueens(<span class="pl-k">int</span> n) {
        <span class="pl-k">if</span>(n <span class="pl-k">&lt;=</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span>[] res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[<span class="pl-c1">1</span>];
        solve(<span class="pl-c1">0</span>,n,<span class="pl-k">new</span> <span class="pl-smi">int</span>[n],res);
        <span class="pl-k">return</span> res[<span class="pl-c1">0</span>];
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> solve(<span class="pl-k">int</span> r, <span class="pl-k">int</span> n, <span class="pl-k">int</span>[] cols, <span class="pl-k">int</span>[] res){
        <span class="pl-k">if</span>(r <span class="pl-k">==</span> n){
          res[<span class="pl-c1">0</span>]<span class="pl-k">++</span>;
        }
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> n; i<span class="pl-k">++</span>){
            <span class="pl-k">if</span>(isValid(r, i, cols)){
                cols[r] <span class="pl-k">=</span> i;
                solve(r<span class="pl-k">+</span><span class="pl-c1">1</span>, n, cols, res);
            }
        }  

    }

    <span class="pl-k">public</span> <span class="pl-k">boolean</span> isValid(<span class="pl-k">int</span> r, <span class="pl-k">int</span> c, <span class="pl-k">int</span>[] cols){
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> r; i<span class="pl-k">++</span>){
            <span class="pl-k">if</span>(c <span class="pl-k">==</span> cols[i] <span class="pl-k">||</span> r <span class="pl-k">-</span> i <span class="pl-k">==</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>abs(cols[i] <span class="pl-k">-</span> c)) <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-53-maximum-subarray" class="anchor" href="https://github.com/wishyouhappy/Algorithm#53-maximum-subarray" aria-hidden="true"><span class="octicon octicon-link"></span></a>53 Maximum Subarray</h3>

<blockquote>
<p>Find the contiguous subarray within an array <strong>(containing at least one number)</strong> which has the largest sum.</p>
</blockquote>

<p>For example, given the array [−2,1,−3,4,−1,2,1,−5,4],
the contiguous subarray [4,−1,2,1] has the largest sum = 6.</p>

<p><strong>Idea</strong>:</p>

<ul>
<li>1) solution1: use dp. Store a local max and global max. Local max represents the max subarray which includes the element A[i]. Thus Local Max = max(local+A[i], A[i]). global = max(global, local).</li>
</ul>

<p><strong>Attention</strong>: Because the maxsubarray contains at least one number, thus the max sum might be negative when the array only contains one negative numbers or when all the numbers are negative.</p>

<div class="highlight highlight-java"><pre>     <span class="pl-k">public</span> <span class="pl-k">int</span> maxSubArray(<span class="pl-k">int</span>[] <span class="pl-smi">A</span>) {
         <span class="pl-k">if</span>(<span class="pl-smi">A</span> <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
         <span class="pl-k">int</span> local <span class="pl-k">=</span> <span class="pl-k">A</span>[<span class="pl-c1">0</span>];
         <span class="pl-k">int</span> global <span class="pl-k">=</span> <span class="pl-k">A</span>[<span class="pl-c1">0</span>];
         <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length; i<span class="pl-k">++</span>){
             local <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(<span class="pl-k">A</span>[i], local<span class="pl-k">+</span><span class="pl-k">A</span>[i]);
             global <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(local, global);
         }
         <span class="pl-k">return</span> global;
     }
</pre></div>

<p><br></p>

<ul>
<li>2) solution 2: One pass. When encounter a negative number, record the current max. when sum + A[i] &lt; 0 &amp;&amp; A[i] &gt; 0, change the local max to A[i]. </li>
</ul>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> maxSubArray1(<span class="pl-k">int</span>[] <span class="pl-smi">A</span>) {
        <span class="pl-k">if</span>(<span class="pl-smi">A</span> <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> max <span class="pl-k">=</span> <span class="pl-smi">Integer</span><span class="pl-c1"><span class="pl-k">.</span>MIN_VALUE</span>;
        <span class="pl-k">int</span> temp <span class="pl-k">=</span> <span class="pl-k">A</span>[<span class="pl-c1">0</span>];
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length; i<span class="pl-k">++</span>){
            <span class="pl-k">if</span>(temp <span class="pl-k">&lt;</span> <span class="pl-c1">0</span>){
                max <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(max,temp);
                temp <span class="pl-k">=</span> <span class="pl-k">A</span>[i];
            }<span class="pl-k">else</span>{
                <span class="pl-k">if</span>(<span class="pl-k">A</span>[i] <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>) temp <span class="pl-k">+=</span> <span class="pl-k">A</span>[i];
                <span class="pl-k">else</span> <span class="pl-k">if</span>(temp <span class="pl-k">+</span> <span class="pl-k">A</span>[i] <span class="pl-k">&lt;</span> <span class="pl-c1">0</span>){
                    max <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(max,temp);
                    temp <span class="pl-k">=</span> <span class="pl-k">A</span>[i];
                }<span class="pl-k">else</span>{
                    max <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(max,temp);
                    temp <span class="pl-k">+=</span> <span class="pl-k">A</span>[i];
                }
            }
        }
        max <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(max,temp);
        <span class="pl-k">return</span> max;
    }
</pre></div>

<p><br></p>

<p><strong>Related</strong>: maxinum submatrix sum:</p>

<p><strong>Idea</strong>: </p>

<p>For each row, we calculate the sum of the rows below the current row. Then apply the maximum subarray to the compressed rows.</p>

<p><strong>Time</strong> : O(n ^ 3)</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">int</span> largest(<span class="pl-k">int</span>[][] matrix) {
    <span class="pl-k">int</span> res <span class="pl-k">=</span> <span class="pl-smi">Integer</span><span class="pl-c1"><span class="pl-k">.</span>MIN_VALUE</span>;
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> matrix<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
      <span class="pl-k">int</span>[] compressedRow <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[matrix[<span class="pl-c1">0</span>].length];
      <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> i; j <span class="pl-k">&lt;</span> matrix<span class="pl-k">.</span>length; j<span class="pl-k">++</span>) {
        <span class="pl-k">for</span>(<span class="pl-k">int</span> k <span class="pl-k">=</span> <span class="pl-c1">0</span>; k <span class="pl-k">&lt;</span> compressedRow<span class="pl-k">.</span>length; k<span class="pl-k">++</span>) {
          compressedRow[k] <span class="pl-k">+=</span> matrix[j][k];
        }
        res <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(res, largestSum(compressedRow));
      }
    }
    <span class="pl-k">return</span> res;
  }

  <span class="pl-k">private</span> <span class="pl-k">int</span> largestSum(<span class="pl-k">int</span>[] array) {
    <span class="pl-k">int</span> local <span class="pl-k">=</span> array[<span class="pl-c1">0</span>];
    <span class="pl-k">int</span> res <span class="pl-k">=</span> array[<span class="pl-c1">0</span>];
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;</span> array<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
      local <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(array[i], local <span class="pl-k">+</span> array[i]);
      res <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(res, local);
    }
    <span class="pl-k">return</span> res;
  }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-54-spiral-matrix" class="anchor" href="https://github.com/wishyouhappy/Algorithm#54-spiral-matrix" aria-hidden="true"><span class="octicon octicon-link"></span></a>54 Spiral Matrix</h3>

<blockquote>
<p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</p>
</blockquote>

<pre>For example,
Given the following matrix:

[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]

</pre>

<p><strong>Idea</strong>:Don't figure out any good solution yet. Just add the element in spiral order one by one.</p>

<p><strong>Attention</strong>: The row is not necessarily equal to column, thus make sure to check if they are equal. Also, in the following method, I loop Math.min(row, col) / 2 times. what will happen if  Math.min(row, col) is odd? </p>

<p><strong>Java code</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> spiralOrder(<span class="pl-k">int</span>[][] matrix) {
        <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
        <span class="pl-k">if</span>(matrix <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> matrix<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> matrix[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) 
            <span class="pl-k">return</span> res;
        <span class="pl-k">int</span> row <span class="pl-k">=</span> matrix<span class="pl-k">.</span>length;
        <span class="pl-k">int</span> col <span class="pl-k">=</span> matrix[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length;
        <span class="pl-k">int</span> loops <span class="pl-k">=</span> (<span class="pl-smi">Math</span><span class="pl-k">.</span>min(row, col)) <span class="pl-k">/</span><span class="pl-c1">2</span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> loops; i<span class="pl-k">++</span>){
            <span class="pl-k">for</span>(<span class="pl-k">int</span> j <span class="pl-k">=</span> i; j <span class="pl-k">&lt;</span> col <span class="pl-k">-</span> i; j<span class="pl-k">++</span>){
                res<span class="pl-k">.</span>add(matrix[i][j]);
            }
            <span class="pl-k">for</span>(<span class="pl-k">int</span> j <span class="pl-k">=</span> i<span class="pl-k">+</span><span class="pl-c1">1</span>; j <span class="pl-k">&lt;</span> row <span class="pl-k">-</span>i; j<span class="pl-k">++</span>){
                res<span class="pl-k">.</span>add(matrix[j][col<span class="pl-k">-</span>i<span class="pl-k">-</span><span class="pl-c1">1</span>]);
            }
            <span class="pl-k">for</span>(<span class="pl-k">int</span> j <span class="pl-k">=</span> col<span class="pl-k">-</span>i<span class="pl-k">-</span><span class="pl-c1">2</span>; j <span class="pl-k">&gt;=</span> i; j<span class="pl-k">--</span>){
                res<span class="pl-k">.</span>add(matrix[row<span class="pl-k">-</span>i<span class="pl-k">-</span><span class="pl-c1">1</span>][j]);
            }
            <span class="pl-k">for</span>(<span class="pl-k">int</span> j <span class="pl-k">=</span> row <span class="pl-k">-</span> (i<span class="pl-k">+</span><span class="pl-c1">2</span>); j <span class="pl-k">&gt;=</span> i<span class="pl-k">+</span><span class="pl-c1">1</span>; j<span class="pl-k">--</span>){
                res<span class="pl-k">.</span>add(matrix[j][i]);
            }
        }
        <span class="pl-k">if</span>(row <span class="pl-k">&gt;=</span> col <span class="pl-k">&amp;&amp;</span> col <span class="pl-k">%</span> <span class="pl-c1">2</span> <span class="pl-k">==</span> <span class="pl-c1">1</span>){
            <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> col<span class="pl-k">/</span><span class="pl-c1">2</span>; i <span class="pl-k">&lt;</span> row <span class="pl-k">-</span> col<span class="pl-k">/</span><span class="pl-c1">2</span>; i<span class="pl-k">++</span>){
                res<span class="pl-k">.</span>add(matrix[i][col<span class="pl-k">/</span><span class="pl-c1">2</span>]);
            }
        }
        <span class="pl-k">if</span>(row <span class="pl-k">&lt;</span> col <span class="pl-k">&amp;&amp;</span> row <span class="pl-k">%</span> <span class="pl-c1">2</span> <span class="pl-k">==</span> <span class="pl-c1">1</span>){
            <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> row<span class="pl-k">/</span><span class="pl-c1">2</span>; i <span class="pl-k">&lt;</span> col <span class="pl-k">-</span> row<span class="pl-k">/</span><span class="pl-c1">2</span>; i<span class="pl-k">++</span>){
                res<span class="pl-k">.</span>add(matrix[row<span class="pl-k">/</span><span class="pl-c1">2</span>][i]);
            }
        }
         <span class="pl-k">return</span> res;
    }
</pre></div>

<p><br></p>

<p><strong>Another more straightforward way</strong>: M * N iterarive</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> spiral(<span class="pl-k">int</span>[][] matrix) {
    <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
    <span class="pl-k">if</span> (matrix <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> matrix<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> matrix[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
      <span class="pl-k">return</span> res;
    }
    <span class="pl-k">int</span> left <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">int</span> right <span class="pl-k">=</span> matrix[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>;
    <span class="pl-k">int</span> top <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">int</span> bottom <span class="pl-k">=</span> matrix<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>;
    <span class="pl-k">while</span> (left <span class="pl-k">&lt;</span> right <span class="pl-k">&amp;&amp;</span> top <span class="pl-k">&lt;</span> bottom) {
      <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> left; i <span class="pl-k">&lt;=</span> right; i<span class="pl-k">++</span>) {
        res<span class="pl-k">.</span>add(matrix[top][i]);
      }
      <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> top <span class="pl-k">+</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;=</span> bottom; i<span class="pl-k">++</span>) {
        res<span class="pl-k">.</span>add(matrix[i][right]);
      }
      <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> right <span class="pl-k">-</span> <span class="pl-c1">1</span>; i <span class="pl-k">&gt;=</span> left; i<span class="pl-k">--</span>) {
        res<span class="pl-k">.</span>add(matrix[bottom][i]);
      }
      <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> bottom <span class="pl-k">-</span> <span class="pl-c1">1</span>; i <span class="pl-k">&gt;=</span> top <span class="pl-k">+</span> <span class="pl-c1">1</span>; i<span class="pl-k">--</span>) {
        res<span class="pl-k">.</span>add(matrix[i][left]);
      }
      left<span class="pl-k">++</span>;
      right<span class="pl-k">--</span>;
      top<span class="pl-k">++</span>;
      bottom<span class="pl-k">--</span>;
    }
    <span class="pl-k">if</span> (left <span class="pl-k">==</span> right <span class="pl-k">&amp;&amp;</span> top <span class="pl-k">&lt;=</span> bottom) {
      <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> top; i <span class="pl-k">&lt;=</span> bottom; i<span class="pl-k">++</span>) {
        res<span class="pl-k">.</span>add(matrix[i][left]);
      }
    } <span class="pl-k">else</span> <span class="pl-k">if</span> (top <span class="pl-k">==</span> bottom <span class="pl-k">&amp;&amp;</span> left <span class="pl-k">&lt;=</span> right) {
      <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> left; i <span class="pl-k">&lt;=</span> right; i<span class="pl-k">++</span>) {
        res<span class="pl-k">.</span>add(matrix[top][i]);
      }
    }
    <span class="pl-k">return</span> res;
  }</pre></div>

<p><br></p>

<p><strong>Recursive solution</strong>: handle N* N </p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">int</span>[] spiral(<span class="pl-k">int</span>[][] matrix) {
    <span class="pl-k">int</span>[] res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[matrix<span class="pl-k">.</span>length <span class="pl-k">*</span> matrix<span class="pl-k">.</span>length];
    spiral(res, matrix, <span class="pl-c1">0</span>, matrix<span class="pl-k">.</span>length, <span class="pl-c1">0</span>);
    <span class="pl-k">return</span> res;
  }

  <span class="pl-k">public</span> <span class="pl-k">void</span> spiral(<span class="pl-k">int</span>[] res, <span class="pl-k">int</span>[][] matrix, <span class="pl-k">int</span> offset, <span class="pl-k">int</span> size, <span class="pl-k">int</span> count) {
    <span class="pl-k">if</span> (size <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
      <span class="pl-k">return</span>;
    }
    <span class="pl-k">if</span> (size <span class="pl-k">&lt;=</span> <span class="pl-c1">1</span>) {
      res[count<span class="pl-k">++</span>] <span class="pl-k">=</span> matrix[offset][offset];
      <span class="pl-k">return</span>;
    }
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> size <span class="pl-k">-</span> <span class="pl-c1">1</span>; i<span class="pl-k">++</span>) {
      res[count<span class="pl-k">++</span>] <span class="pl-k">=</span> matrix[offset][i <span class="pl-k">+</span> offset];
    }
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> size <span class="pl-k">-</span> <span class="pl-c1">1</span>; i<span class="pl-k">++</span>) {
      res[count<span class="pl-k">++</span>] <span class="pl-k">=</span> matrix[offset <span class="pl-k">+</span> i][offset <span class="pl-k">+</span> size <span class="pl-k">-</span> <span class="pl-c1">1</span>];
    }
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> size <span class="pl-k">-</span> <span class="pl-c1">1</span>; i <span class="pl-k">&gt;=</span> <span class="pl-c1">1</span>; i<span class="pl-k">--</span>) {
      res[count<span class="pl-k">++</span>] <span class="pl-k">=</span> matrix[offset <span class="pl-k">+</span> size <span class="pl-k">-</span> <span class="pl-c1">1</span>][offset <span class="pl-k">+</span> i];
    }
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> size <span class="pl-k">-</span> <span class="pl-c1">1</span>; i <span class="pl-k">&gt;=</span> <span class="pl-c1">1</span>; i<span class="pl-k">--</span>) {
      res[count<span class="pl-k">++</span>] <span class="pl-k">=</span> matrix[offset <span class="pl-k">+</span> i][offset];
    }
    spiral(res, matrix, offset <span class="pl-k">+</span> <span class="pl-c1">1</span>, size <span class="pl-k">-</span> <span class="pl-c1">2</span>, count);
  }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-55-jump-game" class="anchor" href="https://github.com/wishyouhappy/Algorithm#55-jump-game" aria-hidden="true"><span class="octicon octicon-link"></span></a>55 Jump Game</h3>

<blockquote>
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>

<p>Each element in the array represents your maximum jump length at that position.</p>

<p>Determine if you are able to reach the last index.</p>
</blockquote>

<pre>For example:
A = [2,3,1,1,4], return true.

A = [3,2,1,0,4], return false.
</pre>

<p><strong>Idea</strong>: We need to figure out the max-position we can reach. If max &gt;= A.length-1, then we can reach to the end. Note that we need to check if at certain step if index i &gt; max, then we can not reach to the end. Because in some cases the A[i] might be 0, thus we might not able to go to the next step.</p>

<p><strong>Java code</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">boolean</span> canJump(<span class="pl-k">int</span>[] <span class="pl-smi">A</span>) {
        <span class="pl-k">if</span>(<span class="pl-smi">A</span> <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length <span class="pl-k">&lt;=</span> <span class="pl-c1">1</span>) <span class="pl-k">return</span> <span class="pl-c1">true</span>;
        <span class="pl-k">int</span> max <span class="pl-k">=</span> <span class="pl-k">A</span>[<span class="pl-c1">0</span>];
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length <span class="pl-k">&amp;&amp;</span> i <span class="pl-k">&lt;=</span> max; i<span class="pl-k">++</span>){
            max <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(max, i<span class="pl-k">+</span><span class="pl-k">A</span>[i]);
            <span class="pl-k">if</span>(max <span class="pl-k">&gt;=</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length<span class="pl-k">-</span><span class="pl-c1">1</span>) <span class="pl-k">return</span> <span class="pl-c1">true</span>;
        }
        <span class="pl-k">return</span> max <span class="pl-k">&gt;=</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length<span class="pl-k">-</span><span class="pl-c1">1</span>;
    }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-56-merge-intervals" class="anchor" href="https://github.com/wishyouhappy/Algorithm#56-merge-intervals" aria-hidden="true"><span class="octicon octicon-link"></span></a>56 Merge Intervals</h3>

<blockquote>
<p>Given a collection of intervals, merge all overlapping intervals.</p>
</blockquote>

<pre>For example,
Given [1,3],[2,6],[8,10],[15,18],
return [1,6],[8,10],[15,18].
</pre>

<p><strong>Idea</strong>: First sort then merge.</p>

<ul>
<li>1) For sort, we can use Collections.sort(list, comparator). And when interval1.start == interval2.start, we compare interval1.end and interval2.end.
Otherwise, we compare interval1.start and interval2.start</li>
<li>2) For merge, if current.start &gt; last.end, just add interval.
Otherwise, we need to compare the end of two intervals. If current.end &gt; last.end, we need to update last.end. </li>
</ul>

<p><strong>Java code</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-smi">Interval</span>&gt;</span> merge(<span class="pl-k">List&lt;<span class="pl-smi">Interval</span>&gt;</span> intervals) {
        <span class="pl-k">if</span>(intervals <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> intervals<span class="pl-k">.</span>size() <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> intervals;
        <span class="pl-k">List&lt;<span class="pl-smi">Interval</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Interval</span>&gt;</span>();
        <span class="pl-k">Comparator&lt;<span class="pl-smi">Interval</span>&gt;</span> comp <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">Comparator&lt;<span class="pl-smi">Interval</span>&gt;</span>(){
          <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">compare</span>(<span class="pl-smi">Interval</span> <span class="pl-v">arg1</span>, <span class="pl-smi">Interval</span> <span class="pl-v">arg2</span>){
              <span class="pl-k">if</span>(arg1<span class="pl-k">.</span>start <span class="pl-k">==</span> arg2<span class="pl-k">.</span>start) <span class="pl-k">return</span> arg1<span class="pl-k">.</span>end <span class="pl-k">-</span> arg2<span class="pl-k">.</span>end;
              <span class="pl-k">else</span> <span class="pl-k">return</span> arg1<span class="pl-k">.</span>start <span class="pl-k">-</span> arg2<span class="pl-k">.</span>start;
          }
        };
        <span class="pl-smi">Collections</span><span class="pl-k">.</span>sort(intervals, comp);
        res<span class="pl-k">.</span>add(intervals<span class="pl-k">.</span>get(<span class="pl-c1">0</span>));
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;</span> intervals<span class="pl-k">.</span>size(); i<span class="pl-k">++</span>){
            <span class="pl-smi">Interval</span> cur <span class="pl-k">=</span> intervals<span class="pl-k">.</span>get(i);
            <span class="pl-k">if</span>(cur<span class="pl-k">.</span>start <span class="pl-k">&gt;</span> res<span class="pl-k">.</span>get(res<span class="pl-k">.</span>size() <span class="pl-k">-</span><span class="pl-c1">1</span>)<span class="pl-k">.</span>end) 
                res<span class="pl-k">.</span>add(cur);
            <span class="pl-k">else</span> {
                <span class="pl-k">if</span>(cur<span class="pl-k">.</span>end <span class="pl-k">&gt;</span> res<span class="pl-k">.</span>get(res<span class="pl-k">.</span>size() <span class="pl-k">-</span><span class="pl-c1">1</span>)<span class="pl-k">.</span>end)
                    res<span class="pl-k">.</span>get(res<span class="pl-k">.</span>size() <span class="pl-k">-</span><span class="pl-c1">1</span>)<span class="pl-k">.</span>end <span class="pl-k">=</span> cur<span class="pl-k">.</span>end;
            }
        }
        <span class="pl-k">return</span> res;
    }
</pre></div>

<p><br></p>

<p><br></p>

<h3><a id="user-content-57-insert-interval" class="anchor" href="https://github.com/wishyouhappy/Algorithm#57-insert-interval" aria-hidden="true"><span class="octicon octicon-link"></span></a>57 Insert Interval</h3>

<blockquote>
<p>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).</p>

<p>You may assume that the intervals were initially sorted according to their start times.</p>

<p>Example 1:</p>

<p>Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].</p>

<p>Example 2:</p>

<p>Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].</p>

<p>This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].</p>
</blockquote>

<p><strong>Idea</strong>:</p>

<ul>
<li><p>solution 1 : There are three possible relations between two intervals. Consider interval i1 and interval i2,</p>

<ul>
<li><p>case 1: i1.end &lt; i2.start</p></li>
<li><p>case 2:  i1.start &gt; i2.end</p></li>
<li><p>case 3: i1 includes i2, or i2 includes i1, or i1.start &lt; i2.start and i1.end &lt; i2.end, or i1.start &gt; i2.start and i1.end &gt; i2.end</p></li>
</ul>

<p>In case 1: we just need to add i1 to result,
In case 2: we add i2 to result, and change newInterval to i1,
In case 3: We might need to update the start or end of the newInterval.</p></li>
<li><p>solution 2: First find the place to insert the newInterval, then do merge intervals for the remain intervals. How to find the place to insert the newInterval? If we find a interval that its end is &gt;= newInterval.start, then it is the place to insert the newInterval. After insert, we merge the intervals. </p></li>
</ul>

<p><strong>java code</strong>:</p>

<p><em>Solution 1</em>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-smi">Interval</span>&gt;</span> insert(<span class="pl-k">List&lt;<span class="pl-smi">Interval</span>&gt;</span> intervals, <span class="pl-smi">Interval</span> newInterval) {
        <span class="pl-k">List&lt;<span class="pl-smi">Interval</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Interval</span>&gt;</span>();
        <span class="pl-k">for</span>(<span class="pl-smi">Interval</span> interval <span class="pl-k">:</span> intervals){
            <span class="pl-k">if</span>(interval<span class="pl-k">.</span>end <span class="pl-k">&lt;</span> newInterval<span class="pl-k">.</span>start){
                res<span class="pl-k">.</span>add(interval);
            }<span class="pl-k">else</span> <span class="pl-k">if</span>(interval<span class="pl-k">.</span>start <span class="pl-k">&gt;</span> newInterval<span class="pl-k">.</span>end){
                res<span class="pl-k">.</span>add(newInterval);
                newInterval <span class="pl-k">=</span> interval;
            }<span class="pl-k">else</span> <span class="pl-k">if</span>(newInterval<span class="pl-k">.</span>end <span class="pl-k">&gt;=</span> interval<span class="pl-k">.</span>start <span class="pl-k">||</span> newInterval<span class="pl-k">.</span>start <span class="pl-k">&lt;=</span> interval<span class="pl-k">.</span>end ){
                newInterval<span class="pl-k">.</span>start <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>min(interval<span class="pl-k">.</span>start, newInterval<span class="pl-k">.</span>start);
                newInterval<span class="pl-k">.</span>end <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(interval<span class="pl-k">.</span>end, newInterval<span class="pl-k">.</span>end);
            }
        }
        res<span class="pl-k">.</span>add(newInterval);
        <span class="pl-k">return</span> res;
    }

</pre></div>

<p><em>Solution 2</em>: </p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-smi">Interval</span>&gt;</span> insert(<span class="pl-k">List&lt;<span class="pl-smi">Interval</span>&gt;</span> intervals, <span class="pl-smi">Interval</span> newInterval) {
        <span class="pl-k">List&lt;<span class="pl-smi">Interval</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Interval</span>&gt;</span>();
        <span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">for</span>(; i <span class="pl-k">&lt;</span> intervals<span class="pl-k">.</span>size(); i<span class="pl-k">++</span>){
            <span class="pl-smi">Interval</span> cur <span class="pl-k">=</span> intervals<span class="pl-k">.</span>get(i);
            <span class="pl-k">if</span>(cur<span class="pl-k">.</span>end <span class="pl-k">&gt;=</span> newInterval<span class="pl-k">.</span>start){
                <span class="pl-k">break</span>;
            }
            res<span class="pl-k">.</span>add(cur);
        }

        res<span class="pl-k">.</span>add(newInterval);

        <span class="pl-k">for</span>(; i <span class="pl-k">&lt;</span> intervals<span class="pl-k">.</span>size(); i<span class="pl-k">++</span>){
            <span class="pl-smi">Interval</span> cur <span class="pl-k">=</span> intervals<span class="pl-k">.</span>get(i);
            <span class="pl-smi">Interval</span> last <span class="pl-k">=</span> res<span class="pl-k">.</span>get(res<span class="pl-k">.</span>size()<span class="pl-k">-</span><span class="pl-c1">1</span>);
            <span class="pl-k">if</span>(cur<span class="pl-k">.</span>start <span class="pl-k">&gt;</span> last<span class="pl-k">.</span>end){
                res<span class="pl-k">.</span>add(cur);
            }<span class="pl-k">else</span>{
                last<span class="pl-k">.</span>start <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>min(last<span class="pl-k">.</span>start, cur<span class="pl-k">.</span>start);
                last<span class="pl-k">.</span>end <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(last<span class="pl-k">.</span>end, cur<span class="pl-k">.</span>end);
            }
        }
        <span class="pl-k">return</span> res;
    }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-58-length-of-last-word" class="anchor" href="https://github.com/wishyouhappy/Algorithm#58-length-of-last-word" aria-hidden="true"><span class="octicon octicon-link"></span></a>58 Length of Last Word</h3>

<blockquote>
<p>Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string.</p>

<p>If the last word does not exist, return 0.</p>

<p>Note: A word is defined as a character sequence consists of non-space characters only.</p>

<p>For example, </p>

<p>Given s = "Hello World",</p>

<p>return 5.</p>
</blockquote>

<p><strong>Idea</strong>:</p>

<ul>
<li><p>solution1 : split the string by spaces, then return the length of the last word. Be careful, before you split, you should first trim the string to remove the front and back spaces in the string. Otherwise, you might get the wrong answer.</p></li>
<li><p>solution2 : trim the spaces, then find from the end of the string, until we find the first space, then we can return the length.</p></li>
</ul>

<p><strong>Java code</strong>:</p>

<p><em>Method 1</em>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> lengthOfLastWord(<span class="pl-smi">String</span> s) {
        <span class="pl-k">if</span>(s <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> s<span class="pl-k">.</span>length() <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        s <span class="pl-k">=</span> s<span class="pl-k">.</span>trim();
        <span class="pl-k">String</span>[] words <span class="pl-k">=</span> s<span class="pl-k">.</span>split(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\\</span>s+<span class="pl-pds">"</span></span>);
        <span class="pl-k">return</span> words[words<span class="pl-k">.</span>length <span class="pl-k">-</span><span class="pl-c1">1</span>]<span class="pl-k">.</span>length();
    }

</pre></div>

<p><em>Method 2</em>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> lengthOfLastWord1(<span class="pl-smi">String</span> s) {
        <span class="pl-k">if</span>(s <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> s<span class="pl-k">.</span>length() <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        s <span class="pl-k">=</span> s<span class="pl-k">.</span>trim();
        <span class="pl-k">int</span> len <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> s<span class="pl-k">.</span>length()<span class="pl-k">-</span><span class="pl-c1">1</span>; i<span class="pl-k">&gt;=</span><span class="pl-c1">0</span>; i<span class="pl-k">--</span>){
            <span class="pl-k">if</span>(s<span class="pl-k">.</span>charAt(i) <span class="pl-k">!=</span> <span class="pl-s"><span class="pl-pds">'</span> <span class="pl-pds">'</span></span>){
                len<span class="pl-k">++</span>;
            }<span class="pl-k">else</span> <span class="pl-k">break</span>;
        }
        <span class="pl-k">return</span> len;
    }

</pre></div>

<p><br></p>

<p><strong>Related</strong>: reverse words in a sentence</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-smi">String</span> reverseWords(<span class="pl-smi">String</span> input) {
    <span class="pl-k">if</span> (input <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> input<span class="pl-k">.</span>length() <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
      <span class="pl-k">return</span> input;
    }
    input <span class="pl-k">=</span> input<span class="pl-k">.</span>trim();
    <span class="pl-k">String</span>[] arr <span class="pl-k">=</span> input<span class="pl-k">.</span>split(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\\</span>s+<span class="pl-pds">"</span></span>);
    <span class="pl-smi">StringBuilder</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">StringBuilder</span>();
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> arr<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>; i <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>; i<span class="pl-k">--</span>) {
      res<span class="pl-k">.</span>append(arr[i]);
      res<span class="pl-k">.</span>append(<span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span>);
    }
    <span class="pl-k">return</span> res<span class="pl-k">.</span>toString()<span class="pl-k">.</span>trim();
  }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-59-spiral-matrix-ii" class="anchor" href="https://github.com/wishyouhappy/Algorithm#59-spiral-matrix-ii" aria-hidden="true"><span class="octicon octicon-link"></span></a>59 Spiral Matrix II</h3>

<blockquote>
<p>Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.</p>
</blockquote>

<pre>For example,
Given n = 3,

You should return the following matrix:
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]
</pre>

<p><strong>Idea</strong>: The idea is similar with spiral matrix. Actually, it's easier then the spiral matrix. Because now we can make sure that the matrix is a square matrix, thus we don't need to consider some corner cases like we did in spiral matrix. </p>

<p><strong>Java code</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span>[][] generateMatrix(<span class="pl-k">int</span> n) {
        <span class="pl-k">int</span>[][] matrix <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[n][n];
        <span class="pl-k">int</span> num <span class="pl-k">=</span> <span class="pl-c1">1</span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> n<span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">+</span><span class="pl-c1">1</span>; i<span class="pl-k">++</span>){
            <span class="pl-k">for</span>(<span class="pl-k">int</span> j <span class="pl-k">=</span> i; j <span class="pl-k">&lt;</span> n <span class="pl-k">-</span> i; j<span class="pl-k">++</span>){
               matrix[i][j] <span class="pl-k">=</span> num<span class="pl-k">++</span> ;
            }
            <span class="pl-k">for</span>(<span class="pl-k">int</span> j <span class="pl-k">=</span> i<span class="pl-k">+</span><span class="pl-c1">1</span>; j <span class="pl-k">&lt;</span> n <span class="pl-k">-</span>i; j<span class="pl-k">++</span>){
               matrix[j][n<span class="pl-k">-</span>i<span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">=</span> num<span class="pl-k">++</span>;
            }
            <span class="pl-k">for</span>(<span class="pl-k">int</span> j <span class="pl-k">=</span> n<span class="pl-k">-</span>i<span class="pl-k">-</span><span class="pl-c1">2</span>; j <span class="pl-k">&gt;=</span> i; j<span class="pl-k">--</span>){
               matrix[n<span class="pl-k">-</span>i<span class="pl-k">-</span><span class="pl-c1">1</span>][j] <span class="pl-k">=</span> num<span class="pl-k">++</span>;
            }
            <span class="pl-k">for</span>(<span class="pl-k">int</span> j <span class="pl-k">=</span> n <span class="pl-k">-</span> (i<span class="pl-k">+</span><span class="pl-c1">2</span>); j <span class="pl-k">&gt;=</span> i<span class="pl-k">+</span><span class="pl-c1">1</span>; j<span class="pl-k">--</span>){
               matrix[j][i] <span class="pl-k">=</span> num<span class="pl-k">++</span>;
            }
       }
       <span class="pl-k">return</span> matrix;
    }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-60-permutation-sequence" class="anchor" href="https://github.com/wishyouhappy/Algorithm#60-permutation-sequence" aria-hidden="true"><span class="octicon octicon-link"></span></a>60 Permutation Sequence</h3>

<blockquote>
<p>The set [1,2,3,…,n] contains a total of n! unique permutations.</p>

<p>By listing and labeling all of the permutations in order,
We get the following sequence (ie, for n = 3):</p>
</blockquote>

<pre>"123"
"132"
"213"
"231"
"312"
"321"

</pre>

<p>Given n and k, return the kth permutation sequence.</p>

<p>Note: Given n will be between 1 and 9 inclusive.</p>

<p><strong>Idea</strong>: for each begin character, it has (n-1)! permutations, k/(n-1)! we know the begin character</p>

<p><strong>Attention</strong>: How to decide add which num to the permutation? We use k/(n-1)!. There are boundary between permutation (n-1)! when add num to permutation. For example, n = 3, k = 4, k /(2!) = 2, should we add 2 or 3 to the permutation? 
Thus k-- can simplify the index.  </p>

<p><strong>Java code</strong>:</p>

<div class="highlight highlight-java"><pre>      <span class="pl-k">public</span> <span class="pl-smi">String</span> getPermutation(<span class="pl-k">int</span> n, <span class="pl-k">int</span> k) {
            <span class="pl-k">if</span>(n <span class="pl-k">&lt;=</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>;

            <span class="pl-c">/* create factorial,nums for permutation and ressult stringbuilder*/</span>
            <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> nums <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
            <span class="pl-k">int</span> factorial <span class="pl-k">=</span> <span class="pl-c1">1</span>;
            <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;=</span> n; i<span class="pl-k">++</span>){
                nums<span class="pl-k">.</span>add(i);
                factorial <span class="pl-k">*=</span> i;
            }
            factorial <span class="pl-k">/=</span> n;
            <span class="pl-smi">StringBuilder</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">StringBuilder</span>();

            <span class="pl-c">/* to simplify the boundary, we can k--. Consider n = 4, k = 18, 18 / 6 = 3, then we need to add nums[i-1]*/</span> 
            k<span class="pl-k">--</span>;

            <span class="pl-c">/*create permutation one digit per time*/</span>
            <span class="pl-k">while</span>(n <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>){
                <span class="pl-k">int</span> index <span class="pl-k">=</span> k <span class="pl-k">/</span> factorial;
                res<span class="pl-k">.</span>append(nums<span class="pl-k">.</span>get(index));
                nums<span class="pl-k">.</span>remove(index);
                k <span class="pl-k">%=</span> factorial;
                <span class="pl-k">if</span>(n <span class="pl-k">&gt;</span> <span class="pl-c1">1</span>) {
                    factorial <span class="pl-k">=</span> factorial <span class="pl-k">/</span> (n<span class="pl-k">-</span><span class="pl-c1">1</span>);
                }
                n<span class="pl-k">--</span>;
            }
            <span class="pl-k">return</span> res<span class="pl-k">.</span>toString();
        }

</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-61-rotate-list" class="anchor" href="https://github.com/wishyouhappy/Algorithm#61-rotate-list" aria-hidden="true"><span class="octicon octicon-link"></span></a>61 Rotate List</h3>

<blockquote>
<p>Given a list, rotate the list to the right by k places, where k is non-negative.</p>
</blockquote>

<pre>For example:
Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,
return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL.
</pre>

<p><strong>Idea</strong>: First calculate the length of list and record the tail, then move len - n steps. Connect tail and head, disconnect the (len-n)th and (len-n+1)th node.</p>

<p><strong>Attention</strong>: </p>

<ul>
<li>1) we need to mode n = n%len</li>
<li>2) Take care of null pointer</li>
</ul>

<p>code:</p>

<div class="highlight highlight-java"><pre>      <span class="pl-k">public</span> <span class="pl-smi">ListNode</span> rotateRight(<span class="pl-smi">ListNode</span> head, <span class="pl-k">int</span> n) {
        <span class="pl-k">if</span>(n <span class="pl-k">&lt;</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> head <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">return</span> head;
        <span class="pl-smi">ListNode</span> temp <span class="pl-k">=</span> head;
        <span class="pl-k">int</span> len <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-smi">ListNode</span> tail <span class="pl-k">=</span> <span class="pl-c1">null</span>;
        <span class="pl-k">while</span>(temp <span class="pl-k">!=</span> <span class="pl-c1">null</span>){
            len<span class="pl-k">++</span>;
            tail <span class="pl-k">=</span> temp;
            temp <span class="pl-k">=</span> temp<span class="pl-k">.</span>next;
        }
        n <span class="pl-k">=</span> n <span class="pl-k">%</span> len;
        len <span class="pl-k">=</span> len <span class="pl-k">-</span> n;
        <span class="pl-k">if</span>(n <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> len <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> head;
        temp <span class="pl-k">=</span> head;
        <span class="pl-smi">ListNode</span> pre <span class="pl-k">=</span> <span class="pl-c1">null</span>;
        <span class="pl-k">while</span>(len <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>){
            pre <span class="pl-k">=</span> temp;
            temp <span class="pl-k">=</span> temp<span class="pl-k">.</span>next;
            len<span class="pl-k">--</span>;
        }
        pre<span class="pl-k">.</span>next <span class="pl-k">=</span> <span class="pl-c1">null</span>;
        tail<span class="pl-k">.</span>next <span class="pl-k">=</span> head;
        <span class="pl-k">return</span> temp;
    }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-62-unique-paths" class="anchor" href="https://github.com/wishyouhappy/Algorithm#62-unique-paths" aria-hidden="true"><span class="octicon octicon-link"></span></a>62 Unique Paths</h3>

<blockquote>
<p>A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).</p>

<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).</p>

<p>How many possible unique paths are there?</p>
</blockquote>

<p><strong>Idea</strong>: There are several ways to solve this problem. Let's discuss four methods. </p>

<p><strong>Solution 1</strong></p>

<p>This problem is much similar to fibonacci number or the climb steps. We can easily solve this problem in recursion. But the time complexity is bad. The code is below(would be time exceeded on leetcode):</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> uniquePaths1(<span class="pl-k">int</span> m, <span class="pl-k">int</span> n) {
        <span class="pl-k">if</span> (n <span class="pl-k">&lt;=</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> m <span class="pl-k">&lt;=</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        }
        <span class="pl-k">return</span> helper(m<span class="pl-k">-</span><span class="pl-c1">1</span>, n<span class="pl-k">-</span><span class="pl-c1">1</span>);
    }

    <span class="pl-k">public</span> <span class="pl-k">int</span> helper(<span class="pl-k">int</span> m, <span class="pl-k">int</span> n){
        <span class="pl-k">if</span> (m <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> n <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">1</span>;
        } <span class="pl-k">else</span> <span class="pl-k">if</span> ( m <span class="pl-k">&lt;</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> n <span class="pl-k">&lt;</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        }
        <span class="pl-k">return</span> helper(m<span class="pl-k">-</span><span class="pl-c1">1</span>, n)<span class="pl-k">+</span>helper(m, n<span class="pl-k">-</span><span class="pl-c1">1</span>);
    }

</pre></div>

<p><br></p>

<p><strong>Solution 2</strong></p>

<p>Simply to the climb stairs problem, we can solve this problem use dynamic programming. Use dynamic programming. dp[m][n] = dp[m-1][n-1]. </p>

<p>In dp, the initial value is really important. In this problem, how do we initialize the dp array? Generally, the initianization would be dp[0][0] or dp[0][i] or dp[i][0], or other. In this problem, we need to initialize dp[0][i] dp[i][0] to 1, because they all have single path. The code is below:</p>

<p><em>Dp, 2 dimensional array</em></p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> uniquePaths(<span class="pl-k">int</span> m, <span class="pl-k">int</span> n) {
        <span class="pl-k">if</span> (m <span class="pl-k">&lt;</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> n <span class="pl-k">&lt;</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> (m <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> n <span class="pl-k">==</span> <span class="pl-c1">0</span>)) {
            <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        }

        <span class="pl-k">int</span>[][] dp <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[m][n];
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> m; i<span class="pl-k">++</span>) {
            dp[i][<span class="pl-c1">0</span>] <span class="pl-k">=</span> <span class="pl-c1">1</span>;
        }
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> n; i<span class="pl-k">++</span>) {
            dp[<span class="pl-c1">0</span>][i] <span class="pl-k">=</span> <span class="pl-c1">1</span>;
        }

        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;</span> m; i<span class="pl-k">++</span>) {
            <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">1</span>; j <span class="pl-k">&lt;</span> n; j<span class="pl-k">++</span>) {
                dp[i][j] <span class="pl-k">=</span> dp[i<span class="pl-k">-</span><span class="pl-c1">1</span>][j] <span class="pl-k">+</span> dp[i][j<span class="pl-k">-</span><span class="pl-c1">1</span>];
            }
        }

        <span class="pl-k">return</span> dp[m<span class="pl-k">-</span><span class="pl-c1">1</span>][n<span class="pl-k">-</span><span class="pl-c1">1</span>];
    }</pre></div>

<p><br></p>

<p><strong>Solution 3</strong></p>

<p>In the above dp code, the formula is  dp[i][j] = dp[i-1][j] + dp[i][j-1]. We can easily find that dp[i][j] is only related to the previous line. Thus we can use an one dimensional array to solve this problem.</p>

<div class="highlight highlight-java"><pre> <span class="pl-k">public</span> <span class="pl-k">int</span> uniquePaths(<span class="pl-k">int</span> m, <span class="pl-k">int</span> n) {
        <span class="pl-k">if</span> (m <span class="pl-k">&lt;</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> n <span class="pl-k">&lt;</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> (m <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> n <span class="pl-k">==</span> <span class="pl-c1">0</span>)) {
            <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        }

        <span class="pl-k">int</span>[] dp <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[n];
        dp[<span class="pl-c1">0</span>] <span class="pl-k">=</span> <span class="pl-c1">1</span>;
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> m; i<span class="pl-k">++</span>) {
            <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">1</span>; j <span class="pl-k">&lt;</span> n; j<span class="pl-k">++</span>) {
                dp[j] <span class="pl-k">=</span> dp[j] <span class="pl-k">+</span> dp[j<span class="pl-k">-</span><span class="pl-c1">1</span>];
            }
        }

        <span class="pl-k">return</span> dp[n<span class="pl-k">-</span><span class="pl-c1">1</span>];
 }

</pre></div>

<p><strong>Solution 4</strong></p>

<p>We can also use combination to solve this problem. We need to walk m+n-2 steps. m-1 steps down and n-1 steps right. </p>

<p><strong>Note that the numbers will because really big after a few steps. Remember to use double or big integers.</strong></p>

<div class="highlight highlight-java"><pre>     <span class="pl-k">public</span> <span class="pl-k">int</span> uniquePaths3(<span class="pl-k">int</span> m, <span class="pl-k">int</span> n) {
         <span class="pl-k">int</span> small <span class="pl-k">=</span> m <span class="pl-k">&lt;</span> n <span class="pl-k">?</span> m<span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-k">:</span> n<span class="pl-k">-</span><span class="pl-c1">1</span>;
         <span class="pl-k">int</span> large <span class="pl-k">=</span> small <span class="pl-k">==</span> m<span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-k">?</span> n<span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-k">:</span> m<span class="pl-k">-</span><span class="pl-c1">1</span>;
         <span class="pl-c">/* if use int, when m, n &gt; 10, will overflow and get wrong answer*/</span>
         <span class="pl-k">double</span> up <span class="pl-k">=</span> <span class="pl-c1">1</span>;
         <span class="pl-k">double</span> down <span class="pl-k">=</span> <span class="pl-c1">1</span>;
         <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;=</span> small; i<span class="pl-k">++</span>) {
             down <span class="pl-k">*=</span> i;
             up <span class="pl-k">*=</span> small <span class="pl-k">+</span> large <span class="pl-k">+</span> <span class="pl-c1">1</span> <span class="pl-k">-</span>i;
         }
         <span class="pl-k">return</span> (<span class="pl-k">int</span>) (up<span class="pl-k">/</span>down);

     }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-63-unique-paths-ii" class="anchor" href="https://github.com/wishyouhappy/Algorithm#63-unique-paths-ii" aria-hidden="true"><span class="octicon octicon-link"></span></a>63 Unique Paths II</h3>

<blockquote>
<p>Follow up for "Unique Paths":</p>

<p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>

<p>An obstacle and empty space is marked as 1 and 0 respectively in the grid.</p>
</blockquote>

<pre>For example,
There is one obstacle in the middle of a 3x3 grid as illustrated below.

[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
The total number of unique paths is 2.

Note: m and n will be at most 100.

</pre>

<p><strong>Idea</strong>: The basic Idea is similar to <strong>62 Unique path</strong>. Only difference is that we can not run through obstacles in this problem. So when we encounter obstacles, we need to set path through that lattice to 0.</p>

<p>Similarly, we can use one dimensional array or two dimensional array to solve this problem. </p>

<p><strong>Attention</strong>: <em>For the two dimensional array solution we need to take attention to the dp array initialization. Note that if one lattice if blocked, like grid[2][0] == 1, then all lattices after grid[2][0] such ad grid[3][0] ... should set dp[i][0] to 0.</em></p>

<p><strong>Java code</strong>:</p>

<p><strong>Two dimensional array</strong>:</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">int</span> uniquePathsWithObstacles(<span class="pl-k">int</span>[][] obstacleGrid) {
        <span class="pl-k">if</span> (obstacleGrid <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> obstacleGrid<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> obstacleGrid[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> obstacleGrid[<span class="pl-c1">0</span>][<span class="pl-c1">0</span>] <span class="pl-k">==</span> <span class="pl-c1">1</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        }
        <span class="pl-k">int</span>[][] dp <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[obstacleGrid<span class="pl-k">.</span>length][obstacleGrid[<span class="pl-c1">0</span>].length];
        <span class="pl-k">boolean</span> blocked <span class="pl-k">=</span> <span class="pl-c1">false</span>;
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> obstacleGrid<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
            <span class="pl-k">if</span> (obstacleGrid[i][<span class="pl-c1">0</span>] <span class="pl-k">==</span> <span class="pl-c1">1</span>) {
                blocked <span class="pl-k">=</span> <span class="pl-c1">true</span>;
            }
            <span class="pl-k">if</span> (<span class="pl-k">!</span>blocked) {
                dp[i][<span class="pl-c1">0</span>] <span class="pl-k">=</span> <span class="pl-c1">1</span>;
            }
        }
        blocked <span class="pl-k">=</span> <span class="pl-c1">false</span>;
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> obstacleGrid[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
            <span class="pl-k">if</span> (obstacleGrid[<span class="pl-c1">0</span>][i] <span class="pl-k">==</span> <span class="pl-c1">1</span>) {
                blocked <span class="pl-k">=</span> <span class="pl-c1">true</span>;
            }
            <span class="pl-k">if</span> (<span class="pl-k">!</span>blocked) {
                dp[<span class="pl-c1">0</span>][i] <span class="pl-k">=</span> <span class="pl-c1">1</span>;
            }
        }
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>, rlen <span class="pl-k">=</span> obstacleGrid<span class="pl-k">.</span>length; i <span class="pl-k">&lt;</span> rlen; i<span class="pl-k">++</span>) {
            <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">1</span>, clen <span class="pl-k">=</span> obstacleGrid[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length; j <span class="pl-k">&lt;</span> clen; j<span class="pl-k">++</span>) {
                <span class="pl-k">if</span> (obstacleGrid[i][j] <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
                    dp[i][j] <span class="pl-k">=</span> dp[i][j<span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">+</span> dp[i<span class="pl-k">-</span><span class="pl-c1">1</span>][j];
                }
            }
        }
        <span class="pl-k">return</span> dp[obstacleGrid<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>][obstacleGrid[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>];
    }
</pre></div>

<p><strong>One dimensional array</strong>:</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">int</span> uniquePathsWithObstacles(<span class="pl-k">int</span>[][] obstacleGrid) {
        <span class="pl-k">int</span> m <span class="pl-k">=</span> obstacleGrid<span class="pl-k">.</span>length;
        <span class="pl-k">int</span> n <span class="pl-k">=</span> obstacleGrid[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length;
        <span class="pl-k">if</span> (obstacleGrid <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> m <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> n <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> obstacleGrid[<span class="pl-c1">0</span>][<span class="pl-c1">0</span>] <span class="pl-k">==</span> <span class="pl-c1">1</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        }
        <span class="pl-k">int</span>[] dp <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[n];
        dp[<span class="pl-c1">0</span>] <span class="pl-k">=</span> <span class="pl-c1">1</span>;
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> m; i<span class="pl-k">++</span>) {
            <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;</span> n; j<span class="pl-k">++</span>) {
                <span class="pl-k">if</span> (obstacleGrid[i][j] <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> j <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>) {
                    dp[j] <span class="pl-k">=</span> dp[j<span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">+</span> dp[j];
                }<span class="pl-k">else</span> <span class="pl-k">if</span> (obstacleGrid[i][j] <span class="pl-k">==</span> <span class="pl-c1">1</span>) {
                    dp[j] <span class="pl-k">=</span> <span class="pl-c1">0</span>;
                }
            }
        }
        <span class="pl-k">return</span> dp[n <span class="pl-k">-</span> <span class="pl-c1">1</span>];
    }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-64-minimum-path-sum" class="anchor" href="https://github.com/wishyouhappy/Algorithm#64-minimum-path-sum" aria-hidden="true"><span class="octicon octicon-link"></span></a>64 Minimum Path Sum</h3>

<blockquote>
<p>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.</p>

<p>Note: You can only move either down or right at any point in time.</p>
</blockquote>

<p><strong>Idea</strong>: If you have figure out how to solve the unique path problem :</p>

<ul>
<li><a href="https://github.com/wishyouhappy/Algorithm#62-unique-paths">62 Unique Paths</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#63-unique-paths-ii">63 Unique Paths II</a></li>
</ul>

<p>you will find that we can solve this problem in the same way. We can use recursion, 2 dimensonal dp, 1 dimensional dp to solve this problem. </p>

<p><strong>Here is the 2 dimensional dp solution in java:</strong></p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> minPathSum(<span class="pl-k">int</span>[][] grid) {
        <span class="pl-k">if</span> (grid <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> grid<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> grid[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        }
        <span class="pl-k">int</span> m <span class="pl-k">=</span> grid<span class="pl-k">.</span>length; 
        <span class="pl-k">int</span> n <span class="pl-k">=</span> grid[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length;
        <span class="pl-k">int</span>[][] dp <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[m][n];
        dp[<span class="pl-c1">0</span>][<span class="pl-c1">0</span>] <span class="pl-k">=</span> grid[<span class="pl-c1">0</span>][<span class="pl-c1">0</span>];
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;</span> n; i<span class="pl-k">++</span>) {
            dp[<span class="pl-c1">0</span>][i] <span class="pl-k">=</span> dp[<span class="pl-c1">0</span>][i<span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">+</span> grid[<span class="pl-c1">0</span>][i];
        }
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;</span> m; i<span class="pl-k">++</span>) {
            dp[i][<span class="pl-c1">0</span>] <span class="pl-k">=</span> dp[i<span class="pl-k">-</span><span class="pl-c1">1</span>][<span class="pl-c1">0</span>] <span class="pl-k">+</span> grid[i][<span class="pl-c1">0</span>];
        }
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;</span> m; i<span class="pl-k">++</span>) {
            <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">1</span>; j <span class="pl-k">&lt;</span> n; j<span class="pl-k">++</span>) {
                dp[i][j] <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>min(dp[i<span class="pl-k">-</span><span class="pl-c1">1</span>][j] <span class="pl-k">+</span> grid[i][j], dp[i][j<span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">+</span> grid[i][j]);
            }
        }
        <span class="pl-k">return</span> dp[m<span class="pl-k">-</span><span class="pl-c1">1</span>][n<span class="pl-k">-</span><span class="pl-c1">1</span>];
    }
</pre></div>

<p><strong>Here is the 1 dimensional dp solution in java:</strong></p>

<div class="highlight highlight-java"><pre> <span class="pl-k">public</span> <span class="pl-k">int</span> minPathSum(<span class="pl-k">int</span>[][] grid) {
        <span class="pl-k">if</span> (grid <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> grid<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> grid[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        }
        <span class="pl-k">int</span> m <span class="pl-k">=</span> grid<span class="pl-k">.</span>length; 
        <span class="pl-k">int</span> n <span class="pl-k">=</span> grid[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length;
        <span class="pl-k">int</span>[] dp <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[n];
        dp[<span class="pl-c1">0</span>] <span class="pl-k">=</span> grid[<span class="pl-c1">0</span>][<span class="pl-c1">0</span>];
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> m; i<span class="pl-k">++</span>) {
            <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;</span> n; j<span class="pl-k">++</span>) {
                <span class="pl-k">if</span> (j <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> i <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
                    <span class="pl-k">continue</span>;
                } <span class="pl-k">else</span> <span class="pl-k">if</span> (i <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
                    dp[j] <span class="pl-k">=</span> dp[j<span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">+</span> grid[i][j];
                } <span class="pl-k">else</span> <span class="pl-k">if</span> (j <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
                    dp[j] <span class="pl-k">=</span> dp[j] <span class="pl-k">+</span> grid[i][j];
                } <span class="pl-k">else</span> {
                     dp[j] <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>min(dp[j], dp[j<span class="pl-k">-</span><span class="pl-c1">1</span>]) <span class="pl-k">+</span> grid[i][j];
                }
            }
        }
        <span class="pl-k">return</span> dp[n<span class="pl-k">-</span><span class="pl-c1">1</span>];
    }

</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-65-valid-number" class="anchor" href="https://github.com/wishyouhappy/Algorithm#65-valid-number" aria-hidden="true"><span class="octicon octicon-link"></span></a>65 Valid Number</h3>

<blockquote>
<p>Validate if a given string is numeric.</p>

<p>Some examples:</p>

<p>"0" =&gt; true</p>

<p>" 0.1 " =&gt; true</p>

<p>"abc" =&gt; false</p>

<p>"1 a" =&gt; false</p>

<p>"2e10" =&gt; true</p>

<p>Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one.</p>
</blockquote>

<p><strong>Need to consider before start</strong>:</p>

<pre>- In a number it could include 0, 1-9, ., e E, + - Thus if other character appears, then the number is invalid

- The right place of the above characters: 

    - 0-9:  0-9 is valid in any place. 
    
    - . 
        * can not after e or E
        * must has a number before it or after it 
        
    - - and + :
        * must at the beginning or after e or E
        * must has a number or . after it.

    - e or E:
        * must be the first time appear, that is, there should not be any e or E before it
        * e should not at the beginning
        * it must be a integer after e (we can have + or 1 after e)
    
</pre>

<p><strong>Some case</strong>:</p>

<pre>"1 " true
"  " false
"-1." true
"6e6.5" false
" 005047e+6" true

</pre>

<p><strong>Java code</strong></p>

<div class="highlight highlight-java"><pre>
    <span class="pl-k">public</span> <span class="pl-k">boolean</span> isNumber1(<span class="pl-smi">String</span> s) {
        <span class="pl-k">if</span> (s <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> s<span class="pl-k">.</span>trim()<span class="pl-k">.</span>length() <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        s <span class="pl-k">=</span> s<span class="pl-k">.</span>trim();
        <span class="pl-k">boolean</span> eE <span class="pl-k">=</span> <span class="pl-c1">false</span>;
        <span class="pl-k">boolean</span> dot <span class="pl-k">=</span> <span class="pl-c1">false</span>;
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> s<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>) {
            <span class="pl-k">char</span> c <span class="pl-k">=</span> s<span class="pl-k">.</span>charAt(i);
            <span class="pl-c">//check if character valid, if e|E at the beginning , if -|+ at the end</span>
            <span class="pl-k">if</span> (<span class="pl-k">!</span>isValidCharacter(c) <span class="pl-k">||</span> (i <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> (c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>e<span class="pl-pds">'</span></span> <span class="pl-k">||</span> c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>E<span class="pl-pds">'</span></span>)) <span class="pl-k">||</span> (i <span class="pl-k">==</span> s<span class="pl-k">.</span>length() <span class="pl-k">-</span><span class="pl-c1">1</span>  <span class="pl-k">&amp;&amp;</span> (c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>-<span class="pl-pds">'</span></span> <span class="pl-k">||</span> c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>+<span class="pl-pds">'</span></span>))) {
               <span class="pl-k">return</span> <span class="pl-c1">false</span>;
            }
            <span class="pl-c">//if e|E, e|E must hasn't existed before, must be a number of + - after it</span>
            <span class="pl-k">if</span> ((c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>e<span class="pl-pds">'</span></span> <span class="pl-k">||</span> c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>E<span class="pl-pds">'</span></span>)) {
                <span class="pl-k">if</span> (eE <span class="pl-k">||</span> (i <span class="pl-k">==</span> s<span class="pl-k">.</span>length() <span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-k">||</span> (<span class="pl-k">!</span>isNumber(s<span class="pl-k">.</span>charAt(i<span class="pl-k">+</span><span class="pl-c1">1</span>)) <span class="pl-k">&amp;&amp;</span> s<span class="pl-k">.</span>charAt(i<span class="pl-k">+</span><span class="pl-c1">1</span>) <span class="pl-k">!=</span> <span class="pl-s"><span class="pl-pds">'</span>-<span class="pl-pds">'</span></span> <span class="pl-k">&amp;&amp;</span> s<span class="pl-k">.</span>charAt(i<span class="pl-k">+</span><span class="pl-c1">1</span>) <span class="pl-k">!=</span> <span class="pl-s"><span class="pl-pds">'</span>+<span class="pl-pds">'</span></span>))) {
                    <span class="pl-k">return</span> <span class="pl-c1">false</span>;
                }
                eE <span class="pl-k">=</span> <span class="pl-c1">true</span>;
            }
            <span class="pl-c">//if -|+, must at the beginning or after e|E, must be a . or number after it</span>
            <span class="pl-k">if</span> ((c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>-<span class="pl-pds">'</span></span> <span class="pl-k">||</span> c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>+<span class="pl-pds">'</span></span>)) {
                <span class="pl-k">if</span>((<span class="pl-k">!</span>isNumber(s<span class="pl-k">.</span>charAt(i<span class="pl-k">+</span><span class="pl-c1">1</span>)) <span class="pl-k">&amp;&amp;</span> s<span class="pl-k">.</span>charAt(i<span class="pl-k">+</span><span class="pl-c1">1</span>) <span class="pl-k">!=</span> <span class="pl-s"><span class="pl-pds">'</span>.<span class="pl-pds">'</span></span>) <span class="pl-k">||</span> (i <span class="pl-k">!=</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> s<span class="pl-k">.</span>charAt(i<span class="pl-k">-</span><span class="pl-c1">1</span>) <span class="pl-k">!=</span> <span class="pl-s"><span class="pl-pds">'</span>e<span class="pl-pds">'</span></span> <span class="pl-k">&amp;&amp;</span> s<span class="pl-k">.</span>charAt(i<span class="pl-k">-</span><span class="pl-c1">1</span>) <span class="pl-k">!=</span> <span class="pl-s"><span class="pl-pds">'</span>E<span class="pl-pds">'</span></span>)) {
                    <span class="pl-k">return</span> <span class="pl-c1">false</span>;
                }
            }
            <span class="pl-c">// if ., .|e|E must hasn't existed before, must has a number before it or after it. </span>
           <span class="pl-k">if</span> (c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>.<span class="pl-pds">'</span></span>){
               <span class="pl-k">if</span> (dot <span class="pl-k">||</span> eE <span class="pl-k">||</span>  s<span class="pl-k">.</span>length() <span class="pl-k">==</span> <span class="pl-c1">1</span> <span class="pl-k">||</span> (i <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> <span class="pl-k">!</span>isNumber(s<span class="pl-k">.</span>charAt(i<span class="pl-k">+</span><span class="pl-c1">1</span>))) <span class="pl-k">||</span> ( i <span class="pl-k">==</span> s<span class="pl-k">.</span>length() <span class="pl-k">-</span> <span class="pl-c1">1</span> <span class="pl-k">&amp;&amp;</span> <span class="pl-k">!</span>isNumber(s<span class="pl-k">.</span>charAt(i<span class="pl-k">-</span><span class="pl-c1">1</span>))) <span class="pl-k">||</span> (i <span class="pl-k">!=</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> i <span class="pl-k">!=</span> s<span class="pl-k">.</span>length() <span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-k">&amp;&amp;</span> <span class="pl-k">!</span>isNumber(s<span class="pl-k">.</span>charAt(i<span class="pl-k">-</span><span class="pl-c1">1</span>)) <span class="pl-k">&amp;&amp;</span> <span class="pl-k">!</span>isNumber(s<span class="pl-k">.</span>charAt(i<span class="pl-k">+</span><span class="pl-c1">1</span>)))) {
                   <span class="pl-k">return</span> <span class="pl-c1">false</span>;
               } 
               dot <span class="pl-k">=</span> <span class="pl-c1">true</span>;
           }
        }
        <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }

    <span class="pl-k">public</span> <span class="pl-k">boolean</span> isNumber(<span class="pl-k">char</span> c) {
        <span class="pl-k">if</span> (c <span class="pl-k">&gt;=</span> <span class="pl-s"><span class="pl-pds">'</span>0<span class="pl-pds">'</span></span> <span class="pl-k">&amp;&amp;</span> c <span class="pl-k">&lt;=</span> <span class="pl-s"><span class="pl-pds">'</span>9<span class="pl-pds">'</span></span>) {
            <span class="pl-k">return</span> <span class="pl-c1">true</span>;
        }
        <span class="pl-k">return</span> <span class="pl-c1">false</span>;
    }

    <span class="pl-k">public</span> <span class="pl-k">boolean</span> isValidCharacter(<span class="pl-k">char</span> c) {
        <span class="pl-k">if</span> (isNumber(c) <span class="pl-k">||</span> c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>-<span class="pl-pds">'</span></span> <span class="pl-k">||</span> c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>+<span class="pl-pds">'</span></span> <span class="pl-k">||</span> c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>.<span class="pl-pds">'</span></span> <span class="pl-k">||</span> c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>e<span class="pl-pds">'</span></span> <span class="pl-k">||</span> c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>E<span class="pl-pds">'</span></span>) {
            <span class="pl-k">return</span> <span class="pl-c1">true</span>;
        }
        <span class="pl-k">return</span> <span class="pl-c1">false</span>;
    }

</pre></div>

<p>If use switch</p>

<div class="highlight highlight-java"><pre> <span class="pl-k">public</span> <span class="pl-k">boolean</span> isNumber(<span class="pl-smi">String</span> s) {
        <span class="pl-k">if</span> (s <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> s<span class="pl-k">.</span>trim()<span class="pl-k">.</span>length() <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        s <span class="pl-k">=</span> s<span class="pl-k">.</span>trim();
        <span class="pl-k">boolean</span> eE <span class="pl-k">=</span> <span class="pl-c1">false</span>;
        <span class="pl-k">boolean</span> dot <span class="pl-k">=</span> <span class="pl-c1">false</span>;
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> s<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>) {
           <span class="pl-k">switch</span>(s<span class="pl-k">.</span>charAt(i)) {
               <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">'</span>e<span class="pl-pds">'</span></span><span class="pl-k">:</span>
               <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">'</span>E<span class="pl-pds">'</span></span><span class="pl-k">:</span>
                    <span class="pl-k">if</span> (eE <span class="pl-k">||</span> i <span class="pl-k">==</span> s<span class="pl-k">.</span>length() <span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-k">||</span> i <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
                    <span class="pl-k">return</span> <span class="pl-c1">false</span>;
                }
                    eE <span class="pl-k">=</span> <span class="pl-c1">true</span>;
                    <span class="pl-k">break</span>;
                <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">'</span>-<span class="pl-pds">'</span></span><span class="pl-k">:</span>
                <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">'</span>+<span class="pl-pds">'</span></span><span class="pl-k">:</span>
                     <span class="pl-k">if</span> ((i <span class="pl-k">==</span> s<span class="pl-k">.</span>length() <span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-k">||</span> <span class="pl-k">!</span>((s<span class="pl-k">.</span>charAt(i<span class="pl-k">+</span><span class="pl-c1">1</span>) <span class="pl-k">&gt;=</span> <span class="pl-s"><span class="pl-pds">'</span>0<span class="pl-pds">'</span></span> <span class="pl-k">&amp;&amp;</span> s<span class="pl-k">.</span>charAt(i<span class="pl-k">+</span><span class="pl-c1">1</span>) <span class="pl-k">&lt;=</span> <span class="pl-s"><span class="pl-pds">'</span>9<span class="pl-pds">'</span></span>) <span class="pl-k">||</span> s<span class="pl-k">.</span>charAt(i<span class="pl-k">+</span><span class="pl-c1">1</span>) <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>.<span class="pl-pds">'</span></span>) <span class="pl-k">||</span> (i <span class="pl-k">!=</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> s<span class="pl-k">.</span>charAt(i<span class="pl-k">-</span><span class="pl-c1">1</span>) <span class="pl-k">!=</span> <span class="pl-s"><span class="pl-pds">'</span>e<span class="pl-pds">'</span></span> <span class="pl-k">&amp;&amp;</span> s<span class="pl-k">.</span>charAt(i<span class="pl-k">-</span><span class="pl-c1">1</span>) <span class="pl-k">!=</span> <span class="pl-s"><span class="pl-pds">'</span>E<span class="pl-pds">'</span></span>))) {
                    <span class="pl-k">return</span> <span class="pl-c1">false</span>;
                    }
                    <span class="pl-k">break</span>;
                <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">'</span>.<span class="pl-pds">'</span></span><span class="pl-k">:</span>
                    <span class="pl-k">if</span> (dot <span class="pl-k">||</span> eE <span class="pl-k">||</span> s<span class="pl-k">.</span>length() <span class="pl-k">==</span> <span class="pl-c1">1</span> <span class="pl-k">||</span> (i <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> <span class="pl-k">!</span>isNumber(s<span class="pl-k">.</span>charAt(i<span class="pl-k">+</span><span class="pl-c1">1</span>))) <span class="pl-k">||</span> ( i <span class="pl-k">==</span> s<span class="pl-k">.</span>length() <span class="pl-k">-</span> <span class="pl-c1">1</span> <span class="pl-k">&amp;&amp;</span> <span class="pl-k">!</span>isNumber(s<span class="pl-k">.</span>charAt(i<span class="pl-k">-</span><span class="pl-c1">1</span>))) <span class="pl-k">||</span> (i <span class="pl-k">!=</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> i <span class="pl-k">!=</span> s<span class="pl-k">.</span>length() <span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-k">&amp;&amp;</span> <span class="pl-k">!</span>isNumber(s<span class="pl-k">.</span>charAt(i<span class="pl-k">-</span><span class="pl-c1">1</span>)) <span class="pl-k">&amp;&amp;</span> <span class="pl-k">!</span>isNumber(s<span class="pl-k">.</span>charAt(i<span class="pl-k">+</span><span class="pl-c1">1</span>)))) {
                   <span class="pl-k">return</span> <span class="pl-c1">false</span>;
                    } 
                    dot <span class="pl-k">=</span> <span class="pl-c1">true</span>;
                    <span class="pl-k">break</span>;
                <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">'</span>0<span class="pl-pds">'</span></span><span class="pl-k">:</span>
                <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">'</span>1<span class="pl-pds">'</span></span><span class="pl-k">:</span>
                <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">'</span>2<span class="pl-pds">'</span></span><span class="pl-k">:</span>
                <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">'</span>3<span class="pl-pds">'</span></span><span class="pl-k">:</span>
                <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">'</span>4<span class="pl-pds">'</span></span><span class="pl-k">:</span>
                <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">'</span>5<span class="pl-pds">'</span></span><span class="pl-k">:</span>
                <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">'</span>6<span class="pl-pds">'</span></span><span class="pl-k">:</span>
                <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">'</span>7<span class="pl-pds">'</span></span><span class="pl-k">:</span>
                <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">'</span>8<span class="pl-pds">'</span></span><span class="pl-k">:</span>
                <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">'</span>9<span class="pl-pds">'</span></span><span class="pl-k">:</span>
                    <span class="pl-k">break</span>;
                <span class="pl-k">default</span><span class="pl-k">:</span>
                        <span class="pl-k">return</span> <span class="pl-c1">false</span>;
           }
        }
        <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }

    <span class="pl-k">public</span> <span class="pl-k">boolean</span> isNumber(<span class="pl-k">char</span> c) {
        <span class="pl-k">if</span> (c <span class="pl-k">&gt;=</span> <span class="pl-s"><span class="pl-pds">'</span>0<span class="pl-pds">'</span></span> <span class="pl-k">&amp;&amp;</span> c <span class="pl-k">&lt;=</span> <span class="pl-s"><span class="pl-pds">'</span>9<span class="pl-pds">'</span></span>) {
            <span class="pl-k">return</span> <span class="pl-c1">true</span>;
        }
        <span class="pl-k">return</span> <span class="pl-c1">false</span>;
    }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-66-plus-one" class="anchor" href="https://github.com/wishyouhappy/Algorithm#66-plus-one" aria-hidden="true"><span class="octicon octicon-link"></span></a>66 Plus One</h3>

<blockquote>
<p>Given a non-negative number represented as an array of digits, plus one to the number.</p>

<p>The digits are stored such that the most significant digit is at the head of the list.</p>
</blockquote>

<p><strong>Idea</strong>: Since the most significant digit is at the head of the list, thus we need to add from the end. Thus problem is really similar to add two numbers, the other number in the two number is 1. We just need to take care of the carry. </p>

<p>There are two cases:</p>

<ul>
<li>If carry is not 1 at the end, what should we  do? Definitely the original array is not big enough to store the result. Thus we need to enlarge the array by creating a new array. So the most straight forward thing to do is store the carry at index 0 and copy the original array, like the <strong>First try solution</strong> below.</li>
</ul>

<p>It seems that it's a pretty good solution. Well, actually, we just need to store carry in index 0. <strong>Why? Because if there are carry at the end, then the other digits must be 0</strong>.  See detail on the <strong>better solution</strong> below. </p>

<p><strong>Java code</strong>:</p>

<p><strong>First try</strong>:</p>

<div class="highlight highlight-java"><pre> <span class="pl-k">public</span> <span class="pl-k">int</span>[] plusOne(<span class="pl-k">int</span>[] digits) {
        <span class="pl-k">if</span> (digits <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> digits<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> digits;
        }
        <span class="pl-k">int</span> carry <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> digits<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>; i <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>; i<span class="pl-k">--</span>) {
            <span class="pl-k">int</span> digit <span class="pl-k">=</span> digits[i];
            <span class="pl-k">if</span> (i <span class="pl-k">==</span> digits<span class="pl-k">.</span>length <span class="pl-k">-</span><span class="pl-c1">1</span>) {
                digit <span class="pl-k">+=</span> <span class="pl-c1">1</span>;
            }
            digit <span class="pl-k">+=</span> carry;
            digits[i] <span class="pl-k">=</span> digit <span class="pl-k">%</span> <span class="pl-c1">10</span>;
            carry <span class="pl-k">=</span> digit <span class="pl-k">/</span> <span class="pl-c1">10</span>;
        }
        <span class="pl-k">if</span> (carry <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> digits;
        } <span class="pl-k">else</span> {
            <span class="pl-k">int</span>[] res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[digits<span class="pl-k">.</span>length <span class="pl-k">+</span> <span class="pl-c1">1</span>];
            res[<span class="pl-c1">0</span>] <span class="pl-k">=</span> carry;
            <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> digits<span class="pl-k">.</span>length; i<span class="pl-k">++</span>){
                res[i<span class="pl-k">+</span><span class="pl-c1">1</span>] <span class="pl-k">=</span> digits[i];
            }
            <span class="pl-k">return</span> res;
        }

    }

</pre></div>

<p><strong>Better solution</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span>[] plusOne(<span class="pl-k">int</span>[] digits) {
        <span class="pl-k">if</span> (digits <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> digits<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> digits;
        }
        <span class="pl-k">int</span> carry <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> digits<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>; i <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>; i<span class="pl-k">--</span>) {
            <span class="pl-k">int</span> digit <span class="pl-k">=</span> digits[i];
            <span class="pl-k">if</span> (i <span class="pl-k">==</span> digits<span class="pl-k">.</span>length <span class="pl-k">-</span><span class="pl-c1">1</span>) {
                digit <span class="pl-k">+=</span> <span class="pl-c1">1</span>;
            }
            digit <span class="pl-k">+=</span> carry;
            digits[i] <span class="pl-k">=</span> digit <span class="pl-k">%</span> <span class="pl-c1">10</span>;
            carry <span class="pl-k">=</span> digit <span class="pl-k">/</span> <span class="pl-c1">10</span>;
        }
        <span class="pl-k">if</span> (carry <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> digits;
        } <span class="pl-k">else</span> {
            <span class="pl-k">int</span>[] res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[digits<span class="pl-k">.</span>length <span class="pl-k">+</span> <span class="pl-c1">1</span>];
            res[<span class="pl-c1">0</span>] <span class="pl-k">=</span> carry;
            <span class="pl-k">return</span> res;
        }
    }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-67-add-binary" class="anchor" href="https://github.com/wishyouhappy/Algorithm#67-add-binary" aria-hidden="true"><span class="octicon octicon-link"></span></a>67 Add Binary</h3>

<blockquote>
<p>Given two binary strings, return their sum (also a binary string).</p>

<p>For example,</p>

<p>a = "11"</p>

<p>b = "1"</p>

<p>Return "100".</p>
</blockquote>

<p><strong>Idea</strong>:</p>

<p><strong>Solution</strong>:</p>

<p><br></p>

<p><br></p>

<h3><a id="user-content-69-sqrt" class="anchor" href="https://github.com/wishyouhappy/Algorithm#69-sqrt" aria-hidden="true"><span class="octicon octicon-link"></span></a>69 Sqrt</h3>

<blockquote>
<p>Implement int sqrt(int x).</p>

<p>Compute and return the square root of x.</p>
</blockquote>

<p><strong>Idea</strong>: The result = x/result, so each time we can give a better guess result = (result + x/result)/2 until we get the correct answer.</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">int</span> mySqrt(<span class="pl-k">int</span> x) {
        <span class="pl-k">if</span> (x <span class="pl-k">&lt;</span> <span class="pl-c1">1</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        }
        <span class="pl-k">double</span> res <span class="pl-k">=</span> <span class="pl-c1">1</span>;
        <span class="pl-k">while</span> (<span class="pl-c1">true</span>) {
            <span class="pl-k">if</span> (<span class="pl-smi">Math</span><span class="pl-k">.</span>abs(res <span class="pl-k">-</span> x<span class="pl-k">/</span>res) <span class="pl-k">&lt;</span> <span class="pl-c1">0.00000001</span>) {
                <span class="pl-k">return</span> (<span class="pl-k">int</span>)res;
            }
            res <span class="pl-k">=</span> (res <span class="pl-k">+</span> x <span class="pl-k">/</span> res) <span class="pl-k">/</span> <span class="pl-c1">2</span>;
        }
    }</pre></div>

<p><strong>Other Idea</strong>: Dichotomy. l = smallest possible result, r the largest possible result. mid = (l + r)/2 , check the relationship between mid and result</p>

<p><strong>Attention</strong>: mid &lt;= x/mid &amp;&amp; (mid + 1) &gt; x/(mid+1) can not change to mid * mid &lt;= x &amp;&amp; (mid+1) * (mid+1) &gt; x. Because, when <strong>mid * mid overflows</strong>, the result might change, also, it might lead to Time limit exceeded.</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> mySqrt(<span class="pl-k">int</span> x) {
        <span class="pl-k">if</span> (x <span class="pl-k">&lt;</span> <span class="pl-c1">1</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        }
        <span class="pl-k">int</span> l <span class="pl-k">=</span> <span class="pl-c1">1</span>;
        <span class="pl-k">int</span> r <span class="pl-k">=</span> x<span class="pl-k">/</span><span class="pl-c1">2</span> <span class="pl-k">+</span> <span class="pl-c1">1</span>;
        <span class="pl-k">while</span> (l <span class="pl-k">&lt;=</span> r) {
           <span class="pl-k">int</span> mid <span class="pl-k">=</span> l <span class="pl-k">+</span> (r <span class="pl-k">-</span> l) <span class="pl-k">/</span> <span class="pl-c1">2</span>;
           <span class="pl-k">if</span> (mid <span class="pl-k">&lt;=</span> x <span class="pl-k">/</span> mid <span class="pl-k">&amp;&amp;</span> (mid <span class="pl-k">+</span> <span class="pl-c1">1</span>) <span class="pl-k">&gt;</span> x <span class="pl-k">/</span> (mid <span class="pl-k">+</span> <span class="pl-c1">1</span>)) {
               <span class="pl-k">return</span> mid;
           } <span class="pl-k">else</span> <span class="pl-k">if</span> (mid <span class="pl-k">&gt;</span> x <span class="pl-k">/</span> mid) {
               r <span class="pl-k">=</span> mid <span class="pl-k">-</span> <span class="pl-c1">1</span>;
           } <span class="pl-k">else</span> {
               l <span class="pl-k">=</span> mid <span class="pl-k">+</span> <span class="pl-c1">1</span>;
           }
        }
        <span class="pl-k">return</span> <span class="pl-c1">0</span>;
    }
</pre></div>

<p><br></p>

<p><br></p>

<h3><a id="user-content-70-climbing-stairs" class="anchor" href="https://github.com/wishyouhappy/Algorithm#70-climbing-stairs" aria-hidden="true"><span class="octicon octicon-link"></span></a>70 Climbing Stairs</h3>

<blockquote>
<p>You are climbing a stair case. It takes n steps to reach to the top.</p>
</blockquote>

<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>

<p><strong>Idea</strong>: Each time we can climb 1 steps or 2 steps, thus Fn = Fn-1 + Fn-2. It's just a fibonacci sequence. </p>

<p><strong>Solution1</strong> Use dp, Time O(n), Space O(1)</p>

<div class="highlight highlight-java"><pre> <span class="pl-k">public</span> <span class="pl-k">int</span> climbStairs(<span class="pl-k">int</span> n){
        <span class="pl-k">if</span>(n <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">1</span>;
        <span class="pl-k">if</span>(n <span class="pl-k">==</span> <span class="pl-c1">1</span>) <span class="pl-k">return</span> <span class="pl-c1">1</span>;
        <span class="pl-k">int</span> n1 <span class="pl-k">=</span> <span class="pl-c1">1</span>;
        <span class="pl-k">int</span> n2 <span class="pl-k">=</span> <span class="pl-c1">1</span>;
        <span class="pl-k">int</span> n3 <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">2</span>; i <span class="pl-k">&lt;=</span> n; i<span class="pl-k">++</span>){
            n3 <span class="pl-k">=</span> n1 <span class="pl-k">+</span> n2;
            n1 <span class="pl-k">=</span> n2;
            n2 <span class="pl-k">=</span> n3;
        }
        <span class="pl-k">return</span> n3;
    }</pre></div>

<p><strong>Solution2</strong>: Use matrix, O(lgn) time.</p>

<div class="highlight highlight-java"><pre>   <span class="pl-k">public</span> <span class="pl-k">int</span> climbStairs2(<span class="pl-k">int</span> n){
        <span class="pl-k">if</span>(n <span class="pl-k">&lt;</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        <span class="pl-k">if</span>(n <span class="pl-k">&lt;=</span> <span class="pl-c1">1</span>) <span class="pl-k">return</span> <span class="pl-c1">1</span>;
        <span class="pl-k">int</span>[][] res <span class="pl-k">=</span> {{<span class="pl-c1">1</span>, <span class="pl-c1">0</span>}, {<span class="pl-c1">0</span>, <span class="pl-c1">1</span>}};
        <span class="pl-k">int</span>[][] m <span class="pl-k">=</span> {{<span class="pl-c1">1</span>, <span class="pl-c1">1</span>}, {<span class="pl-c1">1</span>, <span class="pl-c1">0</span>}};
        <span class="pl-k">while</span>(n <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>){
            <span class="pl-k">if</span>(n <span class="pl-k">%</span> <span class="pl-c1">2</span> <span class="pl-k">==</span> <span class="pl-c1">1</span>) res <span class="pl-k">=</span> multiplyMatrix(res, m);
            n <span class="pl-k">=</span> n<span class="pl-k">/</span><span class="pl-c1">2</span>;
            m <span class="pl-k">=</span> multiplyMatrix(m, m);
        }
        <span class="pl-k">return</span> res[<span class="pl-c1">0</span>][<span class="pl-c1">0</span>];
    }


    <span class="pl-k">public</span> <span class="pl-k">int</span>[][] multiplyMatrix(<span class="pl-k">int</span>[][] m, <span class="pl-k">int[][]</span>n){
        <span class="pl-k">int</span> a <span class="pl-k">=</span> m[<span class="pl-c1">0</span>][<span class="pl-c1">0</span>] <span class="pl-k">*</span> n[<span class="pl-c1">0</span>][<span class="pl-c1">0</span>] <span class="pl-k">+</span> m[<span class="pl-c1">0</span>][<span class="pl-c1">1</span>] <span class="pl-k">*</span> n[<span class="pl-c1">1</span>][<span class="pl-c1">0</span>];
        <span class="pl-k">int</span> b <span class="pl-k">=</span> m[<span class="pl-c1">0</span>][<span class="pl-c1">0</span>] <span class="pl-k">*</span> n[<span class="pl-c1">0</span>][<span class="pl-c1">1</span>] <span class="pl-k">+</span> m[<span class="pl-c1">0</span>][<span class="pl-c1">1</span>] <span class="pl-k">*</span> n[<span class="pl-c1">1</span>][<span class="pl-c1">1</span>];
        <span class="pl-k">int</span> c <span class="pl-k">=</span> m[<span class="pl-c1">1</span>][<span class="pl-c1">0</span>] <span class="pl-k">*</span> n[<span class="pl-c1">0</span>][<span class="pl-c1">0</span>] <span class="pl-k">+</span> m[<span class="pl-c1">1</span>][<span class="pl-c1">1</span>] <span class="pl-k">*</span> n[<span class="pl-c1">1</span>][<span class="pl-c1">0</span>];
        <span class="pl-k">int</span> d <span class="pl-k">=</span> m[<span class="pl-c1">1</span>][<span class="pl-c1">0</span>] <span class="pl-k">*</span> n[<span class="pl-c1">0</span>][<span class="pl-c1">1</span>] <span class="pl-k">+</span> m[<span class="pl-c1">1</span>][<span class="pl-c1">1</span>] <span class="pl-k">*</span> n[<span class="pl-c1">1</span>][<span class="pl-c1">1</span>];
        <span class="pl-k">int</span>[][] res <span class="pl-k">=</span> {{a, b}, {c, d}};
        <span class="pl-k">return</span> res;
    }
</pre></div>

<p><strong>Solution 3</strong> : recursion, O(2 ^ n) time.</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> climbStairs(<span class="pl-k">int</span> n) {
        <span class="pl-k">if</span>(n <span class="pl-k">&lt;</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        <span class="pl-k">if</span>(n <span class="pl-k">==</span> <span class="pl-c1">1</span> <span class="pl-k">||</span> n <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">1</span>;
        <span class="pl-k">return</span> climbStairs(n<span class="pl-k">-</span><span class="pl-c1">1</span>)<span class="pl-k">+</span>climbStairs(n<span class="pl-k">-</span><span class="pl-c1">2</span>);
    }
</pre></div>

<p>We see that the value of Fibonacci increases exponentially. If we use int, then we can only compute to F47, if we use long, we can compute to F96. So if our required numbers are big, it's unreasonable to use in/long as return value. We can use BigInteger in java. Eg:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">String</span> bigFib(<span class="pl-k">int</span> n){
        <span class="pl-k">if</span>(n <span class="pl-k">&lt;=</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>0<span class="pl-pds">"</span></span>;
        <span class="pl-k">if</span>(n <span class="pl-k">==</span> <span class="pl-c1">1</span>) <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>;
        <span class="pl-smi">BigInteger</span> n1 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">BigInteger</span>(<span class="pl-s"><span class="pl-pds">"</span>0<span class="pl-pds">"</span></span>);
        <span class="pl-smi">BigInteger</span> n2 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">BigInteger</span>(<span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>);
        <span class="pl-smi">BigInteger</span> n3 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">BigInteger</span>(<span class="pl-s"><span class="pl-pds">"</span>0<span class="pl-pds">"</span></span>);
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">2</span>; i <span class="pl-k">&lt;=</span> n; i<span class="pl-k">++</span>){
            n3 <span class="pl-k">=</span> n1<span class="pl-k">.</span>add(n2);
            n1 <span class="pl-k">=</span> n2;
            n2 <span class="pl-k">=</span> n3;
        }
        <span class="pl-k">return</span> n3<span class="pl-k">.</span>toString();

    }

</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-73-set-matrix-zeroes" class="anchor" href="https://github.com/wishyouhappy/Algorithm#73-set-matrix-zeroes" aria-hidden="true"><span class="octicon octicon-link"></span></a>73 Set Matrix Zeroes</h3>

<blockquote>
<p>Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.</p>
</blockquote>

<p><strong>Idea</strong>: The easiest way to do this problem is record the rows of columns needed to be set to 0. We can use extra array to record the rows and columns. The space complexity would ba O(m+n). If we use one row and one column that are supposed to set to 0s to stroe the information, we can get O(1) space complexity.</p>

<p><strong>Java code</strong>:</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">void</span> setZeroes(<span class="pl-k">int</span>[][] matrix) {
        <span class="pl-k">if</span>(matrix <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> matrix<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> matrix[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span>;
        <span class="pl-k">int</span>[] rzeros <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[matrix<span class="pl-k">.</span>length];
        <span class="pl-k">int</span>[] czeros <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[matrix[<span class="pl-c1">0</span>].length];

        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> matrix<span class="pl-k">.</span>length; i<span class="pl-k">++</span>){
            <span class="pl-k">for</span>(<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;</span> matrix[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length; j<span class="pl-k">++</span>){
                <span class="pl-k">if</span>(matrix[i][j] <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
                    rzeros[i] <span class="pl-k">=</span> <span class="pl-c1">1</span>;
                    czeros[j] <span class="pl-k">=</span> <span class="pl-c1">1</span>;
                }
            }
        }
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> rzeros<span class="pl-k">.</span>length; i<span class="pl-k">++</span>){
            <span class="pl-k">if</span>(rzeros[i] <span class="pl-k">==</span> <span class="pl-c1">1</span>){
                <span class="pl-k">for</span>(<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;</span> matrix[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length; j<span class="pl-k">++</span>){
                    matrix[i][j] <span class="pl-k">=</span> <span class="pl-c1">0</span>;
                }
            } 
        }
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> czeros<span class="pl-k">.</span>length; i<span class="pl-k">++</span>){
            <span class="pl-k">if</span>(czeros[i] <span class="pl-k">==</span> <span class="pl-c1">1</span>){
                <span class="pl-k">for</span>(<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;</span> matrix<span class="pl-k">.</span>length; j<span class="pl-k">++</span>){
                    matrix[j][i] <span class="pl-k">=</span> <span class="pl-c1">0</span>;
                }
            }
        }
    }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-74-search-a-2d-matrix" class="anchor" href="https://github.com/wishyouhappy/Algorithm#74-search-a-2d-matrix" aria-hidden="true"><span class="octicon octicon-link"></span></a>74 Search a 2D Matrix</h3>

<blockquote>
<p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p>

<p>Integers in each row are sorted from left to right.
The first integer of each row is greater than the last integer of the previous row.
For example,</p>

<p>Consider the following matrix:</p>
</blockquote>

<pre>[
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
Given target = 3, return true.

</pre>

<p><strong>Idea</strong>:</p>

<p><em>Solution 1</em>: We can search from the top-right, if the target is larger than current, then we move to next row. If the target is smaller, then we move to left.</p>

<p><em>Solution 2</em>: We use the method in solution 1 to find the target row, then apply binary search on that row.</p>

<p>Solution 3*: Use binary search to find the row, then in that row, use binary search to find the target.</p>

<p><strong>Attention: In binary search, when loop ends, if target is not found, then l points to the first element larger than the target and r points to the first element smaller than target.</strong> </p>

<p><strong>java code</strong>:</p>

<p><strong>Solution 1</strong>: Time: O(m + n)</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">boolean</span> searchMatrix(<span class="pl-k">int</span>[][] matrix, <span class="pl-k">int</span> target) {
        <span class="pl-k">if</span>(matrix <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> matrix<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> matrix[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>, row <span class="pl-k">=</span> matrix<span class="pl-k">.</span>length; i <span class="pl-k">&lt;</span> row; i<span class="pl-k">++</span>) {
            <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> matrix[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>; j <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>; j<span class="pl-k">--</span>) {
                <span class="pl-k">if</span> (matrix[i][j] <span class="pl-k">==</span> target) {
                    <span class="pl-k">return</span> <span class="pl-c1">true</span>;
                } <span class="pl-k">else</span> <span class="pl-k">if</span> (matrix[i][j] <span class="pl-k">&lt;</span> target) {
                    <span class="pl-k">break</span>;
                }
            }
        }
      <span class="pl-k">return</span> <span class="pl-c1">false</span>;
    }</pre></div>

<p><strong>Solution 2</strong>: Time: O(m) + O(lgn)</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">boolean</span> searchMatrix(<span class="pl-k">int</span>[][] matrix, <span class="pl-k">int</span> target) {
        <span class="pl-k">if</span>(matrix <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> matrix<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> matrix[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>, row <span class="pl-k">=</span> matrix<span class="pl-k">.</span>length; i <span class="pl-k">&lt;</span> row; i<span class="pl-k">++</span>) {
            <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> matrix[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>; j <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>; j<span class="pl-k">--</span>) {
                <span class="pl-k">if</span> (matrix[i][j] <span class="pl-k">==</span> target) {
                    <span class="pl-k">return</span> <span class="pl-c1">true</span>;
                } <span class="pl-k">else</span> <span class="pl-k">if</span> (matrix[i][j] <span class="pl-k">&lt;</span> target) {
                    <span class="pl-k">break</span>;
                } <span class="pl-k">else</span> {
                    <span class="pl-c">//do binary search </span>
                    <span class="pl-k">int</span> l <span class="pl-k">=</span> <span class="pl-c1">0</span>;
                    <span class="pl-k">int</span> r <span class="pl-k">=</span> j <span class="pl-k">-</span> <span class="pl-c1">1</span>;
                    <span class="pl-k">while</span> (l <span class="pl-k">&lt;=</span> r) {
                        <span class="pl-k">int</span> mid <span class="pl-k">=</span> l <span class="pl-k">+</span> (r <span class="pl-k">-</span> l) <span class="pl-k">/</span> <span class="pl-c1">2</span>;
                        <span class="pl-k">if</span> (matrix[i][mid] <span class="pl-k">==</span> target) {
                            <span class="pl-k">return</span> <span class="pl-c1">true</span>;
                        } <span class="pl-k">else</span> <span class="pl-k">if</span> (matrix[i][mid] <span class="pl-k">&gt;</span> target) {
                            r <span class="pl-k">=</span> mid <span class="pl-k">-</span> <span class="pl-c1">1</span>;
                        } <span class="pl-k">else</span> {
                            l <span class="pl-k">=</span> mid <span class="pl-k">+</span> <span class="pl-c1">1</span>;
                        }
                    }
                    <span class="pl-k">return</span> <span class="pl-c1">false</span>;
                }
            }
        }
      <span class="pl-k">return</span> <span class="pl-c1">false</span>;
    }</pre></div>

<p><strong>Solution 3</strong>: Time complexity: O(lgm) + O(lgn)</p>

<p><em>**There are two ways below, can you find out the big difference here? *</em>*</p>

<p>1) search from right. </p>

<div class="highlight highlight-java"><pre>   <span class="pl-k">public</span> <span class="pl-k">boolean</span> searchMatrix(<span class="pl-k">int</span>[][] matrix, <span class="pl-k">int</span> target) {
        <span class="pl-k">if</span>(matrix <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> matrix<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> matrix[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }

        <span class="pl-k">int</span> row <span class="pl-k">=</span> matrix<span class="pl-k">.</span>length;
        <span class="pl-k">int</span> col <span class="pl-k">=</span> matrix[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length;
        <span class="pl-k">int</span> l <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> r <span class="pl-k">=</span> row <span class="pl-k">-</span> <span class="pl-c1">1</span>;
        <span class="pl-c">//Find row</span>
        <span class="pl-k">while</span> (l <span class="pl-k">&lt;=</span> r) {
            <span class="pl-k">int</span> mid <span class="pl-k">=</span> l <span class="pl-k">+</span> (r <span class="pl-k">-</span> l) <span class="pl-k">/</span> <span class="pl-c1">2</span>;
            <span class="pl-k">if</span> (matrix[mid][col <span class="pl-k">-</span> <span class="pl-c1">1</span>] <span class="pl-k">==</span> target) {
                <span class="pl-k">return</span> <span class="pl-c1">true</span>;
            } <span class="pl-k">else</span> <span class="pl-k">if</span> (matrix[mid][col <span class="pl-k">-</span> <span class="pl-c1">1</span>] <span class="pl-k">&gt;</span> target) {
                r <span class="pl-k">=</span> mid <span class="pl-k">-</span> <span class="pl-c1">1</span>;
            } <span class="pl-k">else</span> {
                l <span class="pl-k">=</span> mid <span class="pl-k">+</span> <span class="pl-c1">1</span>;
            }
        }
        <span class="pl-c">//find target in that row</span>
        <span class="pl-k">if</span> (l <span class="pl-k">&gt;=</span> row <span class="pl-k">||</span> l <span class="pl-k">&lt;</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        <span class="pl-k">int</span> ll <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> rr <span class="pl-k">=</span> col <span class="pl-k">-</span> <span class="pl-c1">1</span>;
        <span class="pl-k">while</span> (ll <span class="pl-k">&lt;=</span> rr) {
            <span class="pl-k">int</span> midcol <span class="pl-k">=</span> ll <span class="pl-k">+</span> (rr <span class="pl-k">-</span>ll) <span class="pl-k">/</span> <span class="pl-c1">2</span>;
            <span class="pl-k">if</span> (matrix[l][midcol] <span class="pl-k">==</span> target) {
                <span class="pl-k">return</span> <span class="pl-c1">true</span>;
            } <span class="pl-k">else</span> <span class="pl-k">if</span> (matrix[l][midcol] <span class="pl-k">&lt;</span> target) {
                ll <span class="pl-k">=</span> midcol <span class="pl-k">+</span> <span class="pl-c1">1</span>;
            } <span class="pl-k">else</span> {
                rr <span class="pl-k">=</span> midcol <span class="pl-k">-</span> <span class="pl-c1">1</span>;
            }
        }
      <span class="pl-k">return</span> <span class="pl-c1">false</span>;
    }</pre></div>

<p>2) Search from left </p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">boolean</span> searchMatrix(<span class="pl-k">int</span>[][] matrix, <span class="pl-k">int</span> target) {
        <span class="pl-k">if</span>(matrix <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> matrix<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> matrix[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }

        <span class="pl-k">int</span> row <span class="pl-k">=</span> matrix<span class="pl-k">.</span>length;
        <span class="pl-k">int</span> col <span class="pl-k">=</span> matrix[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length;
        <span class="pl-k">int</span> l <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> r <span class="pl-k">=</span> row <span class="pl-k">-</span> <span class="pl-c1">1</span>;
        <span class="pl-c">//Find row</span>
        <span class="pl-k">while</span> (l <span class="pl-k">&lt;=</span> r) {
            <span class="pl-k">int</span> mid <span class="pl-k">=</span> l <span class="pl-k">+</span> (r <span class="pl-k">-</span> l) <span class="pl-k">/</span> <span class="pl-c1">2</span>;
            <span class="pl-k">if</span> (matrix[mid][<span class="pl-c1">0</span>] <span class="pl-k">==</span> target) {
                <span class="pl-k">return</span> <span class="pl-c1">true</span>;
            } <span class="pl-k">else</span> <span class="pl-k">if</span> (matrix[mid][<span class="pl-c1">0</span>] <span class="pl-k">&gt;</span> target) {
                r <span class="pl-k">=</span> mid <span class="pl-k">-</span> <span class="pl-c1">1</span>;
            } <span class="pl-k">else</span> {
                l <span class="pl-k">=</span> mid <span class="pl-k">+</span> <span class="pl-c1">1</span>;
            }
        }
        <span class="pl-c">//find target in that row</span>
        <span class="pl-k">if</span> (r <span class="pl-k">&gt;=</span> row <span class="pl-k">||</span> r <span class="pl-k">&lt;</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        <span class="pl-k">int</span> ll <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> rr <span class="pl-k">=</span> col <span class="pl-k">-</span> <span class="pl-c1">1</span>;
        <span class="pl-k">while</span> (ll <span class="pl-k">&lt;=</span> rr) {
            <span class="pl-k">int</span> midcol <span class="pl-k">=</span> ll <span class="pl-k">+</span> (rr <span class="pl-k">-</span>ll) <span class="pl-k">/</span> <span class="pl-c1">2</span>;
            <span class="pl-k">if</span> (matrix[r][midcol] <span class="pl-k">==</span> target) {
                <span class="pl-k">return</span> <span class="pl-c1">true</span>;
            } <span class="pl-k">else</span> <span class="pl-k">if</span> (matrix[r][midcol] <span class="pl-k">&lt;</span> target) {
                ll <span class="pl-k">=</span> midcol <span class="pl-k">+</span> <span class="pl-c1">1</span>;
            } <span class="pl-k">else</span> {
                rr <span class="pl-k">=</span> midcol <span class="pl-k">-</span> <span class="pl-c1">1</span>;
            }
        }
      <span class="pl-k">return</span> <span class="pl-c1">false</span>;
    }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-75-sort-colors" class="anchor" href="https://github.com/wishyouhappy/Algorithm#75-sort-colors" aria-hidden="true"><span class="octicon octicon-link"></span></a>75 Sort Colors</h3>

<blockquote>
<p>Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p>

<p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>

<p>Note:
You are not suppose to use the library's sort function for this problem. </p>
</blockquote>

<p><strong>Idea</strong>:</p>

<ul>
<li>Solution 1: Use counting sort, we can count the numbers of 0, 1, 2, then refill numbers into A. <strong>Note that this is not inplace</strong></li>
<li>Solution 2: Use two pointers for 0 and 1, if we encounter 0, A[count1++] = 1, A[count0++] = 0, if we encounter 1, count1++</li>
</ul>

<p><strong>Attention</strong>: </p>

<ul>
<li>1) For the second method, the sequence of count1++ and count0++ is impoertant, we need first A[count1++] = 1</li>
<li>2) Everytime before we move the two pointers, we need to assgin A[i] = 2. Because we don't maintain a pointer for 2, thus the last part would be 2.</li>
</ul>

<p><strong>Time complexity</strong></p>

<p>Use method1 need two pass. Method 2 only need one pass. </p>

<p><strong>Java code Solution1</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">void</span> sortColors(<span class="pl-k">int</span>[] <span class="pl-smi">A</span>) {
        <span class="pl-k">if</span>(<span class="pl-smi">A</span> <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span>;
        <span class="pl-k">int</span> count0 <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> count1 <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length; i<span class="pl-k">++</span>){
            <span class="pl-k">if</span>(<span class="pl-k">A</span>[i] <span class="pl-k">==</span> <span class="pl-c1">0</span>) count0<span class="pl-k">++</span>;
            <span class="pl-k">else</span> <span class="pl-k">if</span>(<span class="pl-k">A</span>[i] <span class="pl-k">==</span> <span class="pl-c1">1</span>) count1<span class="pl-k">++</span>;
        }
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length; i<span class="pl-k">++</span>){
            <span class="pl-k">if</span>(i <span class="pl-k">&lt;</span> count0) <span class="pl-k">A</span>[i] <span class="pl-k">=</span> <span class="pl-c1">0</span>;
            <span class="pl-k">else</span> <span class="pl-k">if</span>(i <span class="pl-k">&gt;=</span> count0 <span class="pl-k">&amp;&amp;</span> i <span class="pl-k">&lt;</span> count0<span class="pl-k">+</span>count1) <span class="pl-k">A</span>[i] <span class="pl-k">=</span> <span class="pl-c1">1</span>;
            <span class="pl-k">else</span> <span class="pl-k">A</span>[i] <span class="pl-k">=</span> <span class="pl-c1">2</span>;
        }
    }

</pre></div>

<p><strong>Java code solution 2</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">void</span> sortColors(<span class="pl-k">int</span>[] <span class="pl-smi">A</span>) {
        <span class="pl-k">if</span>(<span class="pl-smi">A</span> <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span>;
        <span class="pl-k">int</span> count0 <span class="pl-k">=</span> <span class="pl-c1">0</span>, count1 <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length; i<span class="pl-k">++</span>){
            <span class="pl-k">if</span>(<span class="pl-k">A</span>[i] <span class="pl-k">==</span> <span class="pl-c1">0</span>){
                <span class="pl-k">A</span>[i] <span class="pl-k">=</span> <span class="pl-c1">2</span>;
                <span class="pl-k">A</span>[count1<span class="pl-k">++</span>] <span class="pl-k">=</span> <span class="pl-c1">1</span>;
                <span class="pl-k">A</span>[count0<span class="pl-k">++</span>] <span class="pl-k">=</span> <span class="pl-c1">0</span>;
            }<span class="pl-k">else</span> <span class="pl-k">if</span>(<span class="pl-k">A</span>[i] <span class="pl-k">==</span> <span class="pl-c1">1</span>){
                <span class="pl-k">A</span>[i] <span class="pl-k">=</span> <span class="pl-c1">2</span>;
                <span class="pl-k">A</span>[count1<span class="pl-k">++</span>] <span class="pl-k">=</span> <span class="pl-c1">1</span>;
            }
        }

    }</pre></div>

<p><br></p>

<p><strong>Solution 3</strong>:</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">int</span>[] sortColors(<span class="pl-k">int</span>[] array) {
    <span class="pl-k">if</span> (array <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> array<span class="pl-k">.</span>length <span class="pl-k">&lt;=</span> <span class="pl-c1">1</span>) {
      <span class="pl-k">return</span> array;
    }
    <span class="pl-k">int</span> l <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">int</span> r <span class="pl-k">=</span> array<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>;
    <span class="pl-k">int</span> m <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">while</span> (m <span class="pl-k">&lt;</span> r) {
      <span class="pl-k">if</span> (array[m] <span class="pl-k">==</span> <span class="pl-c1">1</span>) {
        m<span class="pl-k">++</span>;
      } <span class="pl-k">else</span> <span class="pl-k">if</span> (array[m] <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
        swap(array, l<span class="pl-k">++</span>, m<span class="pl-k">++</span>);
      } <span class="pl-k">else</span> {
        swap(array, m, r<span class="pl-k">--</span>);
      }
    }
    <span class="pl-k">return</span> array;
    }
    <span class="pl-k">private</span> <span class="pl-k">void</span> swap(<span class="pl-k">int</span>[] array, <span class="pl-k">int</span> i, <span class="pl-k">int</span> j) {
      <span class="pl-k">int</span> temp <span class="pl-k">=</span> array[i];
      array[i] <span class="pl-k">=</span> array[j];
      array[j] <span class="pl-k">=</span> temp;
    }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-77-combinations" class="anchor" href="https://github.com/wishyouhappy/Algorithm#77-combinations" aria-hidden="true"><span class="octicon octicon-link"></span></a>77 Combinations</h3>

<blockquote>
<p>Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.</p>
</blockquote>

<pre>For example,
If n = 4 and k = 2, a solution is:

[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
</pre>

<p><strong>Idea</strong>: Same idea with combination sum, difference is that here we use k to determine the recursion termination condition</p>

<p><strong>Solution</strong>: Recursion</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> combine(<span class="pl-k">int</span> n, <span class="pl-k">int</span> k) {  
        <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>();  
        <span class="pl-k">if</span> (n <span class="pl-k">&lt;=</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> n <span class="pl-k">&lt;</span> k) {
            <span class="pl-k">return</span> res;
        }
        combine(n, k, <span class="pl-c1">1</span>, <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>(), res);  
        <span class="pl-k">return</span> res;  
    }  
    <span class="pl-k">private</span> <span class="pl-k">void</span> combine(<span class="pl-k">int</span> n, <span class="pl-k">int</span> k, <span class="pl-k">int</span> start, <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> item, <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> res)  {  
        <span class="pl-k">if</span> (item<span class="pl-k">.</span>size() <span class="pl-k">==</span> k) {  
            res<span class="pl-k">.</span>add(<span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>(item));  
            <span class="pl-k">return</span>;  
        }  
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> start; i <span class="pl-k">&lt;=</span> n; i<span class="pl-k">++</span>) {  
            item<span class="pl-k">.</span>add(i);  
            combine(n, k, i <span class="pl-k">+</span> <span class="pl-c1">1</span>, item, res);  
            item<span class="pl-k">.</span>remove(item<span class="pl-k">.</span>size() <span class="pl-k">-</span> <span class="pl-c1">1</span>);  
        }  
    } 
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-78-subsets" class="anchor" href="https://github.com/wishyouhappy/Algorithm#78-subsets" aria-hidden="true"><span class="octicon octicon-link"></span></a>78 Subsets</h3>

<blockquote>
<p>Given a set of distinct integers, nums, return all possible subsets.</p>

<p>Note:
Elements in a subset must be in non-descending order.
The solution set must not contain duplicate subsets.</p>
</blockquote>

<pre>For example,
If nums = [1,2,3], a solution is:

[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]

</pre>

<p><strong>Idea</strong>: </p>

<ul>
<li>Non-decsending order --sort the array first</li>
<li>step:

<ul>
<li>[]</li>
<li>[]     [1]</li>
<li>[] [1]       [2] [1, 2]</li>
<li>[] [1] [2] [1, 2]        [3] [1, 3] [2, 3] [1, 2, 3]</li>
</ul></li>
</ul>

<p>From the subsets creation steps above, you must find a way to solve this problem.
The Subset begin with [], after insert 1, it becomes [] [1], you need to combine the original [] and new created[1]. Then add [2] [3] by step. </p>

<p><strong>Attention</strong> : What is the time complexity of this problem? Note that the number of subsets increase exponentially.</p>

<p><strong>Iterative</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> subsets1(<span class="pl-k">int</span>[] nums) {
        <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>();
        res<span class="pl-k">.</span>add(<span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>());
        <span class="pl-k">if</span> (nums <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> nums<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> res;
        }
        <span class="pl-smi">Arrays</span><span class="pl-k">.</span>sort(nums);
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> nums<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
            <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> cur <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>();
            <span class="pl-k">for</span> (<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> l <span class="pl-k">:</span> res) {
                <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> temp <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>(l);
                temp<span class="pl-k">.</span>add(nums[i]);
                cur<span class="pl-k">.</span>add(temp);
            }
            res<span class="pl-k">.</span>addAll(cur);
        }
        <span class="pl-k">return</span> res;
    }

</pre></div>

<p><strong>Recursive</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> subsets(<span class="pl-k">int</span>[] nums) {
        <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>();
        res<span class="pl-k">.</span>add(<span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>());
        <span class="pl-k">if</span> (nums <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> nums<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> res;
        }
        <span class="pl-smi">Arrays</span><span class="pl-k">.</span>sort(nums);
        helper(nums, <span class="pl-c1">0</span>, res);
        <span class="pl-k">return</span> res;
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> helper(<span class="pl-k">int</span>[] nums, <span class="pl-k">int</span> start, <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> res) {
        <span class="pl-k">if</span> (start <span class="pl-k">==</span> nums<span class="pl-k">.</span>length) {
            <span class="pl-k">return</span>;
        }
        <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> cur <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>();
        <span class="pl-k">for</span> (<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> l <span class="pl-k">:</span> res) {
            <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> temp <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>(l);
            temp<span class="pl-k">.</span>add(nums[start]);
            cur<span class="pl-k">.</span>add(temp);
        }
        res<span class="pl-k">.</span>addAll(cur);
        helper(nums, start <span class="pl-k">+</span> <span class="pl-c1">1</span>, res);
    }</pre></div>

<p><br></p>

<p><strong>Similar DFS solution for string</strong>:</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> subSets(<span class="pl-smi">String</span> set) {
    <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">String</span>&gt;</span>();
    <span class="pl-k">if</span> (set <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span> res;
    }
    <span class="pl-k">char</span>[] arr <span class="pl-k">=</span> set<span class="pl-k">.</span>toCharArray();
    subSets(arr, <span class="pl-c1">0</span>, res, <span class="pl-k">new</span> <span class="pl-smi">StringBuilder</span>());
    <span class="pl-k">return</span> res;
  }

  <span class="pl-k">public</span> <span class="pl-k">void</span> subSets(<span class="pl-k">char</span>[] arr, <span class="pl-k">int</span> index, <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> res, <span class="pl-smi">StringBuilder</span> sb) {
    <span class="pl-k">if</span> (index <span class="pl-k">==</span> arr<span class="pl-k">.</span>length) {
      res<span class="pl-k">.</span>add(sb<span class="pl-k">.</span>toString());
      <span class="pl-k">return</span>;
    }
    subSets(arr, index <span class="pl-k">+</span> <span class="pl-c1">1</span>, res, sb);
    subSets(arr, index <span class="pl-k">+</span> <span class="pl-c1">1</span>, res, sb<span class="pl-k">.</span>append(arr[index]));
    sb<span class="pl-k">.</span>deleteCharAt(sb<span class="pl-k">.</span>length() <span class="pl-k">-</span> <span class="pl-c1">1</span>);
  }</pre></div>

<p><br></p>

<p><strong>Related</strong>: <strong>subsets of string</strong></p>

<blockquote>
<p>eg: Set = "abc":  [“”, “a”, “ab”, “abc”, “ac”, “b”, “bc”, “c”]</p>

<p>Set = "":  [""]</p>

<p>Set = null: []</p>
</blockquote>

<p><strong>Idea</strong>: Same with List. </p>

<p><strong>Solution</strong>:</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> subSets(<span class="pl-smi">String</span> set) {
    <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">String</span>&gt;</span>();
    <span class="pl-k">if</span> (set <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span> res;
    }
    res<span class="pl-k">.</span>add(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>);
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> set<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>) {
      <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> current <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">String</span>&gt;</span>();
      <span class="pl-k">char</span> c <span class="pl-k">=</span> set<span class="pl-k">.</span>charAt(i);
      <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;</span> res<span class="pl-k">.</span>size(); j<span class="pl-k">++</span>) {
         <span class="pl-smi">String</span> s <span class="pl-k">=</span> res<span class="pl-k">.</span>get(j);
         <span class="pl-smi">String</span> newS <span class="pl-k">=</span> concatenate(s, s<span class="pl-k">.</span>length(), c);
         current<span class="pl-k">.</span>add(newS);
      }
      res<span class="pl-k">.</span>addAll(current);
    }
    <span class="pl-k">return</span> res;
  }

  <span class="pl-k">public</span> <span class="pl-smi">String</span> concatenate(<span class="pl-smi">String</span> s, <span class="pl-k">int</span> i, <span class="pl-k">char</span> c) {
    <span class="pl-k">if</span> (s <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> s<span class="pl-k">.</span>length() <span class="pl-k">&lt;</span> i <span class="pl-k">||</span> i <span class="pl-k">&lt;</span> <span class="pl-c1">0</span>) {
      <span class="pl-k">return</span> <span class="pl-c1">null</span>;
    }
    <span class="pl-k">return</span> s<span class="pl-k">.</span>substring(<span class="pl-c1">0</span>, i) <span class="pl-k">+</span> c <span class="pl-k">+</span> s<span class="pl-k">.</span>substring(i, s<span class="pl-k">.</span>length());
  }</pre></div>

<p><br></p>

<p><strong>What if we treat "ac" and "ca"  different?</strong></p>

<p><strong>Idea</strong>: Add one more loop, insert each character to each possible index of the all existed strings.</p>

<p><strong>Solution</strong>:</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> subSets(<span class="pl-smi">String</span> set) {
    <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">String</span>&gt;</span>();
    <span class="pl-k">if</span> (set <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span> res;
    }
    res<span class="pl-k">.</span>add(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>);
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> set<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>) {
      <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> current <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">String</span>&gt;</span>();
      <span class="pl-k">char</span> c <span class="pl-k">=</span> set<span class="pl-k">.</span>charAt(i);
      <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;</span> res<span class="pl-k">.</span>size(); j<span class="pl-k">++</span>) {
         <span class="pl-smi">String</span> s <span class="pl-k">=</span> res<span class="pl-k">.</span>get(j);
         <span class="pl-k">for</span> (<span class="pl-k">int</span> k <span class="pl-k">=</span> <span class="pl-c1">0</span>; k <span class="pl-k">&lt;=</span> s<span class="pl-k">.</span>length(); k<span class="pl-k">++</span>) {
           <span class="pl-smi">String</span> newS <span class="pl-k">=</span> concatenate(s, k, c);
           current<span class="pl-k">.</span>add(newS);
         }
      }
      res<span class="pl-k">.</span>addAll(current);
    }
    <span class="pl-k">return</span> res;
  }

  <span class="pl-k">public</span> <span class="pl-smi">String</span> concatenate(<span class="pl-smi">String</span> s, <span class="pl-k">int</span> i, <span class="pl-k">char</span> c) {
    <span class="pl-k">if</span> (s <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> s<span class="pl-k">.</span>length() <span class="pl-k">&lt;</span> i <span class="pl-k">||</span> i <span class="pl-k">&lt;</span> <span class="pl-c1">0</span>) {
      <span class="pl-k">return</span> <span class="pl-c1">null</span>;
    }
    <span class="pl-k">return</span> s<span class="pl-k">.</span>substring(<span class="pl-c1">0</span>, i) <span class="pl-k">+</span> c <span class="pl-k">+</span> s<span class="pl-k">.</span>substring(i, s<span class="pl-k">.</span>length());
  }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-80-remove-duplicates-from-sorted-array-ii" class="anchor" href="https://github.com/wishyouhappy/Algorithm#80-remove-duplicates-from-sorted-array-ii" aria-hidden="true"><span class="octicon octicon-link"></span></a>80 Remove Duplicates From Sorted Array II</h3>

<blockquote>
<p>Follow up for "Remove Duplicates":</p>

<p>What if duplicates are allowed at most twice?</p>

<p>For example,</p>

<p>Given sorted array A = [1,1,1,2,2,3],</p>

<p>Your function should return length = 5, and A is now [1,1,2,2,3].</p>
</blockquote>

<p><strong>Idea</strong>: It's the same method with <a href="https://github.com/wishyouhappy/Algorithm#26-remove-duplicates-from-sorted-array">26 Remove Duplicates from Sorted Array</a>. Only diffence is that we need to compare with previous and previous previous element. </p>

<p><strong>Java Code</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> removeDuplicates(<span class="pl-k">int</span>[] <span class="pl-smi">A</span>) {
        <span class="pl-k">if</span>(<span class="pl-smi">A</span> <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        <span class="pl-k">if</span>(<span class="pl-smi">A</span><span class="pl-k">.</span>length <span class="pl-k">&lt;=</span> <span class="pl-c1">2</span>) <span class="pl-k">return</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length;
        <span class="pl-k">int</span> count <span class="pl-k">=</span> <span class="pl-c1">2</span>;
        <span class="pl-k">int</span> pre <span class="pl-k">=</span> <span class="pl-k">A</span>[<span class="pl-c1">1</span>];
        <span class="pl-k">int</span> prepre <span class="pl-k">=</span> <span class="pl-k">A</span>[<span class="pl-c1">0</span>];
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">2</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length; i<span class="pl-k">++</span>){
            <span class="pl-k">if</span>(<span class="pl-k">A</span>[i] <span class="pl-k">==</span> pre <span class="pl-k">&amp;&amp;</span> <span class="pl-k">A</span>[i] <span class="pl-k">==</span> prepre) <span class="pl-k">continue</span>;
            <span class="pl-k">A</span>[count<span class="pl-k">++</span>] <span class="pl-k">=</span> <span class="pl-k">A</span>[i];
            prepre <span class="pl-k">=</span> pre;
            pre <span class="pl-k">=</span> <span class="pl-k">A</span>[i];
        }
        <span class="pl-k">return</span> count;
    }

</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-81-search-in-rotated-sorted-array-ii" class="anchor" href="https://github.com/wishyouhappy/Algorithm#81-search-in-rotated-sorted-array-ii" aria-hidden="true"><span class="octicon octicon-link"></span></a>81 Search in Rotated Sorted Array II</h3>

<blockquote>
<p>Follow up for "Search in Rotated Sorted Array":
<strong>What if duplicates are allowed?</strong></p>

<p>Would this affect the run-time complexity? How and why?</p>

<p>Write a function to determine if a given target is in the array.</p>
</blockquote>

<p><strong>Idea</strong>: In * <a href="https://github.com/wishyouhappy/Algorithm#33-search-in-rotated-sorted-array">33 Search in Rotated Sorted Array</a>, we can make sure that each time we cut half of the array, thus the totla time complexity is O(lgn). In this problem, since the existence of dulicates, thus the A[mid] might equals to A[l] and A[r]. From this information, we don't know which half we should go. Thus the worst case would be <strong>O(n)</strong> </p>

<p>How to solve this problem? We can use the second method in * <a href="https://github.com/wishyouhappy/Algorithm#33-search-in-rotated-sorted-array">33 Search in Rotated Sorted Array</a>. If we can not find an increasing  interval of A[l]-A[mid] and A[mid]-A[r], we can just move one step right or one step left by l++ or r--</p>

<p>*<em>Solution 1 
*</em>:</p>

<div class="highlight highlight-java"><pre> <span class="pl-k">public</span> <span class="pl-k">boolean</span> search(<span class="pl-k">int</span>[] <span class="pl-smi">A</span>, <span class="pl-k">int</span> target) {
        <span class="pl-k">if</span>(<span class="pl-smi">A</span> <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        <span class="pl-k">int</span> l <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> r <span class="pl-k">=</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length<span class="pl-k">-</span><span class="pl-c1">1</span>;
        <span class="pl-k">while</span>(l <span class="pl-k">&lt;=</span> r){
           <span class="pl-k">int</span> mid <span class="pl-k">=</span> l <span class="pl-k">+</span> (r <span class="pl-k">-</span> l) <span class="pl-k">/</span> <span class="pl-c1">2</span>;
           <span class="pl-k">if</span> (<span class="pl-k">A</span>[mid] <span class="pl-k">==</span> target) {
               <span class="pl-k">return</span> <span class="pl-c1">true</span>;
           } <span class="pl-k">else</span> <span class="pl-k">if</span> (<span class="pl-k">A</span>[mid] <span class="pl-k">&gt;</span> <span class="pl-k">A</span>[l]) {
               <span class="pl-k">if</span> (<span class="pl-k">A</span>[l] <span class="pl-k">&lt;=</span> target <span class="pl-k">&amp;&amp;</span> <span class="pl-k">A</span>[mid] <span class="pl-k">&gt;</span> target) {
                   r <span class="pl-k">=</span> mid <span class="pl-k">-</span> <span class="pl-c1">1</span>;
               } <span class="pl-k">else</span> {
                   l <span class="pl-k">=</span> mid <span class="pl-k">+</span> <span class="pl-c1">1</span>;
               }
           } <span class="pl-k">else</span> <span class="pl-k">if</span> (<span class="pl-k">A</span>[mid] <span class="pl-k">&lt;</span> <span class="pl-k">A</span>[l]){
               <span class="pl-k">if</span> (<span class="pl-k">A</span>[mid] <span class="pl-k">&lt;</span> target <span class="pl-k">&amp;&amp;</span> <span class="pl-k">A</span>[r] <span class="pl-k">&gt;=</span> target) {
                   l <span class="pl-k">=</span> mid <span class="pl-k">+</span> <span class="pl-c1">1</span>;
               } <span class="pl-k">else</span> {
                   r <span class="pl-k">=</span> mid <span class="pl-k">-</span> <span class="pl-c1">1</span>;
               }
           } <span class="pl-k">else</span> {
            l<span class="pl-k">++</span>;
           }
        } 
        <span class="pl-k">return</span> <span class="pl-c1">false</span>;
    }
</pre></div>

<p><strong>Solution 2</strong>:  Even though in worst cast this solution is same with solution 1, in saome cases solution 1 has better time complexity</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">boolean</span> search(<span class="pl-k">int</span>[] <span class="pl-smi">A</span>, <span class="pl-k">int</span> target) {
        <span class="pl-k">if</span>(<span class="pl-smi">A</span> <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        <span class="pl-k">int</span> l <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> r <span class="pl-k">=</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length<span class="pl-k">-</span><span class="pl-c1">1</span>;
        <span class="pl-k">while</span>(l <span class="pl-k">&lt;=</span> r){
            <span class="pl-k">int</span> mid <span class="pl-k">=</span> (l<span class="pl-k">+</span>r)<span class="pl-k">/</span><span class="pl-c1">2</span>;
            <span class="pl-k">if</span>(<span class="pl-k">A</span>[mid] <span class="pl-k">==</span> target) {
                <span class="pl-k">return</span> <span class="pl-c1">true</span>;
            } <span class="pl-k">else</span> <span class="pl-k">if</span>(<span class="pl-k">A</span>[mid] <span class="pl-k">&gt;</span> target <span class="pl-k">&amp;&amp;</span> <span class="pl-k">A</span>[mid] <span class="pl-k">&lt;</span> <span class="pl-k">A</span>[r]) {
                r <span class="pl-k">=</span> mid<span class="pl-k">-</span><span class="pl-c1">1</span>;
            } <span class="pl-k">else</span> <span class="pl-k">if</span>(<span class="pl-k">A</span>[mid] <span class="pl-k">&lt;</span> target <span class="pl-k">&amp;&amp;</span> <span class="pl-k">A</span>[mid] <span class="pl-k">&gt;</span> <span class="pl-k">A</span>[l]) {
                l <span class="pl-k">=</span> mid <span class="pl-k">+</span> <span class="pl-c1">1</span>;
            } <span class="pl-k">else</span> <span class="pl-k">if</span> (<span class="pl-k">A</span>[l] <span class="pl-k">!=</span> target) {
                l<span class="pl-k">++</span>;
            } <span class="pl-k">else</span> {
                <span class="pl-k">return</span> <span class="pl-c1">true</span>;
            }
        }
        <span class="pl-k">return</span> <span class="pl-c1">false</span>;
    }

</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-82-remove-duplicates-from-sorted-list" class="anchor" href="https://github.com/wishyouhappy/Algorithm#82-remove-duplicates-from-sorted-list" aria-hidden="true"><span class="octicon octicon-link"></span></a>82 Remove Duplicates from Sorted List</h3>

<blockquote>
<p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p>
</blockquote>

<p>For example,
Given 1-&gt;1-&gt;2, return 1-&gt;2.
Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3.</p>

<p><strong>Idea</strong>: It's simple compare to * <a href="https://github.com/wishyouhappy/Algorithm#83-remove-duplicates-from-sorted-list-ii">83 Remove Duplicates from Sorted List II</a>. Because there are less corner cases related to null pointers. Just if head != null, start from the head.next, when encounter duplicates, delete that node. </p>

<div class="highlight highlight-java"><pre>   <span class="pl-k">public</span> <span class="pl-smi">ListNode</span> deleteDuplicates(<span class="pl-smi">ListNode</span> head) {
        <span class="pl-k">if</span>(head <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">return</span> <span class="pl-c1">null</span>;
        <span class="pl-smi">ListNode</span> pre <span class="pl-k">=</span> head;
        <span class="pl-smi">ListNode</span> temp <span class="pl-k">=</span> head<span class="pl-k">.</span>next;
        <span class="pl-k">while</span>(temp <span class="pl-k">!=</span> <span class="pl-c1">null</span>){
            <span class="pl-k">if</span>(temp<span class="pl-k">.</span>val <span class="pl-k">==</span> pre<span class="pl-k">.</span>val) {
                pre<span class="pl-k">.</span>next <span class="pl-k">=</span> temp<span class="pl-k">.</span>next;
                temp <span class="pl-k">=</span> temp<span class="pl-k">.</span>next;
            }<span class="pl-k">else</span>{
                pre <span class="pl-k">=</span> temp;
                temp <span class="pl-k">=</span> temp<span class="pl-k">.</span>next;
            }
        }
        <span class="pl-k">return</span> head;
    }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-83-remove-duplicates-from-sorted-list-ii" class="anchor" href="https://github.com/wishyouhappy/Algorithm#83-remove-duplicates-from-sorted-list-ii" aria-hidden="true"><span class="octicon octicon-link"></span></a>83 Remove Duplicates from Sorted List II</h3>

<blockquote>
<p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.</p>
</blockquote>

<pre>For example,
Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.
Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3.
</pre>

<p><strong>Idea</strong>:</p>

<p>1) Compare each node with it's next, count++ if duplicate is found. if head.val != head.next.val, then check if count == 1. If yes, add node, else reset head to 1 and  continue.</p>

<p><strong>Attention</strong>: Remember to check count at the end. If count == 1, add the last node. else set result's tail.next = null. </p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-smi">ListNode</span> deleteDuplicates(<span class="pl-smi">ListNode</span> head) {
        <span class="pl-k">if</span>(head <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">return</span> head;
        <span class="pl-smi">ListNode</span> feakHead <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">ListNode</span>(<span class="pl-k">-</span><span class="pl-c1">1</span>);
        <span class="pl-smi">ListNode</span> h1 <span class="pl-k">=</span> feakHead;
        <span class="pl-k">int</span> count <span class="pl-k">=</span> <span class="pl-c1">1</span>;
        <span class="pl-k">while</span>(head <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> head<span class="pl-k">.</span>next <span class="pl-k">!=</span> <span class="pl-c1">null</span>){
            <span class="pl-k">if</span>(head<span class="pl-k">.</span>val <span class="pl-k">==</span> head<span class="pl-k">.</span>next<span class="pl-k">.</span>val){
                head <span class="pl-k">=</span> head<span class="pl-k">.</span>next;
                count<span class="pl-k">++</span>;
            }<span class="pl-k">else</span>{
                <span class="pl-k">if</span>(count <span class="pl-k">==</span> <span class="pl-c1">1</span>){
                    h1<span class="pl-k">.</span>next <span class="pl-k">=</span> head;
                    head <span class="pl-k">=</span> head<span class="pl-k">.</span>next;
                    h1 <span class="pl-k">=</span> h1<span class="pl-k">.</span>next;
                }<span class="pl-k">else</span>{
                    head <span class="pl-k">=</span> head<span class="pl-k">.</span>next;
                    count <span class="pl-k">=</span> <span class="pl-c1">1</span>;
                }
            }
        }
        <span class="pl-k">if</span>(count <span class="pl-k">==</span> <span class="pl-c1">1</span>) h1<span class="pl-k">.</span>next <span class="pl-k">=</span> head;
        <span class="pl-k">else</span> h1<span class="pl-k">.</span>next <span class="pl-k">=</span> <span class="pl-c1">null</span>;
        <span class="pl-k">return</span> feakHead<span class="pl-k">.</span>next;
    }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-86-partition-list" class="anchor" href="https://github.com/wishyouhappy/Algorithm#86-partition-list" aria-hidden="true"><span class="octicon octicon-link"></span></a>86 Partition List</h3>

<blockquote>
<p>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</p>
</blockquote>

<p>You should <strong>preserve the original relative order</strong> of the nodes in each of the two partitions.</p>

<pre>For example,
Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,
return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5.
</pre>

<p><strong>Idea</strong>: We need to preserve the original order, thus we can maintain two pointers, h1 and tail. h1 is the place we need to insert the element which smaller than x. tail is the end of the result list from which we add the elements equal or larger than x. </p>

<p><strong>Attention</strong>: We need to </p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-smi">ListNode</span> partition(<span class="pl-smi">ListNode</span> head, <span class="pl-k">int</span> x) {
        <span class="pl-k">if</span> (head <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">null</span>;
        }
        <span class="pl-smi">ListNode</span> feakHead <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">ListNode</span>(<span class="pl-k">-</span><span class="pl-c1">1</span>);
        <span class="pl-smi">ListNode</span> h <span class="pl-k">=</span> feakHead;
        <span class="pl-smi">ListNode</span> tail <span class="pl-k">=</span> feakHead;
        <span class="pl-k">while</span> (head <span class="pl-k">!=</span> <span class="pl-c1">null</span>){
            <span class="pl-k">if</span> (head<span class="pl-k">.</span>val <span class="pl-k">&gt;=</span> x) {
                tail<span class="pl-k">.</span>next <span class="pl-k">=</span> head;
                head <span class="pl-k">=</span> head<span class="pl-k">.</span>next;
                tail <span class="pl-k">=</span> tail<span class="pl-k">.</span>next;
                tail<span class="pl-k">.</span>next <span class="pl-k">=</span> <span class="pl-c1">null</span>;
            } <span class="pl-k">else</span>{
                 <span class="pl-smi">ListNode</span> saveH <span class="pl-k">=</span> h;
                 <span class="pl-smi">ListNode</span> temp <span class="pl-k">=</span> h<span class="pl-k">.</span>next;
                 h<span class="pl-k">.</span>next <span class="pl-k">=</span> head;
                 head <span class="pl-k">=</span> head<span class="pl-k">.</span>next;
                 h <span class="pl-k">=</span> h<span class="pl-k">.</span>next;
                 h<span class="pl-k">.</span>next <span class="pl-k">=</span> temp;
                 <span class="pl-k">if</span> (tail<span class="pl-k">.</span>equals(saveH)) {
                    tail <span class="pl-k">=</span> h;
                 }
            }
        }
        <span class="pl-k">return</span> feakHead<span class="pl-k">.</span>next;
    }
</pre></div>

<p><strong>Another solution</strong>: much similar to the first one</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-smi">ListNode</span> partition(<span class="pl-smi">ListNode</span> head, <span class="pl-k">int</span> target) {
    <span class="pl-c">// write your solution here</span>
    <span class="pl-k">if</span> (head <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> head<span class="pl-k">.</span>next <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span> head;
    }
    <span class="pl-smi">ListNode</span> fakeHead1 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">ListNode</span>(<span class="pl-k">-</span><span class="pl-c1">1</span>);
    <span class="pl-smi">ListNode</span> fakeHead2 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">ListNode</span>(<span class="pl-k">-</span><span class="pl-c1">1</span>);
    <span class="pl-smi">ListNode</span> smaller <span class="pl-k">=</span> fakeHead1; <span class="pl-c">// position to insert elements smaller than target</span>
    <span class="pl-smi">ListNode</span> larger <span class="pl-k">=</span> fakeHead2; <span class="pl-c">// position to insert elements larger than target</span>
    <span class="pl-smi">ListNode</span> temp <span class="pl-k">=</span> head;
    <span class="pl-k">while</span> (temp <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
      <span class="pl-smi">ListNode</span> next <span class="pl-k">=</span> temp<span class="pl-k">.</span>next;
      temp<span class="pl-k">.</span>next <span class="pl-k">=</span> <span class="pl-c1">null</span>;
      <span class="pl-k">if</span> (temp<span class="pl-k">.</span>value <span class="pl-k">&lt;</span> target) {
        smaller<span class="pl-k">.</span>next <span class="pl-k">=</span> temp;
        smaller <span class="pl-k">=</span> smaller<span class="pl-k">.</span>next;
      } <span class="pl-k">else</span> {
        larger<span class="pl-k">.</span>next <span class="pl-k">=</span> temp;
        larger <span class="pl-k">=</span> larger<span class="pl-k">.</span>next;
      }
      temp <span class="pl-k">=</span> next;
    }
    smaller<span class="pl-k">.</span>next <span class="pl-k">=</span> fakeHead2<span class="pl-k">.</span>next;
    <span class="pl-k">return</span> fakeHead1<span class="pl-k">.</span>next;
  }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-89-gray-code" class="anchor" href="https://github.com/wishyouhappy/Algorithm#89-gray-code" aria-hidden="true"><span class="octicon octicon-link"></span></a>89 Gray Code</h3>

<blockquote>
<p>The gray code is a binary numeral system where two successive values differ in only one bit.</p>

<p>Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.</p>

<p>For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:</p>

<p>00 - 0</p>

<p>01 - 1</p>

<p>11 - 3</p>

<p>10 - 2</p>

<p>Note:
For a given n, a gray code sequence is not uniquely defined.</p>

<p>For example, [0,2,3,1] is also a valid gray code sequence according to the above definition.</p>

<p>For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.</p>
</blockquote>

<p>Let's first see a few example of gray code and find the laws to create gray code</p>

<pre><code>n = 1: 0 
       1

n = 2: 00 
       01
       11
       10

n = 3: 000
       001
       011
       010
       110
       111
       101
       100

 n = 4: 0000
        0001
        0011
        0010
        0110
        0111
        0101
        0100
        1100
        1101
        1111
        1110
        1010
        1011
        1001
        1000
</code></pre>

<p><strong>Some laws from above</strong> : we can find that the first half of  2 ^ n numbers could be create by add a 0 to 2 ^ (n-1) numbers. For the last half of 2 ^ n, we can add 1 to the reversed order number of 2 ^ (n-1). </p>

<p>For example, based on 2 bit gray code, we can get the first half of 3 bit gray code by adding 0, eg: 000 001 011 010, for the last half, we first reverse the order 10, 11, 01, 00, then add 1 to each of them, we can get 110 111 101 100.</p>

<p><strong>Time Complexity</strong>: we have 2 ^ n gray code numbers, thus the time complexity is 2 ^ n
<strong>Space</strong>: 2 ^ n</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> grayCode(<span class="pl-k">int</span> n) {
        <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> list <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
        <span class="pl-k">if</span>(n <span class="pl-k">&lt;</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> list;
        list<span class="pl-k">.</span>add(<span class="pl-c1">0</span>);
        <span class="pl-k">if</span>(n <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> list;
        list<span class="pl-k">.</span>add(<span class="pl-c1">1</span>);
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">2</span>; i <span class="pl-k">&lt;=</span> n; i<span class="pl-k">++</span>){
            <span class="pl-k">for</span>(<span class="pl-k">int</span> j <span class="pl-k">=</span> list<span class="pl-k">.</span>size()<span class="pl-k">-</span><span class="pl-c1">1</span>; j <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>; j<span class="pl-k">--</span>){
                list<span class="pl-k">.</span>add(list<span class="pl-k">.</span>get(j) <span class="pl-k">+</span> (<span class="pl-c1">1</span> <span class="pl-k">&lt;&lt;</span>(i<span class="pl-k">-</span><span class="pl-c1">1</span>)));
            }
        }
        <span class="pl-k">return</span> list;
     }</pre></div>

<p><strong>Related Questions</strong> : check if two bytes can be put successively in a gray code sequence.</p>

<p><strong>Idea</strong>: we know that the neighbor gray code numbers is different with 1 bit. We need to check if these two numbers have only one bit diffenence.</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">boolean</span> isSuccesive(<span class="pl-k">byte</span> b1, <span class="pl-k">byte</span> b2){
        <span class="pl-k">int</span> count <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">while</span>(b1 <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> b2 <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>){
            <span class="pl-k">if</span>((b1 <span class="pl-k">&amp;</span> <span class="pl-c1">1</span>) <span class="pl-k">!=</span> (b2 <span class="pl-k">&amp;</span> <span class="pl-c1">1</span>))
                count<span class="pl-k">++</span>;
            b1 <span class="pl-k">&gt;&gt;&gt;</span><span class="pl-k">=</span> <span class="pl-c1">1</span>;
            b2 <span class="pl-k">&gt;&gt;&gt;</span><span class="pl-k">=</span> <span class="pl-c1">1</span>;
        }
        <span class="pl-k">return</span> count <span class="pl-k">==</span> <span class="pl-c1">1</span>;
    }</pre></div>

<p>If the numbers are unsigned numbers, we can first ^ then check if it is the power of 2</p>

<div class="highlight highlight-java"><pre>    temp <span class="pl-k">=</span> b1 <span class="pl-k">^</span> b2;

    <span class="pl-k">return</span> (temp <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>) <span class="pl-k">&amp;&amp;</span> ((temp <span class="pl-k">&amp;</span> <span class="pl-k">-</span>temp) <span class="pl-k">==</span> temp); 

    <span class="pl-k">return</span> (temp <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>) <span class="pl-k">&amp;&amp;</span> ((temp <span class="pl-k">&amp;</span> (temp <span class="pl-k">-</span><span class="pl-c1">1</span>)) <span class="pl-k">==</span> <span class="pl-c1">0</span>);
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-90-subsets-ii" class="anchor" href="https://github.com/wishyouhappy/Algorithm#90-subsets-ii" aria-hidden="true"><span class="octicon octicon-link"></span></a>90 Subsets II</h3>

<blockquote>
<p>Given a collection of integers that might contain duplicates, nums, return all possible subsets.</p>
</blockquote>

<pre>Note:
Elements in a subset must be in non-descending order.
The solution set must not contain duplicate subsets.
For example,
If nums = [1,2,2], a solution is:

[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
</pre>

<p><strong>Idea</strong>: The different with * <a href="https://github.com/wishyouhappy/Algorithm#78-subsets">78 Subsets</a> is that in this problem the nums might contain duplicates.</p>

<p>How to handle duplicates? </p>

<p>Consider the above case [1, 2, 2], then the steps are below:</p>

<ul>
<li>[]</li>
<li>[]      [1]</li>
<li>[][1]   [2][1,2]</li>
<li>[][1][2][1,2]  [2,2][1, 2, 2]</li>
</ul>

<p>You might make a mistake that if duplicates occur, we just need to insert new element into the last half of the pre subsets. This seems true at first glance. </p>

<p>Consider the case [2, 2, 2, 2, 2]</p>

<ul>
<li>[] </li>
<li>[]   [2]</li>
<li>[][2]   [2,2]</li>
<li>[][2][2,2]   [2,2,2]</li>
<li>[][2][2,2][2,2,2]    [2,2,2,2]</li>
<li>.......</li>
</ul>

<p>Actually, the start position we need to insert is the size of the prev subsets result. </p>

<p>Here are he solutions.</p>

<p><strong>Iterative</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> subsetsWithDup(<span class="pl-k">int</span>[] nums) {
        <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>();
        res<span class="pl-k">.</span>add(<span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>());
        <span class="pl-k">if</span> (nums <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> nums<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> res;
        }
        <span class="pl-smi">Arrays</span><span class="pl-k">.</span>sort(nums);
        <span class="pl-k">int</span> prevSize <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> nums<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
            <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> cur <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>();
            <span class="pl-k">int</span> startPos <span class="pl-k">=</span> <span class="pl-c1">0</span>;
            <span class="pl-k">if</span> (i <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> nums[i] <span class="pl-k">==</span> nums[i<span class="pl-k">-</span><span class="pl-c1">1</span>]) {
                startPos <span class="pl-k">=</span> prevSize;
            } 
           <span class="pl-k">for</span> (;startPos<span class="pl-k">&lt;</span> res<span class="pl-k">.</span>size(); startPos<span class="pl-k">++</span>) {
                <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> temp <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>(res<span class="pl-k">.</span>get(startPos));
                temp<span class="pl-k">.</span>add(nums[i]);
                cur<span class="pl-k">.</span>add(temp);
            }
            prevSize <span class="pl-k">=</span> res<span class="pl-k">.</span>size();
            res<span class="pl-k">.</span>addAll(cur);
        }
        <span class="pl-k">return</span> res;
    }</pre></div>

<p><strong>Resursion</strong>:</p>

<div class="highlight highlight-java"><pre> <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> subsetsWithDup(<span class="pl-k">int</span>[] nums) {
            <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>();
            res<span class="pl-k">.</span>add(<span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>());
            <span class="pl-k">if</span> (nums <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> nums<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
                <span class="pl-k">return</span> res;
            }
            <span class="pl-smi">Arrays</span><span class="pl-k">.</span>sort(nums);
            helper(nums, <span class="pl-c1">0</span>, res, <span class="pl-c1">0</span>);
            <span class="pl-k">return</span> res;
        }

        <span class="pl-k">public</span> <span class="pl-k">void</span> helper(<span class="pl-k">int</span>[] nums, <span class="pl-k">int</span> start, <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> res, <span class="pl-k">int</span> lastSize) {
            <span class="pl-k">if</span> (start <span class="pl-k">==</span> nums<span class="pl-k">.</span>length) {
                <span class="pl-k">return</span>;
            }
            <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> cur <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>();
            <span class="pl-k">int</span> insertPos <span class="pl-k">=</span> <span class="pl-c1">0</span>;
            <span class="pl-k">if</span> (start <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> nums[start] <span class="pl-k">==</span> nums[start<span class="pl-k">-</span><span class="pl-c1">1</span>]) {
                insertPos <span class="pl-k">=</span> lastSize;
            }
            <span class="pl-k">for</span> (; insertPos <span class="pl-k">&lt;</span> res<span class="pl-k">.</span>size(); insertPos<span class="pl-k">++</span>) {
                <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> temp <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>(res<span class="pl-k">.</span>get(insertPos));
                temp<span class="pl-k">.</span>add(nums[start]);
                cur<span class="pl-k">.</span>add(temp);
            }
            lastSize <span class="pl-k">=</span> res<span class="pl-k">.</span>size();
            res<span class="pl-k">.</span>addAll(cur);
            helper(nums, start <span class="pl-k">+</span> <span class="pl-c1">1</span>, res, lastSize);
        }

</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-92-reverse-linked-list-ii" class="anchor" href="https://github.com/wishyouhappy/Algorithm#92-reverse-linked-list-ii" aria-hidden="true"><span class="octicon octicon-link"></span></a>92 Reverse Linked List II</h3>

<blockquote>
<p>Reverse a linked list from position m to n. Do it in-place and in one-pass.</p>
</blockquote>

<pre>For example:
Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4,

return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL.

Note:
Given m, n satisfy the following condition:
1 ≤ m ≤ n ≤ length of list.
    
</pre>

<p><strong>Idea</strong>: 1) Find begining node of reverse. 2) reverse m-n 3) concatenate </p>

<p><strong>Attention</strong>:</p>

<ul>
<li>1) when concatenate, take care of null pointer. <strong><em>(When use node.next, always check if node is null)</em></strong></li>
<li>2) If m == 1, what should we return? So check the previous node of the reverse list's head, if it's null, just return the reverse head. </li>
<li>3) Take care of the steps. We need to move <strong><em>m-1</em></strong> steps to find the beginning of the reverse. We need take another <strong><em>n-m+1</em></strong> steps to reverse the nodes. </li>
</ul>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-smi">ListNode</span> reverseBetween1(<span class="pl-smi">ListNode</span> head, <span class="pl-k">int</span> m, <span class="pl-k">int</span> n) {
        <span class="pl-k">if</span>(head <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> head<span class="pl-k">.</span>next <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> (m <span class="pl-k">==</span> n)) <span class="pl-k">return</span> head;
        <span class="pl-smi">ListNode</span> saveHead <span class="pl-k">=</span> head;
        <span class="pl-smi">ListNode</span> preReverse <span class="pl-k">=</span> <span class="pl-c1">null</span>;
        <span class="pl-k">while</span>(m<span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>){
            preReverse <span class="pl-k">=</span> head;
            head <span class="pl-k">=</span> head<span class="pl-k">.</span>next;
            m<span class="pl-k">--</span>;
            n<span class="pl-k">--</span>;
        }
        <span class="pl-smi">ListNode</span> reverseHead <span class="pl-k">=</span> <span class="pl-c1">null</span>;
        <span class="pl-smi">ListNode</span> reverseTail <span class="pl-k">=</span> <span class="pl-c1">null</span>;
        <span class="pl-smi">ListNode</span> next <span class="pl-k">=</span> <span class="pl-c1">null</span>;
        <span class="pl-k">while</span>(n<span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>){
            n<span class="pl-k">--</span>;
            <span class="pl-k">if</span>(reverseHead <span class="pl-k">==</span> <span class="pl-c1">null</span>){
                reverseHead <span class="pl-k">=</span> head;
                reverseTail <span class="pl-k">=</span> head;
                head <span class="pl-k">=</span> head<span class="pl-k">.</span>next;
                <span class="pl-k">continue</span>;
            }
            next <span class="pl-k">=</span> head<span class="pl-k">.</span>next;
            head<span class="pl-k">.</span>next <span class="pl-k">=</span> reverseHead;
            reverseHead <span class="pl-k">=</span> head;
            head <span class="pl-k">=</span> next;
        }
        <span class="pl-k">if</span>(preReverse <span class="pl-k">!=</span> <span class="pl-c1">null</span>) preReverse<span class="pl-k">.</span>next <span class="pl-k">=</span> reverseHead;
        <span class="pl-k">if</span>(reverseTail <span class="pl-k">!=</span> <span class="pl-c1">null</span>) reverseTail<span class="pl-k">.</span>next <span class="pl-k">=</span> head;
        <span class="pl-k">if</span>(preReverse <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">return</span> reverseHead;
        <span class="pl-k">return</span> saveHead;
      }</pre></div>

<p><br></p>

<p>Pretty much the save with the above, just change while to for:</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-smi">ListNode</span> reverseBetween(<span class="pl-smi">ListNode</span> head, <span class="pl-k">int</span> m, <span class="pl-k">int</span> n) {
        <span class="pl-k">if</span>(head <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">return</span> <span class="pl-c1">null</span>;
        <span class="pl-k">if</span>(m <span class="pl-k">&lt;</span> <span class="pl-c1">0</span>) m <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">if</span>(m <span class="pl-k">&gt;</span> n){
            <span class="pl-k">int</span> tempValue <span class="pl-k">=</span> m;
            m <span class="pl-k">=</span> n;
            n <span class="pl-k">=</span> tempValue;
        }

        <span class="pl-smi">ListNode</span> temp <span class="pl-k">=</span> head;
        <span class="pl-smi">ListNode</span> previousM <span class="pl-k">=</span> <span class="pl-c1">null</span>;

        <span class="pl-c">/* find node at m */</span>
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;</span> m <span class="pl-k">&amp;&amp;</span> temp <span class="pl-k">!=</span> <span class="pl-c1">null</span>; i<span class="pl-k">++</span>){
            previousM <span class="pl-k">=</span> temp;
            temp <span class="pl-k">=</span> temp<span class="pl-k">.</span>next;
        }
        <span class="pl-smi">ListNode</span> saveTemp <span class="pl-k">=</span> temp;

        <span class="pl-c">/* reverse node between m and n */</span>
        <span class="pl-smi">ListNode</span> pre <span class="pl-k">=</span> <span class="pl-c1">null</span>;
        <span class="pl-smi">ListNode</span> next <span class="pl-k">=</span> <span class="pl-c1">null</span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> m; i <span class="pl-k">&lt;=</span> n <span class="pl-k">&amp;&amp;</span> temp <span class="pl-k">!=</span> <span class="pl-c1">null</span>; i<span class="pl-k">++</span>){
            next <span class="pl-k">=</span> temp<span class="pl-k">.</span>next;
            temp<span class="pl-k">.</span>next <span class="pl-k">=</span> pre;
            pre <span class="pl-k">=</span> temp;
            temp <span class="pl-k">=</span> next;
        }

        <span class="pl-c">/* concatenate */</span>
        <span class="pl-k">if</span>(previousM <span class="pl-k">!=</span> <span class="pl-c1">null</span>) previousM<span class="pl-k">.</span>next <span class="pl-k">=</span> pre;
        <span class="pl-k">if</span>(saveTemp <span class="pl-k">!=</span> <span class="pl-c1">null</span>) saveTemp<span class="pl-k">.</span>next <span class="pl-k">=</span> temp;

        <span class="pl-k">if</span>(m <span class="pl-k">==</span> <span class="pl-c1">1</span>) <span class="pl-k">return</span> pre; 
        <span class="pl-k">return</span> head;
     }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-94-binary-tree-inorder-traversal" class="anchor" href="https://github.com/wishyouhappy/Algorithm#94-binary-tree-inorder-traversal" aria-hidden="true"><span class="octicon octicon-link"></span></a>94 Binary Tree Inorder Traversal</h3>

<blockquote>
<p>Given a binary tree, return the inorder traversal of its nodes' values.</p>
</blockquote>

<pre>For example:
Given binary tree {1,#,2,3},
   1
    \
     2
    /
   3
return [1,3,2].

</pre>

<blockquote>
<p>Note: Recursive solution is trivial, could you do it iteratively?</p>
</blockquote>

<p><strong>Idea</strong>: </p>

<ul>
<li><p>1) Solution 1: Recursion. It's the simplest method. Just visit in left, root, right order.</p></li>
<li><p>2) Solution 2: Iterative. Use a stack to record the parant node, so we can go to it and its right child after visit its left child.</p></li>
<li><p>3) Solution 3 : Morris Traversal. Use a pointer to go back to its parent after visit it's left child. Note that use this method we only need O(1) space. Want to know more about Morris traversal click on this link. <a href="http://wishyouhappy.github.io/2014/12/17/morris%20traversal-traverse%20a%20binary%20tree%20without%20stack/">Morris Traversal</a>. </p></li>
</ul>

<p><strong>Solution 1, Recursion</strong>:</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> inorderTraversal(<span class="pl-smi">TreeNode</span> root) {
    <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
        <span class="pl-k">return</span> res;
    }
    inorderTraversal(root, res);
    <span class="pl-k">return</span> res;
}
<span class="pl-k">public</span> <span class="pl-k">void</span> inorderTraversal(<span class="pl-smi">TreeNode</span> root, <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> res) {
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
        <span class="pl-k">return</span>;
    }
    inorderTraversal(root<span class="pl-k">.</span>left, res);
    res<span class="pl-k">.</span>add(root<span class="pl-k">.</span>val);
    inorderTraversal(root<span class="pl-k">.</span>right, res);
}</pre></div>

<p><strong>Solution 2, Iterative</strong>:</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> inorderTraversal(<span class="pl-smi">TreeNode</span> root) {
    <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
        <span class="pl-k">return</span> res;
    }
    <span class="pl-k">Stack&lt;<span class="pl-smi">TreeNode</span>&gt;</span> stack <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">Stack&lt;<span class="pl-smi">TreeNode</span>&gt;</span>();
    <span class="pl-k">while</span> (root <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> <span class="pl-k">!</span>stack<span class="pl-k">.</span>isEmpty()) {
        <span class="pl-k">if</span> (root <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
            stack<span class="pl-k">.</span>push(root);
            root <span class="pl-k">=</span> root<span class="pl-k">.</span>left;
        } <span class="pl-k">else</span> {
            root <span class="pl-k">=</span> stack<span class="pl-k">.</span>pop();
            res<span class="pl-k">.</span>add(root<span class="pl-k">.</span>val);
            root <span class="pl-k">=</span> root<span class="pl-k">.</span>right;
        }
    }
    <span class="pl-k">return</span> res;
}</pre></div>

<p><strong>Solution 3: Morris Traversal</strong>:</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> inorderTraversal(<span class="pl-smi">TreeNode</span> root) {
    <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
    <span class="pl-smi">TreeNode</span> pre <span class="pl-k">=</span> <span class="pl-c1">null</span>;
    <span class="pl-k">while</span> (root <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
        <span class="pl-k">if</span> (root<span class="pl-k">.</span>left <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
            res<span class="pl-k">.</span>add(root<span class="pl-k">.</span>val);
            root <span class="pl-k">=</span> root<span class="pl-k">.</span>right;
        } <span class="pl-k">else</span> {
            pre <span class="pl-k">=</span> root<span class="pl-k">.</span>left;
            <span class="pl-k">while</span> (pre<span class="pl-k">.</span>right <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> pre<span class="pl-k">.</span>right <span class="pl-k">!=</span> root) {
                pre <span class="pl-k">=</span> pre<span class="pl-k">.</span>right;
            }
            <span class="pl-k">if</span> (pre<span class="pl-k">.</span>right <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
                pre<span class="pl-k">.</span>right <span class="pl-k">=</span> root;
                root <span class="pl-k">=</span> root<span class="pl-k">.</span>left;
            } <span class="pl-k">else</span> {
                pre<span class="pl-k">.</span>right <span class="pl-k">=</span> <span class="pl-c1">null</span>;
                res<span class="pl-k">.</span>add(root<span class="pl-k">.</span>val);
                root <span class="pl-k">=</span> root<span class="pl-k">.</span>right;
            }
        }
    }
    <span class="pl-k">return</span> res;
}
</pre></div>

<p><br>
<br></p>

<p><strong>Related</strong>: Get Keys In Binary Search Tree In Given Range</p>

<blockquote>
<p>Get the list of keys in a given binary search tree in a given range[min, max] in ascending order, both min and max are inclusive.</p>
</blockquote>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> getRange(<span class="pl-smi">TreeNode</span> root, <span class="pl-k">int</span> min, <span class="pl-k">int</span> max) {
    <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span> res;
    }
    getRange(root, min, max, res);
    <span class="pl-k">return</span> res;
  }
  <span class="pl-k">public</span> <span class="pl-k">void</span> getRange(<span class="pl-smi">TreeNode</span> root, <span class="pl-k">int</span> min, <span class="pl-k">int</span> max, <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> res) {
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span>;
    }
    <span class="pl-k">if</span> (root<span class="pl-k">.</span>key <span class="pl-k">&gt;=</span> min) {
      getRange(root<span class="pl-k">.</span>left, min, max, res);
    }
    <span class="pl-k">if</span> (root<span class="pl-k">.</span>key <span class="pl-k">&gt;=</span> min <span class="pl-k">&amp;&amp;</span> root<span class="pl-k">.</span>key <span class="pl-k">&lt;=</span> max) {
      res<span class="pl-k">.</span>add(root<span class="pl-k">.</span>key);
    }
    <span class="pl-k">if</span> (root<span class="pl-k">.</span>key <span class="pl-k">&lt;=</span> max) {
      getRange(root<span class="pl-k">.</span>right, min, max, res);
    }
  }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-95-unique-binary-search-trees" class="anchor" href="https://github.com/wishyouhappy/Algorithm#95-unique-binary-search-trees" aria-hidden="true"><span class="octicon octicon-link"></span></a>95 Unique Binary Search Trees</h3>

<blockquote>
<p>Given n, how many structurally unique BST's (binary search trees) that store values 1...n?</p>

<p>For example,</p>

<p>Given n = 3, there are a total of 5 unique BST's.</p>
</blockquote>

<pre>
   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3


</pre>

<p><strong>Idea</strong>: Consider a binary rooted at certain node node1, the number of unique binary trees would be #left sub-BST * #right sub-BST. So the total number of binary search tree would be sum of binary trees rooted at each node. </p>

<p>This is similar to the <a href="http://en.wikipedia.org/wiki/Catalan_number">catalan numbers</a>. In this problem, we could use dynamic programming to store middle results.  </p>

<p>Cn+1 = Sum (ci * c[n-i]), i = 0, 1, 2,....nwq   </p>

<p><strong>Java code</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> numTrees(<span class="pl-k">int</span> n) {
       <span class="pl-k">int</span>[] res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[n<span class="pl-k">+</span><span class="pl-c1">1</span>];
       res[<span class="pl-c1">0</span>] <span class="pl-k">=</span> <span class="pl-c1">1</span>;
       res[<span class="pl-c1">1</span>] <span class="pl-k">=</span> <span class="pl-c1">1</span>;
       <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">2</span>; i <span class="pl-k">&lt;=</span> n; i<span class="pl-k">++</span>) {
           <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;</span> i; j<span class="pl-k">++</span>) {
               res[i] <span class="pl-k">+=</span> res[j] <span class="pl-k">*</span> res[i <span class="pl-k">-</span> j <span class="pl-k">-</span> <span class="pl-c1">1</span>];
           }
       }
       <span class="pl-k">return</span> res[n];
    }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-96-unique-binary-search-trees-ii" class="anchor" href="https://github.com/wishyouhappy/Algorithm#96-unique-binary-search-trees-ii" aria-hidden="true"><span class="octicon octicon-link"></span></a>96 Unique Binary Search Trees II</h3>

<blockquote>
<p>Given n, generate all structurally unique BST's (binary search trees) that store values 1...n.</p>
</blockquote>

<pre>For example,
Given n = 3, your program should return all 5 unique BST's shown below.

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
confused what "{1,#,2,3}" means? &gt; read more on how binary tree is serialized on OJ.

</pre>

<p><strong>Idea</strong>: The basic Idea is same as <a href="https://github.com/wishyouhappy/Algorithm#95-unique-binary-search-trees">95 Unique Binary Search Trees</a>. We still need to create the left sub-BST and right sub-BST, then combine it with the root. </p>

<p>This is a bottom up approach, we create the trees from leaves. The time complexity is not polynomial. </p>

<p><strong>Attention</strong>: In order to create all the combinations in the for loop. So when left subtree is null, we still need to add null to list. </p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-smi">TreeNode</span>&gt;</span> generateTrees(<span class="pl-k">int</span> n) {
        <span class="pl-k">List&lt;<span class="pl-smi">TreeNode</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">TreeNode</span>&gt;</span>();
        <span class="pl-k">if</span> (n <span class="pl-k">&lt;</span> <span class="pl-c1">0</span>) {
           <span class="pl-k">return</span> res;
        }  
        <span class="pl-k">return</span> generateTrees(<span class="pl-c1">1</span>, n);
    }
    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-smi">TreeNode</span>&gt;</span> generateTrees(<span class="pl-k">int</span> l,  <span class="pl-k">int</span> r) {
        <span class="pl-k">List&lt;<span class="pl-smi">TreeNode</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">TreeNode</span>&gt;</span>();
        <span class="pl-k">if</span> (l <span class="pl-k">&gt;</span> r) {
            res<span class="pl-k">.</span>add(<span class="pl-c1">null</span>);
            <span class="pl-k">return</span> res;
        }
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> l; i <span class="pl-k">&lt;=</span> r; i<span class="pl-k">++</span>) {
            <span class="pl-k">List&lt;<span class="pl-smi">TreeNode</span>&gt;</span> lList <span class="pl-k">=</span> generateTrees(l, i<span class="pl-k">-</span><span class="pl-c1">1</span>);
            <span class="pl-k">List&lt;<span class="pl-smi">TreeNode</span>&gt;</span> rList <span class="pl-k">=</span> generateTrees(i<span class="pl-k">+</span><span class="pl-c1">1</span>, r);
            <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;</span> lList<span class="pl-k">.</span>size(); j<span class="pl-k">++</span>) {
                <span class="pl-k">for</span> (<span class="pl-k">int</span> k <span class="pl-k">=</span> <span class="pl-c1">0</span>; k <span class="pl-k">&lt;</span> rList<span class="pl-k">.</span>size(); k<span class="pl-k">++</span>) {
                    <span class="pl-smi">TreeNode</span> root <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">TreeNode</span>(i);
                    root<span class="pl-k">.</span>left <span class="pl-k">=</span> lList<span class="pl-k">.</span>get(j);
                    root<span class="pl-k">.</span>right <span class="pl-k">=</span> rList<span class="pl-k">.</span>get(k);
                    res<span class="pl-k">.</span>add(root);
                }
            }
        }
        <span class="pl-k">return</span> res;
    }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-98-validate-binary-search-tree" class="anchor" href="./wishyouhappy_Algorithm_files/wishyouhappy_Algorithm.html" aria-hidden="true"><span class="octicon octicon-link"></span></a>98 Validate Binary Search Tree</h3>

<blockquote>
<p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
</blockquote>

<p>Assume a BST is defined as follows:</p>

<p>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node's key.
The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node's key.
Both the left and right subtrees must also be binary search trees.</p>

<p><strong>Idea</strong>: We know that if a tree is a binary search tree, then it's inorder traversal is sequential. Thus we can traverse the tree inorder to check if everynode's predecessor is less than the node. We can also traverse the tree inorder and save the sequence, then check if there is out of order nodes. But it will require addtional space. </p>

<p><strong>Time</strong>: O(n) <strong>Space</strong>: O(lgn)</p>

<p><strong>Note</strong>: Remember to check if pre is null before compare pre.val and root.val</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">boolean</span> isValidBST(<span class="pl-smi">TreeNode</span> root) {
    <span class="pl-c">// Write your solution here.</span>
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }
    <span class="pl-k">boolean</span>[] res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">boolean</span>[<span class="pl-c1">1</span>];
    res[<span class="pl-c1">0</span>] <span class="pl-k">=</span> <span class="pl-c1">true</span>;
    isBST(root, res, <span class="pl-k">new</span> <span class="pl-smi">TreeNode</span>[<span class="pl-c1">1</span>]);
    <span class="pl-k">return</span> res[<span class="pl-c1">0</span>];
  }

  <span class="pl-k">public</span> <span class="pl-k">void</span> isBST(<span class="pl-smi">TreeNode</span> root, <span class="pl-k">boolean</span>[] res, <span class="pl-k">TreeNode</span>[] pre) {
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span>;
    }
    isBST(root<span class="pl-k">.</span>left, res, pre);
    <span class="pl-k">if</span> (pre[<span class="pl-c1">0</span>] <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> pre[<span class="pl-c1">0</span>]<span class="pl-k">.</span>val <span class="pl-k">&gt;=</span> root<span class="pl-k">.</span>val) {
      res[<span class="pl-c1">0</span>] <span class="pl-k">=</span> <span class="pl-c1">false</span>;
    }
    pre[<span class="pl-c1">0</span>] <span class="pl-k">=</span> root;
    isBST(root<span class="pl-k">.</span>right, res, pre);
  }</pre></div>

<p><strong>Other idea</strong>: We record the lower bound and upper bound for each node. If a node's value is not between the lower bound and upper bound, return false. There is a problem with this method: if the tree contains nodes with value of Integer.MIN_VALUE AND Integer.MAX_VALUE. </p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">boolean</span> isValidBST(<span class="pl-smi">TreeNode</span> root) {
        <span class="pl-k">return</span> isValidBST(root, <span class="pl-smi">Integer</span><span class="pl-c1"><span class="pl-k">.</span>MIN_VALUE</span>, <span class="pl-smi">Integer</span><span class="pl-c1"><span class="pl-k">.</span>MAX_VALUE</span>);
    }
    <span class="pl-k">public</span> <span class="pl-k">boolean</span> isValidBST(<span class="pl-smi">TreeNode</span> root, <span class="pl-k">int</span> min, <span class="pl-k">int</span> max) {
        <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">true</span>;
        }
        <span class="pl-k">if</span> (root<span class="pl-k">.</span>val <span class="pl-k">&lt;=</span> min <span class="pl-k">||</span> root<span class="pl-k">.</span>val <span class="pl-k">&gt;=</span> max) {
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        <span class="pl-k">return</span> isValidBST(root<span class="pl-k">.</span>left, min, root<span class="pl-k">.</span>val) <span class="pl-k">&amp;&amp;</span> isValidBST(root<span class="pl-k">.</span>right, root<span class="pl-k">.</span>val, max);
    }

</pre></div>

<p><strong>Wrong answer</strong>: The following code just check if each node maintains node.val &gt; node.left.val and node.val &lt; node.right.val. However, even though each node satisfies this condition, it might not be a binary search tree. Eg: 10,5,15,#,#,6,20</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">boolean</span> isValidBST1(<span class="pl-smi">TreeNode</span> root) {
        <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> (root<span class="pl-k">.</span>left <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> root<span class="pl-k">.</span>right <span class="pl-k">==</span> <span class="pl-c1">null</span>)) {
            <span class="pl-k">return</span> <span class="pl-c1">true</span>;
        }
        <span class="pl-k">if</span> ((root<span class="pl-k">.</span>left <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> root<span class="pl-k">.</span>left<span class="pl-k">.</span>val <span class="pl-k">&gt;=</span> root<span class="pl-k">.</span>val) <span class="pl-k">||</span> (root<span class="pl-k">.</span>right <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> root<span class="pl-k">.</span>right<span class="pl-k">.</span>val <span class="pl-k">&lt;=</span> root<span class="pl-k">.</span>val)) {
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        <span class="pl-k">return</span> isValidBST(root<span class="pl-k">.</span>left) <span class="pl-k">&amp;&amp;</span> isValidBST(root<span class="pl-k">.</span>right);
   }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-99-recover-binary-search-tree" class="anchor" href="https://github.com/wishyouhappy/Algorithm#99-recover-binary-search-tree" aria-hidden="true"><span class="octicon octicon-link"></span></a>99 Recover Binary Search Tree</h3>

<blockquote>
<p>Two elements of a binary search tree (BST) are swapped by mistake.</p>

<p>Recover the tree without changing its structure.</p>

<p>Note:</p>

<p>A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?</p>
</blockquote>

<p><strong>Idea</strong>: We can traverse the tree inorder to find the misplaced TreeNode. If we use recursion, we need O(n) space. If we use morris traversal, we can solve this problem in constant space. </p>

<p><strong>Solution 1: O(n) space.</strong></p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">void</span> recoverTree(<span class="pl-smi">TreeNode</span> root) {
        <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
            <span class="pl-k">return</span>;
        }
        <span class="pl-k">TreeNode</span>[] arr <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">TreeNode</span>[<span class="pl-c1">3</span>];
        recoverTree(root, arr);
        <span class="pl-k">int</span> temp <span class="pl-k">=</span> arr[<span class="pl-c1">0</span>]<span class="pl-k">.</span>val;
        arr[<span class="pl-c1">0</span>]<span class="pl-k">.</span>val <span class="pl-k">=</span> arr[<span class="pl-c1">1</span>]<span class="pl-k">.</span>val;
        arr[<span class="pl-c1">1</span>]<span class="pl-k">.</span>val <span class="pl-k">=</span> temp;
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> recoverTree(<span class="pl-smi">TreeNode</span> root, <span class="pl-k">TreeNode</span>[] arr) {
        <span class="pl-k">if</span>(root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
            <span class="pl-k">return</span>;
        }
        recoverTree(root<span class="pl-k">.</span>left, arr);
        <span class="pl-k">if</span> (arr[<span class="pl-c1">2</span>] <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> arr[<span class="pl-c1">2</span>]<span class="pl-k">.</span>val <span class="pl-k">&gt;</span> root<span class="pl-k">.</span>val) {
            <span class="pl-k">if</span>(arr[<span class="pl-c1">0</span>] <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
                arr[<span class="pl-c1">0</span>] <span class="pl-k">=</span> arr[<span class="pl-c1">2</span>];
            }
            arr[<span class="pl-c1">1</span>] <span class="pl-k">=</span> root;
        }
        arr[<span class="pl-c1">2</span>] <span class="pl-k">=</span> root;
        recoverTree(root<span class="pl-k">.</span>right, arr);
    }
</pre></div>

<p><strong>Solution2 : morris</strong></p>

<div class="highlight highlight-java"><pre>    <span class="pl-c">/*Morris traversal O(1) */</span>
       <span class="pl-k">public</span> <span class="pl-k">void</span> recoverTree(<span class="pl-smi">TreeNode</span> root) {
        <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
            <span class="pl-k">return</span>;
        }
        <span class="pl-k">TreeNode</span>[] arr <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">TreeNode</span>[<span class="pl-c1">3</span>];
        recoverTree(root, arr);
        <span class="pl-k">int</span> temp <span class="pl-k">=</span> arr[<span class="pl-c1">0</span>]<span class="pl-k">.</span>val;
        arr[<span class="pl-c1">0</span>]<span class="pl-k">.</span>val <span class="pl-k">=</span> arr[<span class="pl-c1">1</span>]<span class="pl-k">.</span>val;
        arr[<span class="pl-c1">1</span>]<span class="pl-k">.</span>val <span class="pl-k">=</span> temp;
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> recoverTree(<span class="pl-smi">TreeNode</span> root, <span class="pl-k">TreeNode</span>[] arr){
        <span class="pl-k">if</span>(root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
            <span class="pl-k">return</span>;
        }

        <span class="pl-smi">TreeNode</span> pre <span class="pl-k">=</span> <span class="pl-c1">null</span>; <span class="pl-c">/* predecessor*/</span>
        <span class="pl-smi">TreeNode</span> previous <span class="pl-k">=</span> <span class="pl-c1">null</span>;
        <span class="pl-k">while</span> (root <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
            <span class="pl-k">if</span> (root<span class="pl-k">.</span>left <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
                <span class="pl-k">if</span> (previous <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> previous<span class="pl-k">.</span>val <span class="pl-k">&gt;</span> root<span class="pl-k">.</span>val) {
                    <span class="pl-k">if</span>(arr[<span class="pl-c1">0</span>] <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
                        arr[<span class="pl-c1">0</span>] <span class="pl-k">=</span> previous;
                    }
                    arr[<span class="pl-c1">1</span>] <span class="pl-k">=</span> root;
                }
                previous <span class="pl-k">=</span> root;
                root <span class="pl-k">=</span> root<span class="pl-k">.</span>right;
            }<span class="pl-k">else</span>{
                <span class="pl-c">/* find predecessor */</span>
                pre <span class="pl-k">=</span> root<span class="pl-k">.</span>left;
                <span class="pl-k">while</span> (pre<span class="pl-k">.</span>right <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> pre<span class="pl-k">.</span>right <span class="pl-k">!=</span> root) {
                    pre <span class="pl-k">=</span> pre<span class="pl-k">.</span>right;
                }

                <span class="pl-c">/* if predecessor's right == null, set current node as its right child */</span>
                <span class="pl-k">if</span> (pre<span class="pl-k">.</span>right <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
                    pre<span class="pl-k">.</span>right <span class="pl-k">=</span> root;
                    root <span class="pl-k">=</span> root<span class="pl-k">.</span>left;
                } <span class="pl-k">else</span> {
                    <span class="pl-c">/* recover tree, when return to parent node the second time */</span>
                    pre<span class="pl-k">.</span>right <span class="pl-k">=</span> <span class="pl-c1">null</span>;
                    <span class="pl-k">if</span> (previous <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> previous<span class="pl-k">.</span>val <span class="pl-k">&gt;</span> root<span class="pl-k">.</span>val) {
                        <span class="pl-k">if</span>(arr[<span class="pl-c1">0</span>] <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
                            arr[<span class="pl-c1">0</span>] <span class="pl-k">=</span> previous;
                        }
                        arr[<span class="pl-c1">1</span>] <span class="pl-k">=</span> root;
                    }   
                    previous <span class="pl-k">=</span> root;
                    root <span class="pl-k">=</span> root<span class="pl-k">.</span>right;
                }
            }
        }
    }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-100-same-tree" class="anchor" href="https://github.com/wishyouhappy/Algorithm#100-same-tree" aria-hidden="true"><span class="octicon octicon-link"></span></a>100 Same Tree</h3>

<blockquote>
<p>Given two binary trees, write a function to check if they are equal or not.</p>

<p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.</p>
</blockquote>

<p><strong>Idea</strong>: We can choose any traverse method to visit each node and check if they are the same. We need to check the val, the left child and the right child.</p>

<p><strong>Java code</strong>:</p>

<div class="highlight highlight-java"><pre> <span class="pl-k">public</span> <span class="pl-k">boolean</span> isSameTree(<span class="pl-smi">TreeNode</span> one, <span class="pl-smi">TreeNode</span> two) {
    <span class="pl-k">if</span> (one <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> two <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }
    <span class="pl-k">if</span> (one <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> two <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> one<span class="pl-k">.</span>val <span class="pl-k">!=</span> two<span class="pl-k">.</span>val) {
      <span class="pl-k">return</span> <span class="pl-c1">false</span>;
    }
    <span class="pl-k">return</span> isSameTree(one<span class="pl-k">.</span>left, two<span class="pl-k">.</span>left) <span class="pl-k">&amp;&amp;</span> isSameTree(one<span class="pl-k">.</span>right, two<span class="pl-k">.</span>right);
  }</pre></div>

<p><strong>Time complexity analysis</strong>:</p>

<ul>
<li>1) way 1 : T(n) = 2 T(n/2) + 1. Use master theory, we got T = O(n)</li>
<li>2) way 2 : recursion tree. T(n) = 2 ^ log2(n) = O(n)</li>
</ul>

<p><br></p>

<p><br></p>

<p><strong>Related</strong>: Tweaked Identical Binary Trees</p>

<blockquote>
<p>Determine whether two given binary trees are identical assuming any number of ‘tweak’s are allowed. A tweak is defined as a swap of the children of one node in the tree</p>
</blockquote>

<p><strong>Idea</strong>: basically, it's the same idea with same tree or symmetric tree. If it's same or tweaked, we return true</p>

<p><strong>solution</strong>:</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">boolean</span> isTweakedIdentical(<span class="pl-smi">TreeNode</span> one, <span class="pl-smi">TreeNode</span> two) {
    <span class="pl-k">if</span> (one <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> two <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }
    <span class="pl-k">if</span> (one <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> two <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> one<span class="pl-k">.</span>key <span class="pl-k">!=</span> two<span class="pl-k">.</span>key) {
      <span class="pl-k">return</span> <span class="pl-c1">false</span>;
    }
    <span class="pl-k">return</span> (isTweakedIdentical(one<span class="pl-k">.</span>left, two<span class="pl-k">.</span>left) <span class="pl-k">&amp;&amp;</span> isTweakedIdentical(one<span class="pl-k">.</span>right, two<span class="pl-k">.</span>right)) <span class="pl-k">||</span> (isTweakedIdentical(one<span class="pl-k">.</span>right, two<span class="pl-k">.</span>left) <span class="pl-k">&amp;&amp;</span> isTweakedIdentical(one<span class="pl-k">.</span>left, two<span class="pl-k">.</span>right));
  }
</pre></div>

<p><strong>Time complexity analysis</strong>:</p>

<ul>
<li>1) way 1 : T(n) = 4 T(n/2) + 1. Use master theory, we got T = O(n^2)</li>
<li>2) way 2 : recursion tree. T(n) = 4 ^ log2(n) = 2 ^ (2 log2(n)) = 2 ^ log2(n^2) = O(n^2)</li>
</ul>

<p><br>
<br></p>

<h3><a id="user-content-101-symmetric-tree" class="anchor" href="https://github.com/wishyouhappy/Algorithm#101-symmetric-tree" aria-hidden="true"><span class="octicon octicon-link"></span></a>101 Symmetric Tree</h3>

<blockquote>
<p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
</blockquote>

<pre>For example, this binary tree is symmetric:

    1
   / \
  2   2
 / \ / \
3  4 4  3
But the following is not:
    1
   / \
  2   2
   \   \
   3    3

</pre>

<p>Note:
Bonus points if you could solve it both recursively and iteratively.</p>

<p><strong>Idea</strong>: </p>

<ul>
<li>1) root is null, then return true</li>
<li>2) left and right child are both null return true;</li>
<li>3) left and right only one is null, return false</li>
<li>4) left and right both exist, check if their value equals</li>
<li>5) go to next level, check the relatin of left.left and right.right , left.right and right.left</li>
</ul>

<p><strong>Solution 1</strong>: Recursive</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">boolean</span> isSymmetric(<span class="pl-smi">TreeNode</span> root) {
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> (root<span class="pl-k">.</span>left <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> root<span class="pl-k">.</span>right <span class="pl-k">==</span> <span class="pl-c1">null</span>)) {
      <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }
    <span class="pl-k">return</span> isSymmetric(root<span class="pl-k">.</span>left, root<span class="pl-k">.</span>right);
  }

  <span class="pl-k">public</span> <span class="pl-k">boolean</span> isSymmetric(<span class="pl-smi">TreeNode</span> l, <span class="pl-smi">TreeNode</span> r) {
    <span class="pl-k">if</span> (l <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> r <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }
    <span class="pl-k">if</span> (l <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> r <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> l<span class="pl-k">.</span>val <span class="pl-k">!=</span> r<span class="pl-k">.</span>val) {
      <span class="pl-k">return</span> <span class="pl-c1">false</span>;
    }
    <span class="pl-k">return</span> isSymmetric(l<span class="pl-k">.</span>left, r<span class="pl-k">.</span>right) <span class="pl-k">&amp;&amp;</span> isSymmetric(l<span class="pl-k">.</span>right, r<span class="pl-k">.</span>left);

  }
</pre></div>

<p><strong>Solution 2</strong>: Iterative</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">boolean</span> isSymmetric(<span class="pl-smi">TreeNode</span> root) {
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> (root<span class="pl-k">.</span>left <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> root<span class="pl-k">.</span>right <span class="pl-k">==</span> <span class="pl-c1">null</span>)) {
      <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }
    <span class="pl-k">if</span> (root<span class="pl-k">.</span>left <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> root<span class="pl-k">.</span>right <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
        <span class="pl-k">return</span> <span class="pl-c1">false</span>;
    }
    <span class="pl-k">Queue&lt;<span class="pl-smi">TreeNode</span>&gt;</span> queueL <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">LinkedList&lt;<span class="pl-smi">TreeNode</span>&gt;</span>();
    <span class="pl-k">Queue&lt;<span class="pl-smi">TreeNode</span>&gt;</span> queueR <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">LinkedList&lt;<span class="pl-smi">TreeNode</span>&gt;</span>();
    queueL<span class="pl-k">.</span>offer(root<span class="pl-k">.</span>left);
    queueR<span class="pl-k">.</span>offer(root<span class="pl-k">.</span>right);
    <span class="pl-k">while</span> (<span class="pl-k">!</span>queueL<span class="pl-k">.</span>isEmpty() <span class="pl-k">&amp;&amp;</span> <span class="pl-k">!</span>queueR<span class="pl-k">.</span>isEmpty()) {
        <span class="pl-smi">TreeNode</span> l <span class="pl-k">=</span> queueL<span class="pl-k">.</span>poll();
        <span class="pl-smi">TreeNode</span> r <span class="pl-k">=</span> queueR<span class="pl-k">.</span>poll();
        <span class="pl-k">if</span> (l<span class="pl-k">.</span>val <span class="pl-k">!=</span> r<span class="pl-k">.</span>val) {
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        <span class="pl-k">if</span> (l<span class="pl-k">.</span>left <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
            <span class="pl-k">if</span> (r<span class="pl-k">.</span>right <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
                <span class="pl-k">return</span> <span class="pl-c1">false</span>;
            }
            queueL<span class="pl-k">.</span>offer(l<span class="pl-k">.</span>left);
            queueR<span class="pl-k">.</span>offer(r<span class="pl-k">.</span>right);
        } <span class="pl-k">else</span> {
            <span class="pl-k">if</span> (r<span class="pl-k">.</span>right <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
                <span class="pl-k">return</span> <span class="pl-c1">false</span>;
            }
        }
        <span class="pl-k">if</span> (l<span class="pl-k">.</span>right <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
            <span class="pl-k">if</span> (r<span class="pl-k">.</span>left <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
                <span class="pl-k">return</span> <span class="pl-c1">false</span>;
            }
            queueL<span class="pl-k">.</span>offer(l<span class="pl-k">.</span>right);
            queueR<span class="pl-k">.</span>offer(r<span class="pl-k">.</span>left);
        } <span class="pl-k">else</span> {
            <span class="pl-k">if</span> (r<span class="pl-k">.</span>left <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
                <span class="pl-k">return</span> <span class="pl-c1">false</span>;
            }
        }
    } 
    <span class="pl-k">return</span> <span class="pl-c1">true</span>;
  }</pre></div>

<p><strong>Solution 3</strong>: concise version</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">boolean</span> isSymmetric(<span class="pl-smi">TreeNode</span> root) {
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> (root<span class="pl-k">.</span>left <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> root<span class="pl-k">.</span>right <span class="pl-k">==</span> <span class="pl-c1">null</span>)) {
      <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }
    <span class="pl-k">Queue&lt;<span class="pl-smi">TreeNode</span>&gt;</span> queueL <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">LinkedList&lt;<span class="pl-smi">TreeNode</span>&gt;</span>();
    <span class="pl-k">Queue&lt;<span class="pl-smi">TreeNode</span>&gt;</span> queueR <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">LinkedList&lt;<span class="pl-smi">TreeNode</span>&gt;</span>();
    queueL<span class="pl-k">.</span>offer(root<span class="pl-k">.</span>left);
    queueR<span class="pl-k">.</span>offer(root<span class="pl-k">.</span>right);
    <span class="pl-k">while</span> (<span class="pl-k">!</span>queueL<span class="pl-k">.</span>isEmpty() <span class="pl-k">&amp;&amp;</span> <span class="pl-k">!</span>queueR<span class="pl-k">.</span>isEmpty()) {
        <span class="pl-smi">TreeNode</span> l <span class="pl-k">=</span> queueL<span class="pl-k">.</span>poll();
        <span class="pl-smi">TreeNode</span> r <span class="pl-k">=</span> queueR<span class="pl-k">.</span>poll();
        <span class="pl-k">if</span> (l <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> r <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
            <span class="pl-k">continue</span>;
        }
        <span class="pl-k">if</span> ((l <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> r <span class="pl-k">!=</span> <span class="pl-c1">null</span>) <span class="pl-k">||</span> (l <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> r <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">||</span> l<span class="pl-k">.</span>val <span class="pl-k">!=</span> r<span class="pl-k">.</span>val) {
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        queueL<span class="pl-k">.</span>offer(l<span class="pl-k">.</span>left);
        queueR<span class="pl-k">.</span>offer(r<span class="pl-k">.</span>right);
        queueL<span class="pl-k">.</span>offer(l<span class="pl-k">.</span>right);
        queueR<span class="pl-k">.</span>offer(r<span class="pl-k">.</span>left);
    } 
    <span class="pl-k">return</span> <span class="pl-c1">true</span>;
  }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-102-binary-tree-level-order-traversal" class="anchor" href="https://github.com/wishyouhappy/Algorithm#102-binary-tree-level-order-traversal" aria-hidden="true"><span class="octicon octicon-link"></span></a>102 Binary Tree Level Order Traversal</h3>

<blockquote>
<p>Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).</p>
</blockquote>

<pre>For example:
Given binary tree {3,9,20,#,#,15,7},
    3
   / \
  9  20
    /  \
   15   7
return its level order traversal as:
[
  [3],
  [9,20],
  [15,7]
]
</pre>

<p><strong>Idea</strong>: </p>

<p>-1) Breadth first search -&gt; Queue</p>

<p>-2) each time not just poll one node from queue, but poll a level of nodes from queue</p>

<p><strong>Solution</strong>:</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> levelOrder(<span class="pl-smi">TreeNode</span> root) {
    <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>();
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
        <span class="pl-k">return</span> res;
    }
    <span class="pl-k">Queue&lt;<span class="pl-smi">TreeNode</span>&gt;</span> queue <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">LinkedList&lt;<span class="pl-smi">TreeNode</span>&gt;</span>();
    queue<span class="pl-k">.</span>offer(root);
    <span class="pl-k">while</span> (<span class="pl-k">!</span>queue<span class="pl-k">.</span>isEmpty()) {
        <span class="pl-k">int</span> size <span class="pl-k">=</span> queue<span class="pl-k">.</span>size();
        <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> cur <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> size; i<span class="pl-k">++</span>) {
            <span class="pl-smi">TreeNode</span> temp <span class="pl-k">=</span> queue<span class="pl-k">.</span>poll();
            <span class="pl-k">if</span> (temp<span class="pl-k">.</span>left <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
                queue<span class="pl-k">.</span>offer(temp<span class="pl-k">.</span>left);
            }
            <span class="pl-k">if</span> (temp<span class="pl-k">.</span>right <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
                queue<span class="pl-k">.</span>offer(temp<span class="pl-k">.</span>right);
            }
            cur<span class="pl-k">.</span>add(temp<span class="pl-k">.</span>val);
        }
        res<span class="pl-k">.</span>add(cur);
    }
    <span class="pl-k">return</span> res;
}
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-103-binary-tree-zigzag-level-order-traversal" class="anchor" href="https://github.com/wishyouhappy/Algorithm#103-binary-tree-zigzag-level-order-traversal" aria-hidden="true"><span class="octicon octicon-link"></span></a>103 Binary Tree Zigzag Level Order Traversal</h3>

<blockquote>
<p>Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).</p>
</blockquote>

<pre>For example:
Given binary tree {3,9,20,#,#,15,7},
    3
   / \
  9  20
    /  \
   15   7
return its zigzag level order traversal as:
[
  [3],
  [20,9],
  [15,7]
]

</pre>

<p><strong>Idea</strong>: Maintain a boolean variable to help indicate the add direction of the zigzag. Two cases based on this boolean variable, add at the end or add at index 0;</p>

<p><strong>Solution</strong>:</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> zigzagLevelOrder(<span class="pl-smi">TreeNode</span> root) {
    <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>();
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
        <span class="pl-k">return</span> res;
    }
    <span class="pl-k">Queue&lt;<span class="pl-smi">TreeNode</span>&gt;</span> queue <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">LinkedList&lt;<span class="pl-smi">TreeNode</span>&gt;</span>();
    queue<span class="pl-k">.</span>offer(root);
    <span class="pl-k">boolean</span> zig <span class="pl-k">=</span> <span class="pl-c1">true</span>;
    <span class="pl-k">while</span> (<span class="pl-k">!</span>queue<span class="pl-k">.</span>isEmpty()) {
        <span class="pl-k">int</span> size <span class="pl-k">=</span> queue<span class="pl-k">.</span>size();
        <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> cur <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> size; i<span class="pl-k">++</span>) {
            <span class="pl-smi">TreeNode</span> temp <span class="pl-k">=</span> queue<span class="pl-k">.</span>poll();
            <span class="pl-k">if</span> (temp<span class="pl-k">.</span>left <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
                queue<span class="pl-k">.</span>offer(temp<span class="pl-k">.</span>left);
            }
            <span class="pl-k">if</span> (temp<span class="pl-k">.</span>right <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
                queue<span class="pl-k">.</span>offer(temp<span class="pl-k">.</span>right);
            }
            <span class="pl-k">if</span> (zig) {
                cur<span class="pl-k">.</span>add(temp<span class="pl-k">.</span>val);
            } <span class="pl-k">else</span> {
                cur<span class="pl-k">.</span>add(<span class="pl-c1">0</span>, temp<span class="pl-k">.</span>val);
            }
        }
        res<span class="pl-k">.</span>add(cur);
        zig <span class="pl-k">=</span> <span class="pl-k">!</span>zig;
    }
    <span class="pl-k">return</span> res;
}</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-104-maximum-depth-of-binary-tree" class="anchor" href="https://github.com/wishyouhappy/Algorithm#104-maximum-depth-of-binary-tree" aria-hidden="true"><span class="octicon octicon-link"></span></a>104 Maximum Depth of Binary Tree</h3>

<p><strong>Idea</strong>:</p>

<ul>
<li><p>1) solution 1: recursive, max depth of root = max(max depth of left child, max depth of right child) + 1</p></li>
<li><p>2) the levels of the binary search tree is its max depth</p></li>
</ul>

<p><strong>Solution 1</strong>: recursive</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">int</span> maxDepth(<span class="pl-smi">TreeNode</span> root) {
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
        <span class="pl-k">return</span> <span class="pl-c1">0</span>;
    }
    <span class="pl-k">return</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(maxDepth(root<span class="pl-k">.</span>left), maxDepth(root<span class="pl-k">.</span>right)) <span class="pl-k">+</span> <span class="pl-c1">1</span>;
}</pre></div>

<p><strong>Solution 2</strong>: iterative</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">int</span> maxDepth(<span class="pl-smi">TreeNode</span> root){
    <span class="pl-k">if</span>(root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
        <span class="pl-k">return</span> <span class="pl-c1">0</span>;
    }
    <span class="pl-k">int</span> level <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">Queue&lt;<span class="pl-smi">TreeNode</span>&gt;</span> queue <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">LinkedList&lt;<span class="pl-smi">TreeNode</span>&gt;</span>();
    queue<span class="pl-k">.</span>offer(root);
    <span class="pl-k">while</span> (<span class="pl-k">!</span>queue<span class="pl-k">.</span>isEmpty()) {
        <span class="pl-k">int</span> size <span class="pl-k">=</span> queue<span class="pl-k">.</span>size();
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> size; i<span class="pl-k">++</span>) {
            <span class="pl-smi">TreeNode</span> temp <span class="pl-k">=</span> queue<span class="pl-k">.</span>poll();
            <span class="pl-k">if</span> (temp<span class="pl-k">.</span>left <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
                queue<span class="pl-k">.</span>offer(temp<span class="pl-k">.</span>left);
            }
            <span class="pl-k">if</span> (temp<span class="pl-k">.</span>right <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
                queue<span class="pl-k">.</span>offer(temp<span class="pl-k">.</span>right);
            }
        }
        level<span class="pl-k">++</span>;
    }
    <span class="pl-k">return</span> level;
    }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-105-construct-binary-tree-from-preorder-and-inorder-traversal" class="anchor" href="https://github.com/wishyouhappy/Algorithm#105-construct-binary-tree-from-preorder-and-inorder-traversal" aria-hidden="true"><span class="octicon octicon-link"></span></a>105 Construct Binary Tree from Preorder and Inorder Traversal</h3>

<blockquote>
<p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
</blockquote>

<p>Note:
You may assume that duplicates do not exist in the tree.</p>

<p><strong>Idea</strong>: </p>

<p><strong>Solution 1</strong>:</p>

<ul>
<li><p>1) in preorder, the first element is root, then left subtree, right subtree</p></li>
<li><p>2) in inorder, left subtree, root, right subtree. </p></li>
</ul>

<p>Thus we can use this index to recursively build the binary search tree. </p>

<p><strong>Time complexity</strong>:</p>

<p>T(n) = 2 T(n/2) + O(n). Solve it we get T(n) = O(nlgn)</p>

<p><strong>Solution 2</strong>:</p>

<p>If we use a map to store the value and index relation of inorder array, we can get a better time complexity:</p>

<p><strong>Time</strong> :</p>

<p>T(n) = 2 T(n/2) + 1. Solve it we get T(n) = O(n)</p>

<p>*<em>Solution 1 code *</em>:</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-smi">TreeNode</span> buildTree(<span class="pl-k">int</span>[] preorder, <span class="pl-k">int</span>[] inorder) {
    <span class="pl-k">if</span> (preorder <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> preorder<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
        <span class="pl-k">return</span> <span class="pl-c1">null</span>;
    }
    <span class="pl-k">return</span> buildTree(preorder, <span class="pl-c1">0</span>, preorder<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>, inorder, <span class="pl-c1">0</span>, inorder<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>);
}

<span class="pl-k">public</span> <span class="pl-smi">TreeNode</span> buildTree(<span class="pl-k">int</span>[] preorder, <span class="pl-k">int</span> pStart, <span class="pl-k">int</span> pEnd, <span class="pl-k">int</span>[] inorder, <span class="pl-k">int</span> iStart, <span class="pl-k">int</span> iEnd) {
    <span class="pl-k">if</span> (pStart <span class="pl-k">&gt;</span> pEnd) {
        <span class="pl-k">return</span> <span class="pl-c1">null</span>;
    }
    <span class="pl-smi">TreeNode</span> root <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">TreeNode</span>(preorder[pStart]);
    <span class="pl-k">int</span> rootIndex <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> iStart; i <span class="pl-k">&lt;=</span> iEnd; i<span class="pl-k">++</span>) {
        <span class="pl-k">if</span> (preorder[pStart] <span class="pl-k">==</span> inorder[i]) {
            rootIndex <span class="pl-k">=</span> i;
            <span class="pl-k">break</span>;
        }
    }
    <span class="pl-k">int</span> leftLen <span class="pl-k">=</span> rootIndex <span class="pl-k">-</span> iStart;
    root<span class="pl-k">.</span>left  <span class="pl-k">=</span> buildTree(preorder, pStart <span class="pl-k">+</span> <span class="pl-c1">1</span>, pStart <span class="pl-k">+</span> leftLen, inorder, iStart, rootIndex <span class="pl-k">-</span> <span class="pl-c1">1</span>);
    root<span class="pl-k">.</span>right <span class="pl-k">=</span> buildTree(preorder, pStart <span class="pl-k">+</span> leftLen <span class="pl-k">+</span> <span class="pl-c1">1</span>, pEnd, inorder, rootIndex <span class="pl-k">+</span> <span class="pl-c1">1</span>, iEnd);
    <span class="pl-k">return</span> root;
}</pre></div>

<p><br></p>

<p><strong>Solution 2 code</strong>:</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-smi">TreeNode</span> buildTree(<span class="pl-k">int</span>[] preorder, <span class="pl-k">int</span>[] inorder) {
    <span class="pl-k">if</span> (preorder <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> preorder<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
        <span class="pl-k">return</span> <span class="pl-c1">null</span>;
    }
    <span class="pl-k">Map&lt;<span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>&gt;</span> map <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashMap&lt;<span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>&gt;</span>();
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> inorder<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
        map<span class="pl-k">.</span>put(inorder[i], i);
    }
    <span class="pl-k">return</span> buildTree(preorder, <span class="pl-c1">0</span>, preorder<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>, inorder, <span class="pl-c1">0</span>, inorder<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>, map);
}

<span class="pl-k">public</span> <span class="pl-smi">TreeNode</span> buildTree(<span class="pl-k">int</span>[] preorder, <span class="pl-k">int</span> pStart, <span class="pl-k">int</span> pEnd, <span class="pl-k">int</span>[] inorder, <span class="pl-k">int</span> iStart, <span class="pl-k">int</span> iEnd, <span class="pl-k">Map&lt;<span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>&gt;</span> map) {
    <span class="pl-k">if</span> (pStart <span class="pl-k">&gt;</span> pEnd) {
        <span class="pl-k">return</span> <span class="pl-c1">null</span>;
    }
    <span class="pl-smi">TreeNode</span> root <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">TreeNode</span>(preorder[pStart]);
    <span class="pl-k">int</span> rootIndex <span class="pl-k">=</span> map<span class="pl-k">.</span>get(preorder[pStart]);
    <span class="pl-k">int</span> leftLen <span class="pl-k">=</span> rootIndex <span class="pl-k">-</span> iStart;
    root<span class="pl-k">.</span>left  <span class="pl-k">=</span> buildTree(preorder, pStart <span class="pl-k">+</span> <span class="pl-c1">1</span>, pStart <span class="pl-k">+</span> leftLen, inorder, iStart, rootIndex <span class="pl-k">-</span> <span class="pl-c1">1</span>, map);
    root<span class="pl-k">.</span>right <span class="pl-k">=</span> buildTree(preorder, pStart <span class="pl-k">+</span> leftLen <span class="pl-k">+</span> <span class="pl-c1">1</span>, pEnd, inorder, rootIndex <span class="pl-k">+</span> <span class="pl-c1">1</span>, iEnd, map);
    <span class="pl-k">return</span> root;
}</pre></div>

<p><br></p>

<p><strong>Related</strong>:Reconstruct Binary Tree With Levelorder And Inorder</p>

<p><strong>Time complexity</strong>: if tree is balanced O(nlogn), otherwise, O(n ^ 2)</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-smi">TreeNode</span> reconstruct(<span class="pl-k">int</span>[] in, <span class="pl-k">int</span>[] level) {
    <span class="pl-k">if</span> (in <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> in<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> level <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> level<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
      <span class="pl-k">return</span> <span class="pl-c1">null</span>;
    }
    <span class="pl-k">Map&lt;<span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>&gt;</span> map <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashMap&lt;<span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>&gt;</span>();
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> in<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
      map<span class="pl-k">.</span>put(in[i], i);
    }
    <span class="pl-k">return</span> reconstruct(in, <span class="pl-c1">0</span>, in<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>, level, map);
  }
  <span class="pl-k">private</span> <span class="pl-smi">TreeNode</span> reconstruct(<span class="pl-k">int</span>[] in, <span class="pl-k">int</span> inl, <span class="pl-k">int</span> inr, <span class="pl-k">int</span>[] level, <span class="pl-k">Map&lt;<span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>&gt;</span> map) {
    <span class="pl-k">if</span> (inl <span class="pl-k">&gt;</span> inr) {
      <span class="pl-k">return</span> <span class="pl-c1">null</span>;
    }
    <span class="pl-smi">TreeNode</span> root <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">TreeNode</span>(level[<span class="pl-c1">0</span>]);
    <span class="pl-k">int</span> rootIndex <span class="pl-k">=</span> map<span class="pl-k">.</span>get(level[<span class="pl-c1">0</span>]);
    <span class="pl-k">int</span>[] levelLeft <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[rootIndex <span class="pl-k">-</span> inl];
    <span class="pl-k">int</span>[] levelRight <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[inr <span class="pl-k">-</span> rootIndex];
    <span class="pl-k">Map&lt;<span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>&gt;</span> leftMap <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashMap&lt;<span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>&gt;</span>();
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> inl; i <span class="pl-k">&lt;</span> rootIndex; i<span class="pl-k">++</span>) {
      leftMap<span class="pl-k">.</span>put(in[i], i);
    }
    <span class="pl-k">int</span> indexLeft <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">int</span> indexRight <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;</span> level<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
      <span class="pl-k">if</span> (leftMap<span class="pl-k">.</span>containsKey(level[i])) {
        levelLeft[indexLeft<span class="pl-k">++</span>] <span class="pl-k">=</span> level[i];
      } <span class="pl-k">else</span> {
        levelRight[indexRight<span class="pl-k">++</span>] <span class="pl-k">=</span> level[i];
      }
    }
    root<span class="pl-k">.</span>left <span class="pl-k">=</span> reconstruct(in, inl, rootIndex <span class="pl-k">-</span> <span class="pl-c1">1</span>, levelLeft, map);
    root<span class="pl-k">.</span>right <span class="pl-k">=</span> reconstruct(in, rootIndex <span class="pl-k">+</span> <span class="pl-c1">1</span>, inr, levelRight, map);
    <span class="pl-k">return</span> root;
  }</pre></div>

<p><br></p>

<p><strong>Related</strong>: Reconstruct Binary Search Tree With Postorder Traversal</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-smi">TreeNode</span> reconstruct(<span class="pl-k">int</span>[] post) {
  <span class="pl-k">if</span> (post <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> post<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
      <span class="pl-k">return</span> <span class="pl-c1">null</span>;
  }
  <span class="pl-k">return</span> reconstruct(post, <span class="pl-c1">0</span>, post<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>);
}

<span class="pl-k">public</span> <span class="pl-smi">TreeNode</span> reconstruct(<span class="pl-k">int</span>[] post, <span class="pl-k">int</span> l, <span class="pl-k">int</span> r) {
  <span class="pl-k">if</span> (l <span class="pl-k">&lt;</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> r <span class="pl-k">&lt;</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> l <span class="pl-k">&gt;</span> r) {
      <span class="pl-k">return</span> <span class="pl-c1">null</span>;
  }
  <span class="pl-smi">TreeNode</span> root <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">TreeNode</span>(post[r]);
  <span class="pl-k">int</span> index <span class="pl-k">=</span> findIndex(post, l, r);
  root<span class="pl-k">.</span>left <span class="pl-k">=</span> reconstruct(post, l, index);
  root<span class="pl-k">.</span>right <span class="pl-k">=</span> reconstruct(post, index <span class="pl-k">+</span> <span class="pl-c1">1</span>, r <span class="pl-k">-</span> <span class="pl-c1">1</span>);
  <span class="pl-k">return</span> root;
}

<span class="pl-k">private</span> <span class="pl-k">int</span> findIndex(<span class="pl-k">int</span>[] post, <span class="pl-k">int</span> l, <span class="pl-k">int</span> r) {
  <span class="pl-k">int</span> root <span class="pl-k">=</span> post[r];
  <span class="pl-k">int</span> index <span class="pl-k">=</span> r <span class="pl-k">-</span> <span class="pl-c1">1</span>;
  <span class="pl-k">while</span> (index <span class="pl-k">&gt;=</span> l <span class="pl-k">&amp;&amp;</span> post[index] <span class="pl-k">&gt;</span> root) {
      index<span class="pl-k">--</span>;
  }
  <span class="pl-k">return</span> index;
}</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-106-construct-binary-tree-from-inorder-and-postorder-traversal" class="anchor" href="https://github.com/wishyouhappy/Algorithm#106-construct-binary-tree-from-inorder-and-postorder-traversal" aria-hidden="true"><span class="octicon octicon-link"></span></a>106 Construct Binary Tree from Inorder and Postorder Traversal</h3>

<blockquote>
<p>Given inorder and postorder traversal of a tree, construct the binary tree.</p>
</blockquote>

<p>Note:
You may assume that duplicates do not exist in the tree.</p>

<p><strong>Idea</strong>: Here is the O(n) solution use hashmap, if you want a O(nlgn) solution, you can refer to 105 Construct Binary Tree from Preorder and Inorder Traversal.</p>

<p>For inorder: left subtree | root | right subtree
For postorder: left subtree | right subtree | root</p>

<p>Thus we can use the index relation to recursively build the tree. s</p>

<p><strong>Solution</strong>:</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-smi">TreeNode</span> buildTree(<span class="pl-k">int</span>[] inorder, <span class="pl-k">int</span>[] postorder) {
    <span class="pl-k">if</span> (inorder<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
        <span class="pl-k">return</span> <span class="pl-c1">null</span>;
    }
    <span class="pl-k">Map&lt;<span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>&gt;</span> map <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashMap&lt;<span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>&gt;</span>();
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> inorder<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
        map<span class="pl-k">.</span>put(inorder[i], i);
    }
    <span class="pl-k">return</span> buildTree(inorder, <span class="pl-c1">0</span>, inorder<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>, postorder, <span class="pl-c1">0</span>, postorder<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>, map);
}
<span class="pl-k">public</span> <span class="pl-smi">TreeNode</span> buildTree(<span class="pl-k">int</span>[] inorder, <span class="pl-k">int</span> iStart, <span class="pl-k">int</span> iEnd, <span class="pl-k">int</span>[] postorder, <span class="pl-k">int</span> pStart, <span class="pl-k">int</span> pEnd, <span class="pl-k">Map&lt;<span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>&gt;</span> map) {
    <span class="pl-k">if</span> (iStart <span class="pl-k">&gt;</span> iEnd) {
        <span class="pl-k">return</span> <span class="pl-c1">null</span>;
    }
    <span class="pl-smi">TreeNode</span> root <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">TreeNode</span>(postorder[pEnd]);
    <span class="pl-k">int</span> rootIndex <span class="pl-k">=</span> map<span class="pl-k">.</span>get(postorder[pEnd]);
    root<span class="pl-k">.</span>left <span class="pl-k">=</span> buildTree(inorder, iStart, rootIndex <span class="pl-k">-</span> <span class="pl-c1">1</span>, postorder, pStart, pStart <span class="pl-k">+</span> (rootIndex <span class="pl-k">-</span> <span class="pl-c1">1</span> <span class="pl-k">-</span> iStart), map);
    root<span class="pl-k">.</span>right <span class="pl-k">=</span> buildTree(inorder, rootIndex <span class="pl-k">+</span> <span class="pl-c1">1</span>, iEnd, postorder, pStart <span class="pl-k">+</span> (rootIndex <span class="pl-k">-</span> iStart), pEnd <span class="pl-k">-</span> <span class="pl-c1">1</span>, map);
    <span class="pl-k">return</span> root;
}</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-107-binary-tree-level-order-traversal-ii" class="anchor" href="https://github.com/wishyouhappy/Algorithm#107-binary-tree-level-order-traversal-ii" aria-hidden="true"><span class="octicon octicon-link"></span></a>107 Binary Tree Level Order Traversal II</h3>

<p><strong>Idea</strong>: The solution below is same with 102  Binary Tree Level Order Traversal. The only difference is that when insert into list of list, we insert at index 0. Is there any other better solution other than the this method and recursion version of level order traverse? </p>

<p><strong>Solution</strong>:</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> levelOrderBottom(<span class="pl-smi">TreeNode</span> root) {
    <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>();
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
        <span class="pl-k">return</span> res;
    }
    <span class="pl-k">Queue&lt;<span class="pl-smi">TreeNode</span>&gt;</span> queue <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">LinkedList&lt;<span class="pl-smi">TreeNode</span>&gt;</span>();
    queue<span class="pl-k">.</span>offer(root);
    <span class="pl-k">while</span> (<span class="pl-k">!</span>queue<span class="pl-k">.</span>isEmpty()) {
        <span class="pl-k">int</span> size <span class="pl-k">=</span> queue<span class="pl-k">.</span>size();
        <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> cur <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> size; i<span class="pl-k">++</span>) {
            <span class="pl-smi">TreeNode</span> temp <span class="pl-k">=</span> queue<span class="pl-k">.</span>poll();
            <span class="pl-k">if</span> (temp<span class="pl-k">.</span>left <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
                queue<span class="pl-k">.</span>offer(temp<span class="pl-k">.</span>left);
            }
            <span class="pl-k">if</span> (temp<span class="pl-k">.</span>right <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
                queue<span class="pl-k">.</span>offer(temp<span class="pl-k">.</span>right);
            }
            cur<span class="pl-k">.</span>add(temp<span class="pl-k">.</span>val);
        }
        res<span class="pl-k">.</span>add(<span class="pl-c1">0</span>, cur);
    }
    <span class="pl-k">return</span> res;
}</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-108-convert-sorted-array-to-binary-search-tree" class="anchor" href="https://github.com/wishyouhappy/Algorithm#108-convert-sorted-array-to-binary-search-tree" aria-hidden="true"><span class="octicon octicon-link"></span></a>108 Convert Sorted Array to Binary Search Tree</h3>

<blockquote>
<p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p>
</blockquote>

<p><strong>Idea</strong>: </p>

<p>Just find the mid of the list each time and create the tree from root.</p>

<p>root = mid</p>

<p>root.left = mid of (0, mid -1)</p>

<p>root.right = mid of (mid + 1, end)</p>

<p><strong>Time: O(n)</strong>, because we need to traverse all the nodes. </p>

<p><strong>Space</strong> O(lg(n)) for recursion. </p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-smi">TreeNode</span> sortedArrayToBST(<span class="pl-k">int</span>[] nums) {
        <span class="pl-k">if</span> (nums <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> nums<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">null</span>;
        }
        <span class="pl-k">return</span> sortedArrayToBST(nums, <span class="pl-c1">0</span>, nums<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>);
    }

    <span class="pl-k">public</span> <span class="pl-smi">TreeNode</span> sortedArrayToBST(<span class="pl-k">int</span>[] nums, <span class="pl-k">int</span> start, <span class="pl-k">int</span> end) {
        <span class="pl-k">if</span> (start <span class="pl-k">&gt;</span> end) {
            <span class="pl-k">return</span> <span class="pl-c1">null</span>;
        }
        <span class="pl-k">int</span> mid <span class="pl-k">=</span> start <span class="pl-k">+</span> (end <span class="pl-k">-</span> start) <span class="pl-k">/</span> <span class="pl-c1">2</span>;
        <span class="pl-smi">TreeNode</span> root <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">TreeNode</span>(nums[mid]);
        root<span class="pl-k">.</span>left <span class="pl-k">=</span> sortedArrayToBST(nums, start, mid <span class="pl-k">-</span> <span class="pl-c1">1</span>);
        root<span class="pl-k">.</span>right <span class="pl-k">=</span> sortedArrayToBST(nums, mid <span class="pl-k">+</span> <span class="pl-c1">1</span>, end);
        <span class="pl-k">return</span> root;
    }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-109-convert-sorted-list-to-binary-search-tree" class="anchor" href="https://github.com/wishyouhappy/Algorithm#109-convert-sorted-list-to-binary-search-tree" aria-hidden="true"><span class="octicon octicon-link"></span></a>109 Convert Sorted List to Binary Search Tree</h3>

<blockquote>
<p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p>
</blockquote>

<p><strong>Idea</strong>: </p>

<p>1) solution1: Bottom-up</p>

<p>The list is sorted and we need to convert it to a <strong>balanced BST</strong>. When visit the linkedlist, we can only visit node by node. Thus we visit the nodes in ascending order: <strong>Inorder Traversal !</strong>. Thus, we create the binary tree <strong>Bottom-up</strong>. The bottom-up approach enables us to access the list in its order while creating nodes.</p>

<p><strong>Time O(n)</strong></p>

<p><strong>Space</strong>: O(n) + O(lgn) = O(n)</p>

<p>2) solution2 : Top-down</p>

<p>Just find the mid of the list each time and create the tree from root.
root = mid
root.left = mid of (0, mid -1)
root.right = mid of (mid + 1, end)</p>

<p><strong>Time: O(nlgn)</strong>  T(n) = 2 * T(n/2) + O(n). Solve it we get T(n) = O(nlgn)</p>

<p><strong>Space</strong>: O(n) + O(lgn) = O(n)</p>

<p>3) solution3: </p>

<p>Store all the nodes in an array, then use the array to create the BST. just like the method in  * <a href="https://github.com/wishyouhappy/Algorithm#108-convert-sorted-array-to-binary-search-tree">108 Convert Sorted Array to Binary Search Tree</a>. However, not recommend this method. If we do in this way, then this question is meaningless. </p>

<p><strong>Time: O(n)</strong></p>

<p><strong>Space</strong>: O(n) + O(lgn) = O(n)</p>

<p><em>Solution1 code:</em></p>

<p><br></p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-smi">TreeNode</span> sortedListToBST(<span class="pl-smi">ListNode</span> head) {
    <span class="pl-k">if</span> (head <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
        <span class="pl-k">return</span> <span class="pl-c1">null</span>;
    }
    <span class="pl-k">int</span> len <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-smi">ListNode</span> temp <span class="pl-k">=</span> head;
    <span class="pl-k">while</span> (temp <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
        temp <span class="pl-k">=</span> temp<span class="pl-k">.</span>next;
        len<span class="pl-k">++</span>;
    }
    <span class="pl-k">ListNode</span>[] h <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">ListNode</span>[<span class="pl-c1">1</span>];
    h[<span class="pl-c1">0</span>] <span class="pl-k">=</span> head;
    <span class="pl-k">return</span> sortedListToBST(h, <span class="pl-c1">0</span>, len <span class="pl-k">-</span> <span class="pl-c1">1</span>);
}

<span class="pl-k">public</span> <span class="pl-smi">TreeNode</span> sortedListToBST(<span class="pl-k">ListNode</span>[] h, <span class="pl-k">int</span> start, <span class="pl-k">int</span> end) {
    <span class="pl-k">if</span> (start <span class="pl-k">&gt;</span> end) {
        <span class="pl-k">return</span> <span class="pl-c1">null</span>;
    }
    <span class="pl-k">int</span> mid <span class="pl-k">=</span> start <span class="pl-k">+</span> (end <span class="pl-k">-</span> start) <span class="pl-k">/</span> <span class="pl-c1">2</span>;
    <span class="pl-smi">TreeNode</span> left <span class="pl-k">=</span> sortedListToBST(h, start, mid <span class="pl-k">-</span> <span class="pl-c1">1</span>);
    <span class="pl-smi">TreeNode</span> root <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">TreeNode</span>(h[<span class="pl-c1">0</span>]<span class="pl-k">.</span>val);
    h[<span class="pl-c1">0</span>] <span class="pl-k">=</span> h[<span class="pl-c1">0</span>]<span class="pl-k">.</span>next;
    root<span class="pl-k">.</span>left <span class="pl-k">=</span> left;
    root<span class="pl-k">.</span>right <span class="pl-k">=</span> sortedListToBST(h, mid <span class="pl-k">+</span> <span class="pl-c1">1</span>, end);
    <span class="pl-k">return</span> root;
}
</pre></div>

<p><em>solution 2 code</em></p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-smi">TreeNode</span> sortedListToBST(<span class="pl-smi">ListNode</span> head) {
    <span class="pl-k">if</span>(head <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
        <span class="pl-k">return</span> <span class="pl-c1">null</span>;
    }
    <span class="pl-k">if</span>(head<span class="pl-k">.</span>next <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
        <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-smi">TreeNode</span>(head<span class="pl-k">.</span>val);
    }
    <span class="pl-smi">ListNode</span> pre <span class="pl-k">=</span> getMidPre(head);
    <span class="pl-smi">ListNode</span> mid <span class="pl-k">=</span> pre<span class="pl-k">.</span>next;
    pre<span class="pl-k">.</span>next <span class="pl-k">=</span> <span class="pl-c1">null</span>;
    <span class="pl-smi">TreeNode</span> root<span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">TreeNode</span>(mid<span class="pl-k">.</span>val);
    root<span class="pl-k">.</span>left <span class="pl-k">=</span> sortedListToBST(head);
    root<span class="pl-k">.</span>right <span class="pl-k">=</span> sortedListToBST(mid<span class="pl-k">.</span>next);
    <span class="pl-k">return</span> root;
 }

 <span class="pl-k">public</span> <span class="pl-smi">ListNode</span> getMidPre(<span class="pl-smi">ListNode</span> head) {
    <span class="pl-smi">ListNode</span> fast <span class="pl-k">=</span> head;  
    <span class="pl-smi">ListNode</span> pre <span class="pl-k">=</span> head;  
    <span class="pl-k">while</span> (fast<span class="pl-k">!=</span><span class="pl-c1">null</span>) {  
        fast <span class="pl-k">=</span> fast<span class="pl-k">.</span>next;  
        <span class="pl-k">if</span> (fast <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
            fast <span class="pl-k">=</span> fast<span class="pl-k">.</span>next;  
            pre <span class="pl-k">=</span> head;  
            head <span class="pl-k">=</span> head<span class="pl-k">.</span>next;  
        } 
    }  
    <span class="pl-k">return</span> pre;  
 }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-110-balanced-binary-tree" class="anchor" href="https://github.com/wishyouhappy/Algorithm#110-balanced-binary-tree" aria-hidden="true"><span class="octicon octicon-link"></span></a>110 Balanced Binary Tree</h3>

<blockquote>
<p>Given a binary tree, determine if it is height-balanced.</p>

<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>
</blockquote>

<p><strong>Idea</strong>: Check the height diffrence of  subtrees. If difference greater than 1, return false</p>

<p><strong>Solution 1</strong> : time O(nlgn)</p>

<p><strong>Time analysis</strong>: </p>

<ul>
<li>1) master theory: getHeight complexity is O(n), thus T(n) = 2T(n/2) + n. Solve it we get T = O(nlgn)</li>
<li>2) recursion tree: O(n) + O(n) ......., lgn layers. Thus the total time is nlgn</li>
</ul>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">boolean</span> isBalanced(<span class="pl-smi">TreeNode</span> root) {
    <span class="pl-c">// Write your solution here.</span>
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }
    <span class="pl-k">if</span> (<span class="pl-smi">Math</span><span class="pl-k">.</span>abs(getHeight(root<span class="pl-k">.</span>left) <span class="pl-k">-</span> getHeight(root<span class="pl-k">.</span>right)) <span class="pl-k">&gt;</span> <span class="pl-c1">1</span>) {
      <span class="pl-k">return</span> <span class="pl-c1">false</span>;
    }
    <span class="pl-k">return</span> isBalanced(root<span class="pl-k">.</span>left) <span class="pl-k">&amp;&amp;</span> isBalanced(root<span class="pl-k">.</span>right);
  }

  <span class="pl-k">public</span> <span class="pl-k">int</span> getHeight(<span class="pl-smi">TreeNode</span> root) {
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span> <span class="pl-c1">0</span>;
    }
    <span class="pl-k">return</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(getHeight(root<span class="pl-k">.</span>left), getHeight(root<span class="pl-k">.</span>right)) <span class="pl-k">+</span> <span class="pl-c1">1</span>;
  }</pre></div>

<p><br>
<strong>Solution 2</strong>: time : O(n)</p>

<p>In this method, we omit repeated getheight part. Thus the time is better than the fist solution</p>

<p><strong>Time analysis</strong>: </p>

<ul>
<li>1) master theory: thus T(n) = 2T(n/2) + 1. Solve it we get T = O(n)</li>
<li>2) recursion tree: 2 ^ lgn  = O(n)</li>
</ul>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">boolean</span> isBalanced(<span class="pl-smi">TreeNode</span> root){
        <span class="pl-k">return</span> helper(root) <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>;
    }

    <span class="pl-k">public</span> <span class="pl-k">int</span> helper(<span class="pl-smi">TreeNode</span> root){
        <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        }
        <span class="pl-k">int</span> left <span class="pl-k">=</span> helper(root<span class="pl-k">.</span>left);
        <span class="pl-k">int</span> right <span class="pl-k">=</span> helper(root<span class="pl-k">.</span>right);
        <span class="pl-k">if</span> (left <span class="pl-k">&lt;</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> right <span class="pl-k">&lt;</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>abs(left <span class="pl-k">-</span> right) <span class="pl-k">&gt;</span> <span class="pl-c1">1</span>) {
            <span class="pl-k">return</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
        }
        <span class="pl-k">return</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(left, right) <span class="pl-k">+</span> <span class="pl-c1">1</span>;
    }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-111-minimum-depth-of-binary-tree" class="anchor" href="https://github.com/wishyouhappy/Algorithm#111-minimum-depth-of-binary-tree" aria-hidden="true"><span class="octicon octicon-link"></span></a>111 Minimum Depth of Binary Tree</h3>

<blockquote>
<p>Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
</blockquote>

<p><strong>Idea</strong>: The * <a href="https://github.com/wishyouhappy/Algorithm#104-maximum-depth-of-binary-tree">104 Maximum Depth of Binary Tree</a> let us to calculate the max depth of the binary tree. </p>

<p>Thus max depth = Math.max(maxDepth(root.left), maxDepth(root.left)) + 1</p>

<p>In this problem, we need to calculate the minumum depth. Is the minimum depth = Math.min(minDepth(root.left), minDepth(root.left)) + 1.</p>

<p>This is partly true. When the left child and right child all exist, this is true. What if only left child or right child exist? </p>

<p>In these two cases:</p>

<p>min depth = minDepth(root.left) + 1 when right child does not exist</p>

<p>min depth = minDepth(root.right) + 1 when left child does not exist</p>

<p><strong>Solution</strong>:</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">int</span> minDepth(<span class="pl-smi">TreeNode</span> root) {
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span> <span class="pl-c1">0</span>;
    }
    <span class="pl-k">if</span> (root<span class="pl-k">.</span>left <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
        <span class="pl-k">return</span> minDepth(root<span class="pl-k">.</span>right) <span class="pl-k">+</span> <span class="pl-c1">1</span>;
    }
    <span class="pl-k">if</span> (root<span class="pl-k">.</span>right <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
        <span class="pl-k">return</span> minDepth(root<span class="pl-k">.</span>left) <span class="pl-k">+</span> <span class="pl-c1">1</span>;
    }
    <span class="pl-k">return</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>min(minDepth(root<span class="pl-k">.</span>left), minDepth(root<span class="pl-k">.</span>right)) <span class="pl-k">+</span> <span class="pl-c1">1</span>;
}</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-114-flatten-binary-tree-to-linked-list" class="anchor" href="https://github.com/wishyouhappy/Algorithm#114-flatten-binary-tree-to-linked-list" aria-hidden="true"><span class="octicon octicon-link"></span></a>114 Flatten Binary Tree to Linked List</h3>

<blockquote>
<p>Given a binary tree, flatten it to a linked list <strong>in-place</strong>.</p>
</blockquote>

<pre>For example,
Given

         1
        / \
       2   5
      / \   \
     3   4   6
The flattened tree should look like:
   1
    \
     2
      \
       3
        \
         4
          \
           5
            \
             6

</pre>

<p><strong>Idea</strong>: From the structure of the original tree and result tree, we know that we need to traverse the tree preorder. We can solve it recursively or use a stack to record the right child. </p>

<p><strong>Attention</strong>: </p>

<ul>
<li><p>1) we can use a fake node pre so that each time we can add the current node to the right of pre, set pre.left = null and recursively solve this problem. </p></li>
<li><p>2) We need to save the right child, because the right child has changed when we visit the left child. </p></li>
</ul>

<p><em>Reversion code</em> : </p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">void</span> flatten(<span class="pl-smi">TreeNode</span> root){
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
        <span class="pl-k">return</span>;
    }
    <span class="pl-k">TreeNode</span>[] pre <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">TreeNode</span>[<span class="pl-c1">1</span>];
    pre[<span class="pl-c1">0</span>] <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">TreeNode</span>(<span class="pl-k">-</span><span class="pl-c1">1</span>);
    flatten(root, pre);
}

<span class="pl-k">public</span> <span class="pl-k">void</span> flatten(<span class="pl-smi">TreeNode</span> root, <span class="pl-k">TreeNode</span>[] pre) {
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
        <span class="pl-k">return</span>;
    }
    <span class="pl-smi">TreeNode</span> right <span class="pl-k">=</span> root<span class="pl-k">.</span>right;
    pre[<span class="pl-c1">0</span>]<span class="pl-k">.</span>left <span class="pl-k">=</span> <span class="pl-c1">null</span>;
    pre[<span class="pl-c1">0</span>]<span class="pl-k">.</span>right <span class="pl-k">=</span> root;
    pre[<span class="pl-c1">0</span>] <span class="pl-k">=</span> root;
    flatten(root<span class="pl-k">.</span>left, pre);
    flatten(right, pre);
}</pre></div>

<p><em>Stack</em>:</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">void</span> flatten(<span class="pl-smi">TreeNode</span> root){
   <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
       <span class="pl-k">return</span>;
   }
   <span class="pl-smi">TreeNode</span> pre <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">TreeNode</span>(<span class="pl-k">-</span><span class="pl-c1">1</span>);
   <span class="pl-k">Stack&lt;<span class="pl-smi">TreeNode</span>&gt;</span> stack <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">Stack&lt;<span class="pl-smi">TreeNode</span>&gt;</span>();
   <span class="pl-k">while</span> (<span class="pl-k">!</span>stack<span class="pl-k">.</span>isEmpty() <span class="pl-k">||</span> root <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
       <span class="pl-k">if</span> (root <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
           pre<span class="pl-k">.</span>right <span class="pl-k">=</span> root;
           pre<span class="pl-k">.</span>left <span class="pl-k">=</span> <span class="pl-c1">null</span>;
           pre <span class="pl-k">=</span> root;
           stack<span class="pl-k">.</span>push(root<span class="pl-k">.</span>right);
           root <span class="pl-k">=</span> root<span class="pl-k">.</span>left;
       } <span class="pl-k">else</span> {
           root <span class="pl-k">=</span> stack<span class="pl-k">.</span>pop();
       }
   }
}

</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-118-pascal-triangle" class="anchor" href="https://github.com/wishyouhappy/Algorithm#118-pascal-triangle" aria-hidden="true"><span class="octicon octicon-link"></span></a>118 Pascal Triangle</h3>

<blockquote>
<p>Given numRows, generate the first numRows of Pascal's triangle.</p>
</blockquote>

<pre>For example, given numRows = 5,
Return

[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]

</pre>

<p><strong>Idea</strong>: First row : 1. Then each row is calculated based on the last row. In each row the first element and the last element is 1. Thus val = j == 0 || j == pre.size() ? 1 : pre.get(j-1)+pre.get(j);</p>

<div class="highlight highlight-java"><pre>            <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> generate(<span class="pl-k">int</span> numRows) {
            <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> list <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>();
            <span class="pl-k">if</span>(numRows <span class="pl-k">&lt;=</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> list;
            <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> firstR <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
            firstR<span class="pl-k">.</span>add(<span class="pl-c1">1</span>);
            list<span class="pl-k">.</span>add(firstR);
            <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;</span> numRows; i<span class="pl-k">++</span>){
                <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> current <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
                <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> pre <span class="pl-k">=</span> list<span class="pl-k">.</span>get(list<span class="pl-k">.</span>size()<span class="pl-k">-</span><span class="pl-c1">1</span>);
                <span class="pl-k">for</span>(<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;=</span> pre<span class="pl-k">.</span>size(); j<span class="pl-k">++</span>){
                    <span class="pl-k">int</span> val <span class="pl-k">=</span> j <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> j <span class="pl-k">==</span> pre<span class="pl-k">.</span>size() <span class="pl-k">?</span> <span class="pl-c1">1</span> <span class="pl-k">:</span> pre<span class="pl-k">.</span>get(j<span class="pl-k">-</span><span class="pl-c1">1</span>)<span class="pl-k">+</span>pre<span class="pl-k">.</span>get(j);
                    current<span class="pl-k">.</span>add(val);
                }
                list<span class="pl-k">.</span>add(current);
            }
            <span class="pl-k">return</span> list;
        }

</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-119-pascal-triangle-ii" class="anchor" href="https://github.com/wishyouhappy/Algorithm#119-pascal-triangle-ii" aria-hidden="true"><span class="octicon octicon-link"></span></a>119 Pascal Triangle II</h3>

<blockquote>
<p>Given an index k, return the kth row of the Pascal's triangle.</p>
</blockquote>

<p>For example, given k = 3,
Return [1,3,3,1].</p>

<p>Note:
Could you optimize your algorithm to use only O(k) extra space?</p>

<p><strong>Idea</strong>: If we can only use O(k) space, then we need to store all rows info in a single array. So the current row is calculated based on the last row. Eg: the last row is 1 2 1, we need to replace it with 1 3 3 1. We can ignore the first 1. Then 3 = 1 + 2 = pre + list.get(j). We need to store the current elment before we overwrite it. </p>

<p>If there is no other requirements, then we can just use the result in <a href="https://github.com/wishyouhappy/Algorithm#118-pascal-triangle">118 Pascal Triangle</a> and get the last row. </p>

<p><strong>Attention</strong>:</p>

<ul>
<li>1) k = 3, we return the fourth row.</li>
<li>2) we need to store the current elment before we overwrite it. </li>
</ul>

<p><br></p>

<div class="highlight highlight-java"><pre>     <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> getRow(<span class="pl-k">int</span> rowIndex) {
    <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> list <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
        <span class="pl-k">if</span>(rowIndex <span class="pl-k">&lt;</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> list;
        list<span class="pl-k">.</span>add(<span class="pl-c1">1</span>);
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> rowIndex; i<span class="pl-k">++</span>){
            <span class="pl-k">int</span> pre <span class="pl-k">=</span> <span class="pl-c1">1</span>;
            <span class="pl-k">int</span> current <span class="pl-k">=</span> <span class="pl-c1">0</span>;
            <span class="pl-k">for</span>(<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;</span> list<span class="pl-k">.</span>size(); j<span class="pl-k">++</span>){
                <span class="pl-k">if</span>(j <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">continue</span>;
                current <span class="pl-k">=</span> list<span class="pl-k">.</span>get(j);
                list<span class="pl-k">.</span>set(j, pre <span class="pl-k">+</span> list<span class="pl-k">.</span>get(j));
                pre <span class="pl-k">=</span> current;
            } 
            list<span class="pl-k">.</span>add(<span class="pl-c1">1</span>);
        }
        <span class="pl-k">return</span> list;
    }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-120-triangle" class="anchor" href="https://github.com/wishyouhappy/Algorithm#120-triangle" aria-hidden="true"><span class="octicon octicon-link"></span></a>120 Triangle</h3>

<blockquote>
<p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p>
</blockquote>

<pre>For example, given the following triangle
[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).

Note:
Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.
</pre>

<p><strong>Idea</strong>: Begin from the second-last layer, calculate the min sum of the last layer and last second layer, then continue the second-last layer and third-last layer....eg: the sum of last layer and last-second layer: min(4, 1) + 6, min(1, 8) + 5, min(8, 3) + 7. If we are only allowed to use O(n) space, then we need to replace the sum each time.</p>

<p>For example: Assume we use int[] res = new int[triangle.get(triangle.size()-1).size()] to store the sum</p>

<pre>Original triangle:             

[                              
     [2],                      
    [3,4],                    
   [6,5,7],                    
  [4,1,8,3]                  
] 


res array:
11
9, 10
7, 6, 10
4, 1, 8, 3

</pre>

<p><strong>Space</strong>: O(n)</p>

<p>We can also calculate from the top layer, then go down. It's similar to the method above. It's easier to handle the index if we begin from the last layer.</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> minimumTotal(<span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> triangle) {
        <span class="pl-k">if</span>(triangle <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> triangle<span class="pl-k">.</span>size() <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span>[] res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[triangle<span class="pl-k">.</span>get(triangle<span class="pl-k">.</span>size()<span class="pl-k">-</span><span class="pl-c1">1</span>)<span class="pl-k">.</span>size()];
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> res<span class="pl-k">.</span>length; i<span class="pl-k">++</span>){
            res[i] <span class="pl-k">=</span> triangle<span class="pl-k">.</span>get(triangle<span class="pl-k">.</span>size()<span class="pl-k">-</span><span class="pl-c1">1</span>)<span class="pl-k">.</span>get(i);
        }
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> triangle<span class="pl-k">.</span>size()<span class="pl-k">-</span><span class="pl-c1">2</span>; i <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>; i<span class="pl-k">--</span>){
            <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> current <span class="pl-k">=</span> triangle<span class="pl-k">.</span>get(i);
            <span class="pl-k">for</span>(<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;</span> current<span class="pl-k">.</span>size(); j<span class="pl-k">++</span>){
                res[j] <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>min(res[j], res[j<span class="pl-k">+</span><span class="pl-c1">1</span>]) <span class="pl-k">+</span> current<span class="pl-k">.</span>get(j);
            }
        }
        <span class="pl-k">return</span> res[<span class="pl-c1">0</span>];
     }</pre></div>

<p><strong>Solution 2</strong>: From top to bottom:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-c">/* from top to bottom */</span>
     <span class="pl-k">public</span> <span class="pl-k">int</span> minimumTotal1(<span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> triangle) {
           <span class="pl-k">if</span>(triangle <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> triangle<span class="pl-k">.</span>size() <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
           <span class="pl-k">int</span>[] sum <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[triangle<span class="pl-k">.</span>get(triangle<span class="pl-k">.</span>size()<span class="pl-k">-</span><span class="pl-c1">1</span>)<span class="pl-k">.</span>size()];
           sum[<span class="pl-c1">0</span>] <span class="pl-k">=</span> triangle<span class="pl-k">.</span>get(<span class="pl-c1">0</span>)<span class="pl-k">.</span>get(<span class="pl-c1">0</span>);
           <span class="pl-k">int</span> min <span class="pl-k">=</span> <span class="pl-smi">Integer</span><span class="pl-c1"><span class="pl-k">.</span>MAX_VALUE</span>;
           <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;</span> triangle<span class="pl-k">.</span>size(); i<span class="pl-k">++</span>){
               <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> cur <span class="pl-k">=</span> triangle<span class="pl-k">.</span>get(i);
               <span class="pl-k">for</span>(<span class="pl-k">int</span> j <span class="pl-k">=</span> cur<span class="pl-k">.</span>size() <span class="pl-k">-</span><span class="pl-c1">1</span> ; j <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>; j<span class="pl-k">--</span>){
                  <span class="pl-k">if</span>(j <span class="pl-k">==</span> cur<span class="pl-k">.</span>size()<span class="pl-k">-</span><span class="pl-c1">1</span>) sum[j] <span class="pl-k">=</span> cur<span class="pl-k">.</span>get(j) <span class="pl-k">+</span> sum[j<span class="pl-k">-</span><span class="pl-c1">1</span>];
                  <span class="pl-k">else</span> <span class="pl-k">if</span>(j <span class="pl-k">==</span> <span class="pl-c1">0</span>) sum[j] <span class="pl-k">=</span> cur<span class="pl-k">.</span>get(j) <span class="pl-k">+</span> sum[<span class="pl-c1">0</span>];
                  <span class="pl-k">else</span> sum[j] <span class="pl-k">=</span> cur<span class="pl-k">.</span>get(j) <span class="pl-k">+</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>min(sum[j], sum[j<span class="pl-k">-</span><span class="pl-c1">1</span>]);
               }
           }
           <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> sum<span class="pl-k">.</span>length; i<span class="pl-k">++</span>){
               <span class="pl-k">if</span>(min <span class="pl-k">&gt;</span> sum[i]) min <span class="pl-k">=</span> sum[i];
           }
           <span class="pl-k">return</span> min;
         }


</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-121-best-time-to-buy-and-sell-stock" class="anchor" href="https://github.com/wishyouhappy/Algorithm#121-best-time-to-buy-and-sell-stock" aria-hidden="true"><span class="octicon octicon-link"></span></a>121 Best Time to Buy and Sell Stock</h3>

<blockquote>
<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>

<p>If you were only permitted to complete <strong>at most one transaction</strong> (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
</blockquote>

<p><strong>Idea:</strong> We are allowed at most one transaction. Thus we only need to maintain a local  min stock price before prices[i]. Traverse prices one pass to get the max profit.</p>

<p><strong>max = Math.max(max, prices[i] - min)</strong> </p>

<p><strong>min = Math.min(min, prices[i])</strong></p>

<p><strong>Time complexity</strong>: O(n)</p>

<p><strong>Space</strong> : O(1)</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> maxProfit(<span class="pl-k">int</span>[] prices){
        <span class="pl-k">if</span>(prices <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> prices<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> max <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> min <span class="pl-k">=</span> prices[<span class="pl-c1">0</span>];
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;</span> prices<span class="pl-k">.</span>length; i<span class="pl-k">++</span>){
            max <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(max, prices[i] <span class="pl-k">-</span> min);
            min <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>min(min, prices[i]);
        }
        <span class="pl-k">return</span> max;
    }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-122-best-time-to-buy-and-sell-stock-ii" class="anchor" href="https://github.com/wishyouhappy/Algorithm#122-best-time-to-buy-and-sell-stock-ii" aria-hidden="true"><span class="octicon octicon-link"></span></a>122 Best Time to Buy and Sell Stock II</h3>

<blockquote>
<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>

<p>Design an algorithm to find the maximum profit. You may complete <strong>as many transactions</strong> as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
</blockquote>

<p><strong>Idea:</strong> We are allowed as many transactions. Thus we only need to each neighbor pair, if prices[i] &gt; prices[i-1], we add the difference to our result. We can get the max one pass. </p>

<p><strong>dif = Math.max(0, prices[i] - prices[i-1])</strong> </p>

<p><strong>max = max + dif</strong> </p>

<p><strong>Time complexity</strong>: O(n) </p>

<p><strong>Space</strong> : O(1)</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> maxProfit(<span class="pl-k">int</span>[] prices){
        <span class="pl-k">int</span> max <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> dif <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;</span> prices<span class="pl-k">.</span>length; i<span class="pl-k">++</span>){
            dif <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(<span class="pl-c1">0</span>, prices[i] <span class="pl-k">-</span> prices[i<span class="pl-k">-</span><span class="pl-c1">1</span>]);
            max <span class="pl-k">=</span> max <span class="pl-k">+</span> dif;
        }
        <span class="pl-k">return</span> max;
    }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-123-best-time-to-buy-and-sell-stock-iii" class="anchor" href="https://github.com/wishyouhappy/Algorithm#123-best-time-to-buy-and-sell-stock-iii" aria-hidden="true"><span class="octicon octicon-link"></span></a>123 Best Time to Buy and Sell Stock III</h3>

<blockquote>
<p>Say you have an array for which the ith element is the price of a given stock on day i. </p>

<p>Design an algorithm to find the maximum profit. You may complete <strong>at most two transactions</strong>.</p>

<p>Note:
You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
</blockquote>

<p><strong>Idea:</strong> We are only allowed  at most two transactions. Thus, we can use two arrays to record the max profit before profits[i], including i, denote as l[i], and max profits after profits[i], including i, denote as r[i]. Then find the max of l[i] + r[i]. </p>

<p><strong>Time complexity</strong>: O(n) </p>

<p><strong>Space</strong> : O(n)</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> maxProfit(<span class="pl-k">int</span>[] prices){
        <span class="pl-k">if</span>(prices <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> prices<span class="pl-k">.</span>length <span class="pl-k">&lt;=</span> <span class="pl-c1">1</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span>[] l <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[prices<span class="pl-k">.</span>length];
        <span class="pl-k">int</span>[] r <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[prices<span class="pl-k">.</span>length];
        <span class="pl-k">int</span> max <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> min <span class="pl-k">=</span> prices[<span class="pl-c1">0</span>];
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;</span> prices<span class="pl-k">.</span>length; i<span class="pl-k">++</span>){
            max <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(max, prices[i] <span class="pl-k">-</span> min);
            min <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>min(min, prices[i]);
            l[i] <span class="pl-k">=</span> max;
        }
        <span class="pl-k">int</span> maxR <span class="pl-k">=</span> prices[prices<span class="pl-k">.</span>length<span class="pl-k">-</span><span class="pl-c1">1</span>];
        max <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> prices<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">2</span>; i <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>; i<span class="pl-k">--</span>){
            max <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(max, maxR <span class="pl-k">-</span> prices[i]);
            maxR <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(maxR, prices[i]);
            r[i] <span class="pl-k">=</span> max;
        }
        max <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> prices<span class="pl-k">.</span>length; i<span class="pl-k">++</span>){
            max <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(max, l[i] <span class="pl-k">+</span> r[i]);
        }
        <span class="pl-k">return</span> max;
    }</pre></div>

<p><strong>Another solution:</strong> </p>

<p>global[i][j]: denotes max profit, at most j transactions before day i: </p>

<p><strong>global[i][j]=max(local[i][j],global[i-1][j])</strong></p>

<p>local[i][j]: denotes max profit, at most j transactions before day i, and last transaction is saled on day i: </p>

<p><strong>local[i][j]=max(global[i-1][j-1]+max(diff,0),local[i-1][j]+diff)</strong></p>

<p>From above, we know that we can change the two dimensional array to one dimensional to save space. Because we only use two rows in the two dimensional array. </p>

<p><strong>Time complexity</strong>: O(n) </p>

<p><strong>Space</strong> : O(1) (O(k), but k is 2 in this problem)</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> maxProfit1(<span class="pl-k">int</span>[] prices){
        <span class="pl-k">return</span> maxProfit(prices, <span class="pl-c1">2</span>);
    }
    <span class="pl-k">public</span> <span class="pl-k">int</span> maxProfit(<span class="pl-k">int</span>[] prices, <span class="pl-k">int</span> k){
        <span class="pl-k">if</span>(prices <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> prices<span class="pl-k">.</span>length <span class="pl-k">&lt;=</span> <span class="pl-c1">1</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span>[] global <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[k<span class="pl-k">+</span><span class="pl-c1">1</span>];
        <span class="pl-k">int</span>[] local <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[k<span class="pl-k">+</span><span class="pl-c1">1</span>];
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;</span> prices<span class="pl-k">.</span>length; i<span class="pl-k">++</span>){
            <span class="pl-k">int</span> dif <span class="pl-k">=</span> prices[i] <span class="pl-k">-</span> prices[i<span class="pl-k">-</span><span class="pl-c1">1</span>];
            <span class="pl-k">for</span>(<span class="pl-k">int</span> j <span class="pl-k">=</span> k; j <span class="pl-k">&gt;=</span> <span class="pl-c1">1</span>; j<span class="pl-k">--</span>){
                local[j] <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(global[j<span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">+</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(dif, <span class="pl-c1">0</span>), local[j] <span class="pl-k">+</span> dif);
                global[j] <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(local[j], global[j]);
            }
        }
        <span class="pl-k">return</span> global[k];
    }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-124-binary-tree-maximum-path-sum" class="anchor" href="https://github.com/wishyouhappy/Algorithm#124-binary-tree-maximum-path-sum" aria-hidden="true"><span class="octicon octicon-link"></span></a>124 Binary Tree Maximum Path Sum</h3>

<blockquote>
<p>Given a binary tree, find the maximum path sum.</p>

<p>The path may start and end at any node in the tree.</p>
</blockquote>

<pre>For example:
Given the below binary tree,

       1
      / \
     2   3
Return 6.

</pre>

<p><strong>Idea</strong>: In this problem, the path can start and end at any node. Thus we can divide the path into 3 parts: left path, root, right path</p>

<p>In the solution below, we maintain a maxSum, this is same with the general max path problem. And in the recursion part, we calculate the max left path root at a certain node and the max right path at a node, update the maxSum and return the max path of left path part or right path part. </p>

<p><strong>Time</strong>:</p>

<p>T(n) = 2T(n/2) + 1. Solve it we get T(n) = O(n)</p>

<p><strong>Solution</strong>:</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">int</span> maxPathSum(<span class="pl-smi">TreeNode</span> root) {
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
        <span class="pl-k">return</span> <span class="pl-c1">0</span>;
    }
    <span class="pl-k">int</span>[] maxSum <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[<span class="pl-c1">1</span>];
    maxSum[<span class="pl-c1">0</span>] <span class="pl-k">=</span> root<span class="pl-k">.</span>val;
    maxPathSum(root, maxSum);
    <span class="pl-k">return</span> maxSum[<span class="pl-c1">0</span>];
}

<span class="pl-k">public</span> <span class="pl-k">int</span> maxPathSum(<span class="pl-smi">TreeNode</span> root, <span class="pl-k">int</span>[] maxSum) {
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
        <span class="pl-k">return</span> <span class="pl-c1">0</span>;
    }
    <span class="pl-k">int</span> left <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(maxPathSum(root<span class="pl-k">.</span>left, maxSum), <span class="pl-c1">0</span>);
    <span class="pl-k">int</span> right <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(maxPathSum(root<span class="pl-k">.</span>right, maxSum), <span class="pl-c1">0</span>);
    maxSum[<span class="pl-c1">0</span>] <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(root<span class="pl-k">.</span>val <span class="pl-k">+</span> left <span class="pl-k">+</span> right, maxSum[<span class="pl-c1">0</span>]);
    <span class="pl-k">return</span> root<span class="pl-k">.</span>val <span class="pl-k">+</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(left, right);
}</pre></div>

<p><br></p>

<p><strong>Related</strong>: max path sum from leaf to leaf</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">int</span> maxPathSum(<span class="pl-smi">TreeNode</span> root) {
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span> <span class="pl-smi">Integer</span><span class="pl-c1"><span class="pl-k">.</span>MIN_VALUE</span>;
    }
    <span class="pl-k">int</span>[] max <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[<span class="pl-c1">1</span>];
    max[<span class="pl-c1">0</span>] <span class="pl-k">=</span> <span class="pl-smi">Integer</span><span class="pl-c1"><span class="pl-k">.</span>MIN_VALUE</span>;
    maxPathSum(root, max);
    <span class="pl-k">return</span> max[<span class="pl-c1">0</span>];
  }
  <span class="pl-k">private</span> <span class="pl-k">int</span> maxPathSum(<span class="pl-smi">TreeNode</span> root, <span class="pl-k">int</span>[] max) {
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span> <span class="pl-c1">0</span>;
    }
    <span class="pl-k">int</span> left <span class="pl-k">=</span> maxPathSum(root<span class="pl-k">.</span>left, max);
    <span class="pl-k">int</span> right <span class="pl-k">=</span> maxPathSum(root<span class="pl-k">.</span>right, max);
    <span class="pl-k">int</span> temp <span class="pl-k">=</span> left <span class="pl-k">+</span> right <span class="pl-k">+</span> root<span class="pl-k">.</span>key;
    <span class="pl-k">if</span> (temp <span class="pl-k">&gt;</span> max[<span class="pl-c1">0</span>] <span class="pl-k">&amp;&amp;</span> root<span class="pl-k">.</span>left <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> root<span class="pl-k">.</span>right <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
      max[<span class="pl-c1">0</span>] <span class="pl-k">=</span> temp;
    }
    <span class="pl-k">if</span> (root<span class="pl-k">.</span>left <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span> right <span class="pl-k">+</span> root<span class="pl-k">.</span>key;
    } <span class="pl-k">else</span> <span class="pl-k">if</span> (root<span class="pl-k">.</span>right <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span> left <span class="pl-k">+</span> root<span class="pl-k">.</span>key;
    } <span class="pl-k">else</span> {
      <span class="pl-k">return</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(left, right) <span class="pl-k">+</span> root<span class="pl-k">.</span>key;
    }
  }</pre></div>

<p><br></p>

<p><strong>Related</strong>:max path sum from node to node on root to leaf path. Allowed to contain only one node.</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">class</span> <span class="pl-en">Sum</span> {
    <span class="pl-k">int</span> val;
    <span class="pl-k">public</span> <span class="pl-en">Sum</span>(<span class="pl-k">int</span> <span class="pl-v">val</span>) {
      <span class="pl-v">this</span><span class="pl-k">.</span>val <span class="pl-k">=</span> val;
    }
  }
  <span class="pl-k">public</span> <span class="pl-k">int</span> maxPathSum(<span class="pl-smi">TreeNode</span> root) {
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span> <span class="pl-c1">0</span>;
    }
    <span class="pl-smi">Sum</span> sum <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Sum</span>(<span class="pl-smi">Integer</span><span class="pl-c1"><span class="pl-k">.</span>MIN_VALUE</span>);
    maxPathSum(root, <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>(), sum);
    <span class="pl-k">return</span> sum<span class="pl-k">.</span>val;
  }

  <span class="pl-k">private</span> <span class="pl-k">void</span> maxPathSum(<span class="pl-smi">TreeNode</span> root, <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> prefixList, <span class="pl-smi">Sum</span> sum) {
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span>;
    }
    prefixList<span class="pl-k">.</span>add(root<span class="pl-k">.</span>key);
    updateSum(prefixList, sum);
    maxPathSum(root<span class="pl-k">.</span>left, prefixList, sum);
    prefixList<span class="pl-k">.</span>remove(prefixList<span class="pl-k">.</span>size() <span class="pl-k">-</span> <span class="pl-c1">1</span>);
    prefixList<span class="pl-k">.</span>add(root<span class="pl-k">.</span>key);
    maxPathSum(root<span class="pl-k">.</span>right, prefixList, sum);
    prefixList<span class="pl-k">.</span>remove(prefixList<span class="pl-k">.</span>size() <span class="pl-k">-</span> <span class="pl-c1">1</span>);
  }

  <span class="pl-k">private</span> <span class="pl-k">void</span> updateSum(<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> prefixList, <span class="pl-smi">Sum</span> sum) {
    <span class="pl-k">int</span> num <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> prefixList<span class="pl-k">.</span>size() <span class="pl-k">-</span> <span class="pl-c1">1</span>; i <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>; i<span class="pl-k">--</span>) {
      num <span class="pl-k">+=</span> prefixList<span class="pl-k">.</span>get(i);
      sum<span class="pl-k">.</span>val <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(sum<span class="pl-k">.</span>val, num);
    }
  }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-126-word-ladder" class="anchor" href="https://github.com/wishyouhappy/Algorithm#126-word-ladder" aria-hidden="true"><span class="octicon octicon-link"></span></a>126 Word Ladder</h3>

<blockquote>
<p>Given two words (start and end), and a dictionary, find the length of shortest transformation sequence from start to end, such that:</p>
</blockquote>

<p>Only one letter can be changed at a time
Each intermediate word must exist in the dictionary
For example,</p>

<p>Given:</p>

<p>start = "hit"</p>

<p>end = "cog"</p>

<p>dict = ["hot","dot","dog","lot","log"]</p>

<p>As one shortest transformation is "hit" -&gt; "hot" -&gt; "dot" -&gt; "dog" -&gt; "cog",</p>

<p>return its length 5.</p>

<p>Note:</p>

<p>Return 0 if there is no such transformation sequence.</p>

<p>All words have the same length.</p>

<p>All words contain <strong>only lowercase alphabetic characters</strong>.</p>

<p><strong>Idea</strong>: This shortest transformation ladder is just like a shortest path in a graph. We teat each string as a graph node. If these two strings only have one different char, then we add an edge to these two nodes. When we come to the end string, we find the shortest path. </p>

<p>If we use bfs, we can use an additional lenqueue to record the path length of each node. </p>

<p><strong>Attention</strong>: </p>

<ul>
<li>1)Everytime, we visit a string in dict and add an edge, we need to remove it from dict. </li>
<li>2) char arr = start.toCharArray() should be inside the first for while loop. Otherwise, it may change more than one character of the string. </li>
</ul>

<p><strong>Solution</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">int</span> ladderLength(<span class="pl-smi">String</span> start, <span class="pl-smi">String</span> end, <span class="pl-k">Set&lt;<span class="pl-smi">String</span>&gt;</span> dict) {
            <span class="pl-k">if</span>(dict <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> dict<span class="pl-k">.</span>size() <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> start <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> end <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
            <span class="pl-k">Deque&lt;<span class="pl-smi">String</span>&gt;</span> queue <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">LinkedList&lt;<span class="pl-smi">String</span>&gt;</span>();
            <span class="pl-k">Deque&lt;<span class="pl-smi">Integer</span>&gt;</span> qlen <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">LinkedList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
            queue<span class="pl-k">.</span>offer(start);
            qlen<span class="pl-k">.</span>offer(<span class="pl-c1">1</span>);
            <span class="pl-k">while</span>(<span class="pl-k">!</span>queue<span class="pl-k">.</span>isEmpty()){
                start <span class="pl-k">=</span> queue<span class="pl-k">.</span>pollFirst();
                <span class="pl-k">int</span> len <span class="pl-k">=</span> qlen<span class="pl-k">.</span>pollFirst();
                <span class="pl-k">if</span>(start<span class="pl-k">.</span>equals(end)) <span class="pl-k">return</span> len;
                <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> start<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>){
                    <span class="pl-k">char</span>[] arr <span class="pl-k">=</span> start<span class="pl-k">.</span>toCharArray();
                    <span class="pl-k">for</span>(arr[i] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>; arr[i] <span class="pl-k">&lt;=</span><span class="pl-s"><span class="pl-pds">'</span>z<span class="pl-pds">'</span></span>; arr[i]<span class="pl-k">++</span>){
                        <span class="pl-smi">String</span> s <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">String</span>(arr);
                        <span class="pl-k">if</span>(dict<span class="pl-k">.</span>contains(s)){
                            queue<span class="pl-k">.</span>addLast(s);
                            qlen<span class="pl-k">.</span>addLast(len<span class="pl-k">+</span><span class="pl-c1">1</span>);
                            dict<span class="pl-k">.</span>remove(s);
                        }
                    }
                }
            }
            <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        }
</pre></div>

<ul>
<li><a href="https://github.com/wishyouhappy/Algorithm#126-word-ladder">126 Word Ladder</a></li>
<li><a href="https://github.com/wishyouhappy/Algorithm#127-word-ladder-ii">127 word Ladder II</a></li>
</ul>

<p><br>
<br></p>

<h3><a id="user-content-127-word-ladder-ii" class="anchor" href="https://github.com/wishyouhappy/Algorithm#127-word-ladder-ii" aria-hidden="true"><span class="octicon octicon-link"></span></a>127 Word Ladder II</h3>

<blockquote>
<p>Given two words (start and end), and a dictionary, find all shortest transformation sequence(s) from start to end, such that:</p>
</blockquote>

<pre>Only one letter can be changed at a time
Each intermediate word must exist in the dictionary
For example,

Given:
start = "hit"
end = "cog"
dict = ["hot","dot","dog","lot","log"]
Return
  [
    ["hit","hot","dot","dog","cog"],
    ["hit","hot","lot","log","cog"]
  ]
Note:
All words have the same length.
All words contain only lowercase alphabetic characters.
</pre>

<p><br>
</p>

<p><strong>Idea</strong>: Becuase we need to output all the shortest paths, thus we need to record the parent node in the path. Then build paths based on these parent nodes.</p>

<p><strong>Attention</strong>:</p>

<ul>
<li>1) we need to remove end from dict if dict contains end, otherwise, we might have duplicates.</li>
<li>2) When we find all the path to end, we can break and rebuild the paths.</li>
<li>3) We can not remove element immediately when we find an neighbors in dict, because one node might have two or more parents. Thus we need to remove it after we have build the relationships between the node and all its parents. <em>We can remove it at the beginning of the next while loop</em></li>
<li>4) when add element to queue, check if queue has alreay contains this element.</li>
</ul>

<p></p>

<p><br></p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span>&gt;</span> findLadders(<span class="pl-smi">String</span> start, <span class="pl-smi">String</span> end, <span class="pl-k">Set&lt;<span class="pl-smi">String</span>&gt;</span> dict) {
        <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span>&gt;</span>();
        <span class="pl-k">if</span>(dict <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> dict<span class="pl-k">.</span>size() <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> start <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> end <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">return</span> res;
        <span class="pl-c">/*if start equals end, we can return [[start, end]]*/</span>
        <span class="pl-k">if</span>(start<span class="pl-k">.</span>equals(end)){
            <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> temp <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">String</span>&gt;</span>();
            temp<span class="pl-k">.</span>add(start);
            temp<span class="pl-k">.</span>add(end);
            <span class="pl-k">return</span> res;
        }

        <span class="pl-c">/*if dict contains end, remove end from dict, otherwise we might have duplicates */</span>
        dict<span class="pl-k">.</span>remove(end); 

        <span class="pl-k">Queue&lt;<span class="pl-smi">String</span>&gt;</span> queue <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">LinkedList&lt;<span class="pl-smi">String</span>&gt;</span> ();

        <span class="pl-c">/*store the parent node of each node*/</span>
        <span class="pl-k">Map&lt;<span class="pl-smi">String</span>, <span class="pl-k">ArrayList&lt;<span class="pl-smi">String</span>&gt;</span>&gt;</span> map <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashMap&lt;<span class="pl-smi">String</span>, <span class="pl-k">ArrayList&lt;<span class="pl-smi">String</span>&gt;</span>&gt;</span>();
        queue<span class="pl-k">.</span>offer(start);
        <span class="pl-k">for</span>(<span class="pl-smi">String</span> s <span class="pl-k">:</span> dict){
            map<span class="pl-k">.</span>put(s, <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">String</span>&gt;</span>());
        }
        map<span class="pl-k">.</span>put(end, <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">String</span>&gt;</span>());
        <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> cur <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">String</span>&gt;</span>();

        <span class="pl-k">while</span>(<span class="pl-k">!</span>queue<span class="pl-k">.</span>isEmpty()){
            cur<span class="pl-k">.</span>clear();
            <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>, size <span class="pl-k">=</span> queue<span class="pl-k">.</span>size(); i <span class="pl-k">&lt;</span> size; i<span class="pl-k">++</span>){
                <span class="pl-smi">String</span> temp <span class="pl-k">=</span> queue<span class="pl-k">.</span>poll();
                cur<span class="pl-k">.</span>add(temp);
                dict<span class="pl-k">.</span>remove(temp);
            }
            <span class="pl-k">for</span>(<span class="pl-smi">String</span> s <span class="pl-k">:</span> cur){
                <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> s<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>){
                    <span class="pl-k">char</span>[] arr <span class="pl-k">=</span> s<span class="pl-k">.</span>toCharArray();
                    <span class="pl-k">for</span>(arr[i] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>; arr[i] <span class="pl-k">&lt;=</span> <span class="pl-s"><span class="pl-pds">'</span>z<span class="pl-pds">'</span></span>; arr[i]<span class="pl-k">++</span>){
                        <span class="pl-smi">String</span> temp <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">String</span>(arr);
                        <span class="pl-c">/* It's ok not add this sentence. just to jump unnecessary operations*/</span>
                        <span class="pl-k">if</span>(temp<span class="pl-k">.</span>equals(s)) <span class="pl-k">continue</span>;
                        <span class="pl-k">if</span>(temp<span class="pl-k">.</span>equals(end)){
                            map<span class="pl-k">.</span>get(end)<span class="pl-k">.</span>add(s);
                        }
                        <span class="pl-k">if</span>(dict<span class="pl-k">.</span>contains(temp)){
                            <span class="pl-k">if</span>(<span class="pl-k">!</span>map<span class="pl-k">.</span>containsKey(temp)){
                                map<span class="pl-k">.</span>put(temp, <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">String</span>&gt;</span>());
                            }
                            map<span class="pl-k">.</span>get(temp)<span class="pl-k">.</span>add(s);
                            <span class="pl-k">if</span>(<span class="pl-k">!</span>queue<span class="pl-k">.</span>contains(temp)) queue<span class="pl-k">.</span>offer(temp);
                        }
                    }
                }
            }

            <span class="pl-k">if</span>(map<span class="pl-k">.</span>get(end)<span class="pl-k">.</span>size()<span class="pl-k">&gt;</span><span class="pl-c1">0</span>) <span class="pl-k">break</span>;
        }

        <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> path <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">String</span>&gt;</span>();
        path<span class="pl-k">.</span>add(end);
        buildPaths(map, res, end, start, path);
        <span class="pl-k">return</span> res;
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> buildPaths(<span class="pl-k">Map&lt;<span class="pl-smi">String</span>, <span class="pl-k">ArrayList&lt;<span class="pl-smi">String</span>&gt;</span>&gt;</span> map, <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span>&gt;</span> res, <span class="pl-smi">String</span> end, <span class="pl-smi">String</span> start, <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> path){
        <span class="pl-k">if</span>(end<span class="pl-k">.</span>equals(start)){
            <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> apath <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">String</span>&gt;</span>(path);
            <span class="pl-smi">Collections</span><span class="pl-k">.</span>reverse(apath);
            res<span class="pl-k">.</span>add(apath);
            <span class="pl-k">return</span>;
        }
        <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> pre <span class="pl-k">=</span> map<span class="pl-k">.</span>get(end);
        <span class="pl-k">for</span>(<span class="pl-smi">String</span> s <span class="pl-k">:</span> pre){
            path<span class="pl-k">.</span>add(s);
            buildPaths(map, res, s, start, path);
            path<span class="pl-k">.</span>remove(path<span class="pl-k">.</span>size()<span class="pl-k">-</span><span class="pl-c1">1</span>);
        }
    }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-131-parlindrome-partitioning" class="anchor" href="https://github.com/wishyouhappy/Algorithm#131-parlindrome-partitioning" aria-hidden="true"><span class="octicon octicon-link"></span></a>131 Parlindrome partitioning</h3>

<blockquote>
<p>Given a string s, partition s such that every substring of the partition is a palindrome.</p>

<p>Return all possible palindrome partitioning of s.</p>
</blockquote>

<pre>For example, given s = "aab",
Return

  [
    ["aa","b"],
    ["a","a","b"]
  ]

</pre>

<p><strong>Idea</strong>:</p>

<ul>
<li><p>Solution 1: Use recursion, each time, add one character, if is palindrome, go to the next recursive level.</p></li>
<li><p>Solution 2: Use dp to pre calculate isPalindrome for each substring i to j, then use the same recursive rule in method 1.</p></li>
</ul>

<p><strong>Time complexity</strong>:</p>

<ul>
<li><p>Solution 1:  worst case. T(n) = (n - 1)T(n - 1) + n * (n - 1), thus time is O(n!)</p></li>
<li><p>Solution 2: T(n) = (n - 1)T(n - 1), time complexity is O(n!) </p></li>
</ul>

<p><strong>Solution 1</strong>: recursion.</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span>&gt;</span> partition(<span class="pl-smi">String</span> s) {
        <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span>&gt;</span>();
        <span class="pl-k">if</span> (s <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> s<span class="pl-k">.</span>length() <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> res;
        }
        partition(s, <span class="pl-c1">0</span>, <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">String</span>&gt;</span>(), res);
        <span class="pl-k">return</span> res;
    }

    <span class="pl-k">private</span> <span class="pl-k">void</span> partition(<span class="pl-smi">String</span> s, <span class="pl-k">int</span> start, <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> cur, <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span>&gt;</span> res) {
        <span class="pl-k">if</span> (start <span class="pl-k">==</span> s<span class="pl-k">.</span>length()) {
            res<span class="pl-k">.</span>add(<span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">String</span>&gt;</span>(cur));
            <span class="pl-k">return</span>;
        }
        <span class="pl-smi">StringBuilder</span> sb <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">StringBuilder</span>();
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> start; i <span class="pl-k">&lt;</span> s<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>) {
            sb<span class="pl-k">.</span>append(s<span class="pl-k">.</span>charAt(i));
            <span class="pl-k">if</span> (isPalindrome(sb<span class="pl-k">.</span>toString())) {
                cur<span class="pl-k">.</span>add(sb<span class="pl-k">.</span>toString());
                partition(s, i <span class="pl-k">+</span> <span class="pl-c1">1</span>, cur, res);
                cur<span class="pl-k">.</span>remove(cur<span class="pl-k">.</span>size() <span class="pl-k">-</span> <span class="pl-c1">1</span>);
            }
        }
    }

    <span class="pl-k">private</span> <span class="pl-k">boolean</span> isPalindrome(<span class="pl-smi">String</span> s) {
        <span class="pl-k">if</span> (s<span class="pl-k">.</span>length() <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> s<span class="pl-k">.</span>length() <span class="pl-k">==</span> <span class="pl-c1">1</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">true</span>;
        }
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>, halfLen <span class="pl-k">=</span> s<span class="pl-k">.</span>length() <span class="pl-k">/</span> <span class="pl-c1">2</span>; i <span class="pl-k">&lt;</span> halfLen; i<span class="pl-k">++</span>) {
            <span class="pl-k">if</span> (s<span class="pl-k">.</span>charAt(i) <span class="pl-k">!=</span> s<span class="pl-k">.</span>charAt(s<span class="pl-k">.</span>length() <span class="pl-k">-</span> i <span class="pl-k">-</span> <span class="pl-c1">1</span>)) {
                <span class="pl-k">return</span> <span class="pl-c1">false</span>;
            }
        }
        <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }</pre></div>

<p><strong>Solution 2</strong>: dp:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span>&gt;</span> partition(<span class="pl-smi">String</span> s) {
        <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span>&gt;</span>();
        <span class="pl-k">if</span> (s <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> s<span class="pl-k">.</span>length() <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> res;
        }
        partition(s, <span class="pl-c1">0</span>, <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">String</span>&gt;</span>(), res, getParlindromeArray(s));
        <span class="pl-k">return</span> res;
    }

    <span class="pl-k">private</span> <span class="pl-k">void</span> partition(<span class="pl-smi">String</span> s, <span class="pl-k">int</span> start, <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> cur, <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span>&gt;</span> res, <span class="pl-k">boolean</span>[][] isP) {
        <span class="pl-k">if</span> (start <span class="pl-k">==</span> s<span class="pl-k">.</span>length()) {
            res<span class="pl-k">.</span>add(<span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">String</span>&gt;</span>(cur));
            <span class="pl-k">return</span>;
        }
        <span class="pl-smi">StringBuilder</span> sb <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">StringBuilder</span>();
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> start; i <span class="pl-k">&lt;</span> s<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>) {
            sb<span class="pl-k">.</span>append(s<span class="pl-k">.</span>charAt(i));
            <span class="pl-k">if</span> (isP[start][i]) {
                cur<span class="pl-k">.</span>add(sb<span class="pl-k">.</span>toString());
                partition(s, i <span class="pl-k">+</span> <span class="pl-c1">1</span>, cur, res, isP);
                cur<span class="pl-k">.</span>remove(cur<span class="pl-k">.</span>size() <span class="pl-k">-</span> <span class="pl-c1">1</span>);
            }
        }
    }

    <span class="pl-k">private</span> <span class="pl-k">boolean</span>[][] getParlindromeArray(<span class="pl-smi">String</span> s) {
        <span class="pl-k">boolean</span>[][] res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">boolean</span>[s<span class="pl-k">.</span>length()][s<span class="pl-k">.</span>length()];
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> s<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>) {
            <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;=</span> i; j<span class="pl-k">++</span>) {
                <span class="pl-k">if</span> (s<span class="pl-k">.</span>charAt(i) <span class="pl-k">==</span> s<span class="pl-k">.</span>charAt(j) <span class="pl-k">&amp;&amp;</span> (i <span class="pl-k">-</span> j <span class="pl-k">&lt;=</span> <span class="pl-c1">2</span> <span class="pl-k">||</span> res[j <span class="pl-k">+</span> <span class="pl-c1">1</span>][i <span class="pl-k">-</span> <span class="pl-c1">1</span>])) {
                    res[j][i] <span class="pl-k">=</span> <span class="pl-c1">true</span>;
                }
            }
        }
        <span class="pl-k">return</span> res;
    }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-132-parlindrome-partitioning-ii" class="anchor" href="https://github.com/wishyouhappy/Algorithm#132-parlindrome-partitioning-ii" aria-hidden="true"><span class="octicon octicon-link"></span></a>132 Parlindrome partitioning II</h3>

<blockquote>
<p>Given a string s, partition s such that every substring of the partition is a palindrome.</p>

<p>Return the minimum cuts needed for a palindrome partitioning of s.</p>

<p>For example, given s = "aab",
Return 1 since the palindrome partitioning ["aa","b"] could be produced using 1 cut.</p>
</blockquote>

<p><strong>Idea</strong>: From Parlindrome partitioning we know how to calcaulate all the possible solutions. If we just need to know the minimum cut numbers, we can use dp to solve the problem.</p>

<ul>
<li><em>Solution 1</em>, calculate the isPalindrome[i][j] use dp, which represents if substring(i, j) is parlindrome. Then use dp to calculate the minimum cut.</li>
</ul>

<p>cut[i] represents the number of cuts to cut the substring(0, i+1) to parlindrome. </p>

<p>Base case: cut[i] = i, every single character must be parlindrome.</p>

<p>Induction rule: cut[i] = min(cut[i], cut[j - 1] + 1), if substring(j, i + 1) is parlindrome. </p>

<p>Note is j = 0, and isParlindrome[j][i] = true, then cut[i] = 0</p>

<ul>
<li><em>Solution 2</em>: combine the cut[] isParlindrome[][] together, then we only need n ^ 2, other then 2 * (n ^ 2) </li>
</ul>

<p><strong>Solution 1</strong>:</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">int</span> minCut(<span class="pl-smi">String</span> s) {
    <span class="pl-k">if</span> (s <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> s<span class="pl-k">.</span>length() <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
        <span class="pl-k">return</span> <span class="pl-c1">0</span>;
    }
    <span class="pl-k">boolean</span>[][] isP <span class="pl-k">=</span> getParlindromeArray(s);
    <span class="pl-k">int</span>[] cut <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[s<span class="pl-k">.</span>length()];
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> s<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>) {
        cut[i] <span class="pl-k">=</span> i;
        <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;=</span> i; j<span class="pl-k">++</span>) {
            <span class="pl-k">if</span> (isP[j][i]) {
                <span class="pl-k">if</span> (j <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>) {
                    cut[i] <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>min(cut[i], cut[j <span class="pl-k">-</span> <span class="pl-c1">1</span>] <span class="pl-k">+</span> <span class="pl-c1">1</span>);
                } <span class="pl-k">else</span> {
                    cut[i] <span class="pl-k">=</span> <span class="pl-c1">0</span>;
                }
            }
        }
    }
    <span class="pl-k">return</span> cut[s<span class="pl-k">.</span>length() <span class="pl-k">-</span> <span class="pl-c1">1</span>];
}
<span class="pl-k">private</span> <span class="pl-k">boolean</span>[][] getParlindromeArray(<span class="pl-smi">String</span> s) {
    <span class="pl-k">boolean</span>[][] res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">boolean</span>[s<span class="pl-k">.</span>length()][s<span class="pl-k">.</span>length()];
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> s<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>) {
        <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;=</span> i; j<span class="pl-k">++</span>) {
            <span class="pl-k">if</span> (s<span class="pl-k">.</span>charAt(i) <span class="pl-k">==</span> s<span class="pl-k">.</span>charAt(j) <span class="pl-k">&amp;&amp;</span> (i <span class="pl-k">-</span> j <span class="pl-k">&lt;=</span> <span class="pl-c1">2</span> <span class="pl-k">||</span> res[j <span class="pl-k">+</span> <span class="pl-c1">1</span>][i <span class="pl-k">-</span> <span class="pl-c1">1</span>])) {
                res[j][i] <span class="pl-k">=</span> <span class="pl-c1">true</span>;
            }
        }
    }
    <span class="pl-k">return</span> res;
}
</pre></div>

<p><br>
<strong>Solution 2</strong>:</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">int</span> minCut(<span class="pl-smi">String</span> s) {
    <span class="pl-k">if</span> (s <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> s<span class="pl-k">.</span>length() <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
        <span class="pl-k">return</span> <span class="pl-c1">0</span>;
    }
    <span class="pl-k">boolean</span>[][] isP <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">boolean</span>[s<span class="pl-k">.</span>length()][s<span class="pl-k">.</span>length()];
    <span class="pl-k">int</span>[] cut <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[s<span class="pl-k">.</span>length()];
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> s<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>) {
        cut[i] <span class="pl-k">=</span> i;
        <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;=</span> i; j<span class="pl-k">++</span>) {
            <span class="pl-k">if</span> (s<span class="pl-k">.</span>charAt(i) <span class="pl-k">==</span> s<span class="pl-k">.</span>charAt(j) <span class="pl-k">&amp;&amp;</span> (i <span class="pl-k">-</span> j <span class="pl-k">&lt;=</span> <span class="pl-c1">2</span> <span class="pl-k">||</span> isP[j <span class="pl-k">+</span> <span class="pl-c1">1</span>][i <span class="pl-k">-</span> <span class="pl-c1">1</span>])) {
                isP[j][i] <span class="pl-k">=</span> <span class="pl-c1">true</span>;
                <span class="pl-k">if</span> (j <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>) {
                    cut[i] <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>min(cut[i], cut[j <span class="pl-k">-</span> <span class="pl-c1">1</span>] <span class="pl-k">+</span> <span class="pl-c1">1</span>);
                } <span class="pl-k">else</span> {
                    cut[i] <span class="pl-k">=</span> <span class="pl-c1">0</span>;
                }
            }
        }
    }
    <span class="pl-k">return</span> cut[s<span class="pl-k">.</span>length() <span class="pl-k">-</span> <span class="pl-c1">1</span>];
}
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-133-clone-graph" class="anchor" href="https://github.com/wishyouhappy/Algorithm#133-clone-graph" aria-hidden="true"><span class="octicon octicon-link"></span></a>133 Clone Graph</h3>

<blockquote>
<p>Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.</p>

<p>OJ's undirected graph serialization:
Nodes are labeled uniquely.</p>

<p>We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.
As an example, consider the serialized graph {0,1,2#1,2#2,2}.</p>

<p>The graph has a total of three nodes, and therefore contains three parts as separated by #.</p>

<p>First node is labeled as 0. Connect node 0 to both nodes 1 and 2.
Second node is labeled as 1. Connect node 1 to node 2.
Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.
Visually, the graph looks like the following:</p>
</blockquote>

<pre>       1
      / \
     /   \
    0 --- 2
         / \
         \_/

</pre>

<p><strong>Idea</strong>: We need a map to record if the node has already been copyed, if it is, then we just need to record the neighbors relationship for it.</p>

<p><strong>Solution 1</strong>: DFS</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-smi">UndirectedGraphNode</span> cloneGraph(<span class="pl-smi">UndirectedGraphNode</span> node) {
        <span class="pl-k">if</span> (node <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
            <span class="pl-k">return</span> node;
        }
        <span class="pl-smi">UndirectedGraphNode</span> copy <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">UndirectedGraphNode</span>(node<span class="pl-k">.</span>label);
        <span class="pl-k">Map&lt;<span class="pl-smi">UndirectedGraphNode</span>, <span class="pl-smi">UndirectedGraphNode</span>&gt;</span> map <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashMap&lt;<span class="pl-smi">UndirectedGraphNode</span>, <span class="pl-smi">UndirectedGraphNode</span>&gt;</span>();
        map<span class="pl-k">.</span>put(node, copy);
        cloneGraph(node, copy, map);
        <span class="pl-k">return</span> copy;
    }
    <span class="pl-k">private</span> <span class="pl-k">void</span> cloneGraph(<span class="pl-smi">UndirectedGraphNode</span> node, <span class="pl-smi">UndirectedGraphNode</span> copy, <span class="pl-k">Map&lt;<span class="pl-smi">UndirectedGraphNode</span>, <span class="pl-smi">UndirectedGraphNode</span>&gt;</span> map) {
        <span class="pl-k">if</span> (node <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
            <span class="pl-k">return</span>;
        }
        <span class="pl-k">for</span> (<span class="pl-smi">UndirectedGraphNode</span> cur <span class="pl-k">:</span> node<span class="pl-k">.</span>neighbors) {
            <span class="pl-k">if</span> (<span class="pl-k">!</span>map<span class="pl-k">.</span>containsKey(cur)) {
                <span class="pl-smi">UndirectedGraphNode</span> curCopy <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">UndirectedGraphNode</span>(cur<span class="pl-k">.</span>label);
                map<span class="pl-k">.</span>put(cur, curCopy);
                copy<span class="pl-k">.</span>neighbors<span class="pl-k">.</span>add(curCopy);
                cloneGraph(cur, curCopy, map);
            } <span class="pl-k">else</span> {
                 copy<span class="pl-k">.</span>neighbors<span class="pl-k">.</span>add(map<span class="pl-k">.</span>get(cur));
            }
        }
    }</pre></div>

<p><strong>Solution 2</strong>: BFS</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-smi">UndirectedGraphNode</span> cloneGraph(<span class="pl-smi">UndirectedGraphNode</span> node) {
    <span class="pl-k">if</span> (node <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
        <span class="pl-k">return</span> node;
    }
     <span class="pl-smi">UndirectedGraphNode</span> copy <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">UndirectedGraphNode</span>(node<span class="pl-k">.</span>label);
     <span class="pl-k">Queue&lt;<span class="pl-smi">UndirectedGraphNode</span>&gt;</span> queue <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">LinkedList&lt;<span class="pl-smi">UndirectedGraphNode</span>&gt;</span>();
     <span class="pl-k">Map&lt;<span class="pl-smi">UndirectedGraphNode</span>,<span class="pl-smi">UndirectedGraphNode</span>&gt;</span> map <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashMap&lt;<span class="pl-smi">UndirectedGraphNode</span>, <span class="pl-smi">UndirectedGraphNode</span>&gt;</span>();
     queue<span class="pl-k">.</span>add(node);
     map<span class="pl-k">.</span>put(node, copy);
     <span class="pl-smi">UndirectedGraphNode</span> temp <span class="pl-k">=</span> <span class="pl-c1">null</span>;
     <span class="pl-smi">UndirectedGraphNode</span> copyTemp <span class="pl-k">=</span> <span class="pl-c1">null</span>;
     <span class="pl-k">while</span> (<span class="pl-k">!</span>queue<span class="pl-k">.</span>isEmpty()) {
          temp <span class="pl-k">=</span> queue<span class="pl-k">.</span>poll();
          <span class="pl-k">for</span> (<span class="pl-smi">UndirectedGraphNode</span> n <span class="pl-k">:</span> temp<span class="pl-k">.</span>neighbors) {
              <span class="pl-k">if</span> (<span class="pl-k">!</span>map<span class="pl-k">.</span>containsKey(n)) {
                  copyTemp <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">UndirectedGraphNode</span>(n<span class="pl-k">.</span>label);
                  map<span class="pl-k">.</span>put(n, copyTemp);
                  map<span class="pl-k">.</span>get(temp)<span class="pl-k">.</span>neighbors<span class="pl-k">.</span>add(copyTemp);
                  queue<span class="pl-k">.</span>add(n);
              } <span class="pl-k">else</span> { 
                  map<span class="pl-k">.</span>get(temp)<span class="pl-k">.</span>neighbors<span class="pl-k">.</span>add(map<span class="pl-k">.</span>get(n));
              }
          }
    }
    <span class="pl-k">return</span> copy;
}
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-135-candy" class="anchor" href="https://github.com/wishyouhappy/Algorithm#135-candy" aria-hidden="true"><span class="octicon octicon-link"></span></a>135 Candy</h3>

<blockquote>
<p>There are N children standing in a line. Each child is assigned a rating value.</p>

<p>You are giving candies to these children subjected to the following requirements:</p>

<p>Each child must have at least one candy.</p>

<p>Children with a higher rating get more candies than their neighbors.</p>

<p>What is the minimum candies you must give?</p>
</blockquote>

<p><strong>Idea</strong>: </p>

<ul>
<li>1) Solution1 : Traverse the array two times, left to right and right to left. In the first traverse, we calculate the min candy for each child based on its left neighbor. In the right to left traverse, we calculate the min candy for each child based on its right neighbor. It's easier to use 2 array and traverse three times. We can reduce it to 1 array and 2 pass. </li>
</ul>

<p><strong>Three pass, two array</strong></p>

<div class="highlight highlight-java"><pre> <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">int</span> candy(<span class="pl-k">int</span>[] ratings) {
        <span class="pl-k">if</span>(ratings <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> ratings<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span>[] left <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[ratings<span class="pl-k">.</span>length];
        left[<span class="pl-c1">0</span>] <span class="pl-k">=</span> <span class="pl-c1">1</span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;</span> ratings<span class="pl-k">.</span>length; i<span class="pl-k">++</span>){
            <span class="pl-k">if</span>(ratings[i] <span class="pl-k">&gt;</span> ratings[i<span class="pl-k">-</span><span class="pl-c1">1</span>]) left[i] <span class="pl-k">=</span> left[i<span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">+</span><span class="pl-c1">1</span>;
            <span class="pl-k">else</span> left[i] <span class="pl-k">=</span> <span class="pl-c1">1</span>;
        }
        <span class="pl-k">int</span>[] right <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[ratings<span class="pl-k">.</span>length];
        right[ratings<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>] <span class="pl-k">=</span> <span class="pl-c1">1</span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> ratings<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">2</span>; i <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>; i<span class="pl-k">--</span>){
             <span class="pl-k">if</span>(ratings[i] <span class="pl-k">&gt;</span> ratings[i<span class="pl-k">+</span><span class="pl-c1">1</span>]){
                right[i] <span class="pl-k">=</span> right[i<span class="pl-k">+</span><span class="pl-c1">1</span>] <span class="pl-k">+</span> <span class="pl-c1">1</span>;
            }<span class="pl-k">else</span> right[i] <span class="pl-k">=</span> <span class="pl-c1">1</span>;
        }
        <span class="pl-k">int</span> res <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> ratings<span class="pl-k">.</span>length; i<span class="pl-k">++</span>){
            res <span class="pl-k">+=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(left[i], right[i]);
        }
        <span class="pl-k">return</span> res;
    }
</pre></div>

<p><br></p>

<p><strong>Two pass, one array</strong></p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">int</span> candy(<span class="pl-k">int</span>[] ratings) {
        <span class="pl-k">if</span>(ratings <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> ratings<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span>[] left <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[ratings<span class="pl-k">.</span>length];
        left[<span class="pl-c1">0</span>] <span class="pl-k">=</span> <span class="pl-c1">1</span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;</span> ratings<span class="pl-k">.</span>length; i<span class="pl-k">++</span>){
            <span class="pl-k">if</span>(ratings[i] <span class="pl-k">&gt;</span> ratings[i<span class="pl-k">-</span><span class="pl-c1">1</span>]) left[i] <span class="pl-k">=</span> left[i<span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">+</span><span class="pl-c1">1</span>;
            <span class="pl-k">else</span> left[i] <span class="pl-k">=</span> <span class="pl-c1">1</span>;
        }
        <span class="pl-k">int</span> res <span class="pl-k">=</span> left[ratings<span class="pl-k">.</span>length<span class="pl-k">-</span><span class="pl-c1">1</span>];
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> ratings<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">2</span>; i <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>; i<span class="pl-k">--</span>){
            <span class="pl-k">int</span> right <span class="pl-k">=</span> <span class="pl-c1">1</span>;
            <span class="pl-k">if</span>(ratings[i] <span class="pl-k">&gt;</span> ratings[i<span class="pl-k">+</span><span class="pl-c1">1</span>]){
                right <span class="pl-k">=</span> left[i<span class="pl-k">+</span><span class="pl-c1">1</span>] <span class="pl-k">+</span> <span class="pl-c1">1</span>;
            }
            res <span class="pl-k">+=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(right, left[i]);
            left[i] <span class="pl-k">=</span> right;
        }
        <span class="pl-k">return</span> res;
    }
</pre></div>

<p><br></p>

<ul>
<li>2) solution 2: Brute force. O(n ^2 )</li>
</ul>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">int</span> candy(<span class="pl-k">int</span>[] ratings) {
        <span class="pl-k">if</span>(ratings <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> ratings<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;

        <span class="pl-k">int</span> preRating <span class="pl-k">=</span> ratings[<span class="pl-c1">0</span>],
            count <span class="pl-k">=</span> <span class="pl-c1">1</span>,
            preCandy <span class="pl-k">=</span> <span class="pl-c1">1</span>,
            lastIncreasingIndex <span class="pl-k">=</span> <span class="pl-c1">0</span>,
            lastDecreasingIndex <span class="pl-k">=</span> <span class="pl-c1">0</span>,
            lastIncreasingCandy <span class="pl-k">=</span> <span class="pl-c1">1</span>,
            changeFlag <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>, len <span class="pl-k">=</span> ratings<span class="pl-k">.</span>length; i <span class="pl-k">&lt;</span> len; i<span class="pl-k">++</span>){
            <span class="pl-k">if</span>(ratings[i] <span class="pl-k">&gt;=</span> preRating){
                <span class="pl-k">if</span>(changeFlag <span class="pl-k">==</span> <span class="pl-c1">1</span>){                
                    <span class="pl-k">if</span>(ratings[i] <span class="pl-k">==</span> preRating){
                        <span class="pl-c">/*if increasing sequence is longer than deceasing sequence */</span>
                        <span class="pl-k">if</span>(lastIncreasingCandy <span class="pl-k">&gt;</span> lastDecreasingIndex <span class="pl-k">-</span> lastIncreasingIndex <span class="pl-k">+</span><span class="pl-c1">1</span>){
                            count <span class="pl-k">+=</span> sumTools(lastDecreasingIndex <span class="pl-k">-</span> lastIncreasingIndex);
                        }<span class="pl-k">else</span>{
                            count <span class="pl-k">-=</span> lastIncreasingCandy;
                            count <span class="pl-k">+=</span> sumTools(lastDecreasingIndex <span class="pl-k">-</span> lastIncreasingIndex<span class="pl-k">+</span><span class="pl-c1">1</span>);
                        }
                        count <span class="pl-k">+=</span> <span class="pl-c1">1</span>;
                        preCandy <span class="pl-k">=</span> <span class="pl-c1">1</span>;
                    }<span class="pl-k">else</span>{
                        <span class="pl-c">/*if increasing sequence is longer than deceasing sequence */</span>
                        <span class="pl-k">if</span>(lastIncreasingCandy <span class="pl-k">&gt;</span> lastDecreasingIndex <span class="pl-k">-</span> lastIncreasingIndex <span class="pl-k">+</span><span class="pl-c1">1</span>){
                            count <span class="pl-k">+=</span> sumTools(lastDecreasingIndex <span class="pl-k">-</span> lastIncreasingIndex);
                        }<span class="pl-k">else</span>{
                            count <span class="pl-k">-=</span> lastIncreasingCandy;
                            count <span class="pl-k">+=</span> sumTools(lastDecreasingIndex <span class="pl-k">-</span> lastIncreasingIndex <span class="pl-k">+</span><span class="pl-c1">1</span>);
                        }
                        count <span class="pl-k">+=</span> <span class="pl-c1">2</span>;
                        preCandy <span class="pl-k">=</span> <span class="pl-c1">2</span>;
                    }
                    changeFlag <span class="pl-k">=</span> <span class="pl-c1">0</span>;
                    lastIncreasingIndex <span class="pl-k">=</span> i;
                    lastIncreasingCandy <span class="pl-k">=</span> preCandy;
                    preRating <span class="pl-k">=</span> ratings[i];
                    <span class="pl-k">continue</span>;
                }<span class="pl-k">else</span>{
                    <span class="pl-k">if</span>(ratings[i] <span class="pl-k">==</span> preRating){
                        preCandy <span class="pl-k">=</span> <span class="pl-c1">1</span>;
                    }<span class="pl-k">else</span>{
                        preCandy<span class="pl-k">++</span>;
                    }
                    count <span class="pl-k">+=</span> preCandy;
                    preRating <span class="pl-k">=</span> ratings[i];
                    lastIncreasingIndex <span class="pl-k">=</span> i;
                    lastIncreasingCandy <span class="pl-k">=</span> preCandy;
                }

            }<span class="pl-k">else</span>{
                lastDecreasingIndex <span class="pl-k">=</span> i;
                preRating <span class="pl-k">=</span> ratings[i];
                changeFlag <span class="pl-k">=</span> <span class="pl-c1">1</span>;
                <span class="pl-k">continue</span>;
            }
        }

        <span class="pl-k">if</span>(changeFlag <span class="pl-k">==</span> <span class="pl-c1">1</span>){
            <span class="pl-k">if</span>(lastIncreasingCandy <span class="pl-k">&gt;</span> lastDecreasingIndex <span class="pl-k">-</span> lastIncreasingIndex <span class="pl-k">+</span><span class="pl-c1">1</span>){
                count <span class="pl-k">+=</span> sumTools(lastDecreasingIndex <span class="pl-k">-</span> lastIncreasingIndex);
            }<span class="pl-k">else</span>{
                count <span class="pl-k">-=</span> lastIncreasingCandy;
                count <span class="pl-k">+=</span> sumTools(lastDecreasingIndex <span class="pl-k">-</span> lastIncreasingIndex <span class="pl-k">+</span><span class="pl-c1">1</span>);
            } 
        }
        <span class="pl-k">return</span> count;
    }

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">int</span> sumTools(<span class="pl-k">int</span> n){
        <span class="pl-k">int</span> sum <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;=</span> n; i<span class="pl-k">++</span> ){
            sum <span class="pl-k">+=</span> i;
        }
        <span class="pl-k">return</span> sum;
    }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-138-copy-list-with-random-pointer" class="anchor" href="https://github.com/wishyouhappy/Algorithm#138-copy-list-with-random-pointer" aria-hidden="true"><span class="octicon octicon-link"></span></a>138 Copy List With Random Pointer</h3>

<blockquote>
<p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list.</p>
</blockquote>

<p><strong>Idea</strong> :</p>

<p><strong>Solution1:</strong>Copy each node in the list, then divide the list into two lists. For example: 1-&gt;2-&gt;3, we copy nodes and the list turns to 1-&gt;1-&gt;2-&gt;2-&gt;3-&gt;3. Then we divide it into two 1-&gt;2-&gt;3</p>

<p><strong>Attention</strong>: <strong><em>we should copy the random pointer seperatel after we copy all the nodes</em></strong>. At the beginning, I thought that I can copy the random pointer at the same time and just let it pointer to the same node with the original node, when breaking the list, I change the copy node's random to origin's random's next. It works only when the node that random pointer points to is after to the current pointer. What if it is before the current node? we might not able to find the random's next because when breaking the list we have changed the structure of the list. </p>

<p><strong>Solution2</strong>: Use hashmap store old and copy, then copy the random pointer</p>

<p><strong><em>Solution1 code</em></strong></p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-smi">RandomListNode</span> copyRandomList(<span class="pl-smi">RandomListNode</span> head) {
        <span class="pl-k">if</span>(head <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">return</span> <span class="pl-c1">null</span>;
        <span class="pl-smi">RandomListNode</span> temp <span class="pl-k">=</span> head;
        <span class="pl-k">while</span>(temp <span class="pl-k">!=</span> <span class="pl-c1">null</span>){
            <span class="pl-smi">RandomListNode</span> next <span class="pl-k">=</span> temp<span class="pl-k">.</span>next;
            temp<span class="pl-k">.</span>next <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">RandomListNode</span>(temp<span class="pl-k">.</span>label);
            temp<span class="pl-k">.</span>next<span class="pl-k">.</span>next <span class="pl-k">=</span> next;
            temp <span class="pl-k">=</span> next;
        }
        temp <span class="pl-k">=</span> head;
        <span class="pl-k">while</span>(temp <span class="pl-k">!=</span> <span class="pl-c1">null</span>){
            <span class="pl-k">if</span>(temp<span class="pl-k">.</span>random <span class="pl-k">!=</span> <span class="pl-c1">null</span>){
                temp<span class="pl-k">.</span>next<span class="pl-k">.</span>random <span class="pl-k">=</span> temp<span class="pl-k">.</span>random<span class="pl-k">.</span>next;
            }
            temp <span class="pl-k">=</span> temp<span class="pl-k">.</span>next<span class="pl-k">.</span>next;
        }
        <span class="pl-smi">RandomListNode</span> fakeHead <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">RandomListNode</span>(<span class="pl-k">-</span><span class="pl-c1">1</span>);
        <span class="pl-smi">RandomListNode</span> copy <span class="pl-k">=</span> fakeHead;
        <span class="pl-k">while</span>(head <span class="pl-k">!=</span> <span class="pl-c1">null</span>){
            <span class="pl-smi">RandomListNode</span> next <span class="pl-k">=</span> head<span class="pl-k">.</span>next<span class="pl-k">.</span>next;
            copy<span class="pl-k">.</span>next <span class="pl-k">=</span> head<span class="pl-k">.</span>next;
            copy <span class="pl-k">=</span> copy<span class="pl-k">.</span>next;
            copy<span class="pl-k">.</span>next <span class="pl-k">=</span> <span class="pl-c1">null</span>;
            head<span class="pl-k">.</span>next <span class="pl-k">=</span> next;
            head <span class="pl-k">=</span> next;
        }
        <span class="pl-k">return</span> fakeHead<span class="pl-k">.</span>next;
    }</pre></div>

<p><strong><em>Solution2 code</em></strong></p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-smi">RandomListNode</span> copyRandomList1(<span class="pl-smi">RandomListNode</span> head) {
        <span class="pl-k">if</span>(head <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">return</span> <span class="pl-c1">null</span>;
        <span class="pl-smi">RandomListNode</span> copy <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">RandomListNode</span>(<span class="pl-k">-</span><span class="pl-c1">1</span>);
        <span class="pl-smi">RandomListNode</span> temp <span class="pl-k">=</span> head;
        <span class="pl-k">HashMap&lt;<span class="pl-smi">RandomListNode</span>, <span class="pl-smi">RandomListNode</span>&gt;</span> map <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashMap&lt;<span class="pl-smi">RandomListNode</span>, <span class="pl-smi">RandomListNode</span>&gt;</span>();
        <span class="pl-k">while</span>(temp <span class="pl-k">!=</span> <span class="pl-c1">null</span>){
            copy<span class="pl-k">.</span>next <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">RandomListNode</span>(temp<span class="pl-k">.</span>label);
            map<span class="pl-k">.</span>put(temp, copy<span class="pl-k">.</span>next);
            copy <span class="pl-k">=</span> copy<span class="pl-k">.</span>next;
            temp <span class="pl-k">=</span> temp<span class="pl-k">.</span>next;
        }
        copy <span class="pl-k">=</span> map<span class="pl-k">.</span>get(head);
        <span class="pl-smi">RandomListNode</span> saveHead <span class="pl-k">=</span> copy;
        <span class="pl-k">while</span>(head <span class="pl-k">!=</span> <span class="pl-c1">null</span>){
            copy<span class="pl-k">.</span>random <span class="pl-k">=</span> map<span class="pl-k">.</span>get(head<span class="pl-k">.</span>random);
            head <span class="pl-k">=</span> head<span class="pl-k">.</span>next;
            copy <span class="pl-k">=</span> copy<span class="pl-k">.</span>next;
        }
        <span class="pl-k">return</span> saveHead;
    }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-141-linked-list-cycle" class="anchor" href="https://github.com/wishyouhappy/Algorithm#141-linked-list-cycle" aria-hidden="true"><span class="octicon octicon-link"></span></a>141 Linked List Cycle</h3>

<blockquote>
<p>Given a linked list, determine if it has a cycle in it.</p>
</blockquote>

<p>Follow up:
Can you solve it without using extra space?</p>

<p><strong>Idea</strong>: Use two pointers, one pointer move one step each time, the other pointer move two step each time. If they encounter, then a cycle exist.</p>

<p><strong>Attention</strong>: when check if they encounter, if check if they are null! Otherwise, if(f.equals(s)) will have null pointer. </p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">boolean</span> hasCycle(<span class="pl-smi">ListNode</span> head) {
        <span class="pl-k">if</span>(head <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        <span class="pl-smi">ListNode</span> f <span class="pl-k">=</span> head;
        <span class="pl-smi">ListNode</span> s <span class="pl-k">=</span> head;
        <span class="pl-k">while</span>(f <span class="pl-k">!=</span> <span class="pl-c1">null</span>){
            f <span class="pl-k">=</span> f<span class="pl-k">.</span>next;
            <span class="pl-k">if</span>(f <span class="pl-k">!=</span> <span class="pl-c1">null</span>) f <span class="pl-k">=</span> f<span class="pl-k">.</span>next;
            s <span class="pl-k">=</span> s<span class="pl-k">.</span>next;
            <span class="pl-k">if</span>(f <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">return</span> <span class="pl-c1">false</span>;
            <span class="pl-k">if</span>(f<span class="pl-k">.</span>equals(s)) <span class="pl-k">return</span> <span class="pl-c1">true</span>;
        }
        <span class="pl-k">return</span> <span class="pl-c1">false</span>;
    }</pre></div>

<p><br>
<br>    </p>

<h3><a id="user-content-142-linked-list-cycle-ii" class="anchor" href="https://github.com/wishyouhappy/Algorithm#142-linked-list-cycle-ii" aria-hidden="true"><span class="octicon octicon-link"></span></a>142 Linked List Cycle II</h3>

<blockquote>
<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>
</blockquote>

<p>Follow up:
Can you solve it without using extra space?</p>

<p><strong>Idea</strong>: </p>

<ul>
<li>1) Use the method in <a href="https://github.com/wishyouhappy/Algorithm#141-linked-list-cycle">141 Linked List Cycle</a> to check if cycle exist. </li>
<li>2) when faster and slower encounters, change the faster to head, and move faster and slower one step each time until they encounter. At this time, the faster and slower point to the node where the cycle begins.</li>
</ul>

<p><strong>Attention</strong>: when check if they encounter, if check if they are null! Otherwise, if(f.equals(s)) will have null pointer. </p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-smi">ListNode</span> detectCycle(<span class="pl-smi">ListNode</span> head) {
        <span class="pl-k">if</span>(head <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">return</span> <span class="pl-c1">null</span>;
        <span class="pl-smi">ListNode</span> f <span class="pl-k">=</span> head;
        <span class="pl-smi">ListNode</span> s <span class="pl-k">=</span> head;
        <span class="pl-k">while</span>(f <span class="pl-k">!=</span> <span class="pl-c1">null</span>){
            f <span class="pl-k">=</span> f<span class="pl-k">.</span>next;
            <span class="pl-k">if</span>(f <span class="pl-k">!=</span> <span class="pl-c1">null</span>) f <span class="pl-k">=</span> f<span class="pl-k">.</span>next;
            s <span class="pl-k">=</span> s<span class="pl-k">.</span>next;
            <span class="pl-k">if</span>(f <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">return</span> <span class="pl-c1">null</span>;
            <span class="pl-k">if</span>(f<span class="pl-k">.</span>equals(s)) <span class="pl-k">break</span>;
        }
        f <span class="pl-k">=</span> head;
        <span class="pl-k">while</span>(f <span class="pl-k">!=</span> <span class="pl-c1">null</span>){
            <span class="pl-k">if</span>(f<span class="pl-k">.</span>equals(s)) <span class="pl-k">return</span> s;
            f <span class="pl-k">=</span> f<span class="pl-k">.</span>next;
            s <span class="pl-k">=</span> s<span class="pl-k">.</span>next;
        }
        <span class="pl-k">return</span> <span class="pl-c1">null</span>;
    }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-143-reorder-list" class="anchor" href="https://github.com/wishyouhappy/Algorithm#143-reorder-list" aria-hidden="true"><span class="octicon octicon-link"></span></a>143 Reorder List</h3>

<blockquote>
<p>Given a singly linked list L: L0→L1→…→Ln-1→Ln,
reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
</blockquote>

<p>You must do this in-place without altering the nodes' values.</p>

<p>For example,
Given {1,2,3,4}, reorder it to {1,4,2,3}.</p>

<p><strong>Idea</strong>: We can solve this problem in two ways.</p>

<ul>
<li>1) copy a reversed linked list, then insert half of the list into original list.</li>
<li>2) Reverse the last half of the list, then insert it into the first half. </li>
</ul>

<p><strong>Attention</strong>: When reverse, remember to set the first node's next to null, otherwise their will have a loop. </p>

<p><em>**Solution1 code *</em>*:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">void</span> reorderList(<span class="pl-smi">ListNode</span> head) {
        <span class="pl-k">if</span> (head <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
            <span class="pl-k">return</span>;
        }
        <span class="pl-smi">ListNode</span> copy <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">ListNode</span>(<span class="pl-k">-</span><span class="pl-c1">1</span>);
        <span class="pl-k">int</span> count <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-smi">ListNode</span> temp <span class="pl-k">=</span> head;
        <span class="pl-k">while</span> (temp <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
            <span class="pl-smi">ListNode</span> current <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">ListNode</span>(temp<span class="pl-k">.</span>val);
            current<span class="pl-k">.</span>next <span class="pl-k">=</span> copy;
            copy <span class="pl-k">=</span> current;
            temp <span class="pl-k">=</span> temp<span class="pl-k">.</span>next;
            count<span class="pl-k">++</span>;
        }
        <span class="pl-k">if</span>(count <span class="pl-k">&lt;=</span> <span class="pl-c1">2</span>) {
            <span class="pl-k">return</span>;
        }
        temp <span class="pl-k">=</span> head;
        <span class="pl-smi">ListNode</span> next <span class="pl-k">=</span> <span class="pl-c1">null</span>;
        <span class="pl-smi">ListNode</span> copyNext <span class="pl-k">=</span> <span class="pl-c1">null</span>;
        <span class="pl-smi">ListNode</span> pre <span class="pl-k">=</span> <span class="pl-c1">null</span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> count<span class="pl-k">/</span><span class="pl-c1">2</span>; i<span class="pl-k">++</span>){
            next <span class="pl-k">=</span> temp<span class="pl-k">.</span>next;
            copyNext <span class="pl-k">=</span> copy<span class="pl-k">.</span>next;
            temp<span class="pl-k">.</span>next <span class="pl-k">=</span> copy;
            copy<span class="pl-k">.</span>next <span class="pl-k">=</span> next;
            pre <span class="pl-k">=</span> copy;
            temp <span class="pl-k">=</span> next;
            copy <span class="pl-k">=</span> copyNext;
        }
        <span class="pl-k">if</span> (count <span class="pl-k">%</span> <span class="pl-c1">2</span> <span class="pl-k">!=</span> <span class="pl-c1">0</span>) {
            temp<span class="pl-k">.</span>next <span class="pl-k">=</span> <span class="pl-c1">null</span>;
        } <span class="pl-k">else</span> {
            pre<span class="pl-k">.</span>next <span class="pl-k">=</span> <span class="pl-c1">null</span>;
        }
    }
</pre></div>

<p><em>**Solution2 code *</em>*:</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">void</span> reorderList(<span class="pl-smi">ListNode</span> head) {
    <span class="pl-c">// write your solution here</span>
    <span class="pl-k">if</span> (head <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> head<span class="pl-k">.</span>next <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> head<span class="pl-k">.</span>next<span class="pl-k">.</span>next <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span>;
    }
    <span class="pl-c">//find the mid node</span>
    <span class="pl-smi">ListNode</span> slower <span class="pl-k">=</span> head; <span class="pl-c">//move one step each time</span>
    <span class="pl-smi">ListNode</span> faster <span class="pl-k">=</span> head; <span class="pl-c">// move two steps each time</span>
    <span class="pl-smi">ListNode</span> pre <span class="pl-k">=</span> <span class="pl-c1">null</span>;
    <span class="pl-k">while</span> (faster <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
      pre <span class="pl-k">=</span> slower;
      slower <span class="pl-k">=</span> slower<span class="pl-k">.</span>next;
      faster <span class="pl-k">=</span> faster<span class="pl-k">.</span>next;
      <span class="pl-k">if</span> (faster <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
        faster <span class="pl-k">=</span> faster<span class="pl-k">.</span>next;
      }
    }
    pre<span class="pl-k">.</span>next <span class="pl-k">=</span> <span class="pl-c1">null</span>;

    <span class="pl-c">//reverse last half</span>
    slower <span class="pl-k">=</span> reverseList(slower);
    <span class="pl-smi">ListNode</span> temp <span class="pl-k">=</span> head;
    <span class="pl-k">while</span>(temp <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> slower <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
      <span class="pl-smi">ListNode</span> insert <span class="pl-k">=</span> slower;
      <span class="pl-smi">ListNode</span> next <span class="pl-k">=</span> temp<span class="pl-k">.</span>next;
      slower <span class="pl-k">=</span> slower<span class="pl-k">.</span>next;
      temp<span class="pl-k">.</span>next <span class="pl-k">=</span> insert;
      insert<span class="pl-k">.</span>next <span class="pl-k">=</span> next;
      temp <span class="pl-k">=</span> temp<span class="pl-k">.</span>next<span class="pl-k">.</span>next;
    }
  }

  <span class="pl-k">public</span> <span class="pl-smi">ListNode</span> reverseList(<span class="pl-smi">ListNode</span> head) {
    <span class="pl-k">if</span> (head <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> head<span class="pl-k">.</span>next <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
        <span class="pl-k">return</span> head;
    }
    <span class="pl-smi">ListNode</span> pre <span class="pl-k">=</span> <span class="pl-c1">null</span>;
    <span class="pl-smi">ListNode</span> next <span class="pl-k">=</span> <span class="pl-c1">null</span>;
    <span class="pl-k">while</span> (head <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
        next <span class="pl-k">=</span> head<span class="pl-k">.</span>next;
        head<span class="pl-k">.</span>next <span class="pl-k">=</span> pre;
        pre <span class="pl-k">=</span> head;
        head <span class="pl-k">=</span> next;
    }
    <span class="pl-k">return</span> pre;
  }</pre></div>

<p><br></p>

<p><strong>Related</strong>: Reorder array in place </p>

<blockquote>
<p>eg : { 1, 2, 3, 4, 5, 6, 7, 8 } → { 1, 5, 2, 6, 3, 7, 4, 8 }</p>

<p>{ 1, 2, 3, 4, 5, 6, 7 } → { 1, 4, 2, 5, 3, 6, 7 }</p>
</blockquote>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">int</span>[] reorder(<span class="pl-k">int</span>[] array) {
    <span class="pl-k">if</span> (array <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> array<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
      <span class="pl-k">return</span> array;
    }
    <span class="pl-k">int</span> len <span class="pl-k">=</span> array<span class="pl-k">.</span>length <span class="pl-k">%</span> <span class="pl-c1">2</span> <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">?</span> array<span class="pl-k">.</span>length <span class="pl-k">:</span> array<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>;
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> len <span class="pl-k">/</span> <span class="pl-c1">2</span>; i <span class="pl-k">&lt;</span> len <span class="pl-k">/</span> <span class="pl-c1">2</span> <span class="pl-k">*</span> <span class="pl-c1">2</span>; i<span class="pl-k">++</span>) {
      <span class="pl-k">int</span> temp <span class="pl-k">=</span> array[i];
      <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> i <span class="pl-k">-</span> <span class="pl-c1">1</span>; j <span class="pl-k">&gt;</span> <span class="pl-c1">2</span> <span class="pl-k">*</span> i <span class="pl-k">-</span> len; j<span class="pl-k">--</span>) {
        array[j <span class="pl-k">+</span> <span class="pl-c1">1</span>] <span class="pl-k">=</span> array[j];
      }
      array[<span class="pl-c1">2</span> <span class="pl-k">*</span> i <span class="pl-k">-</span> len <span class="pl-k">+</span> <span class="pl-c1">1</span>] <span class="pl-k">=</span> temp;
    }
    <span class="pl-k">return</span> array;
  }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-144-binary-tree-preorder-traversal" class="anchor" href="https://github.com/wishyouhappy/Algorithm#144-binary-tree-preorder-traversal" aria-hidden="true"><span class="octicon octicon-link"></span></a>144 Binary Tree Preorder Traversal</h3>

<blockquote>
<p>Given a binary tree, return the preorder traversal of its nodes' values.</p>
</blockquote>

<pre>For example:
Given binary tree {1,#,2,3},
   1
    \
     2
    /
   3
return [1,2,3].

</pre>

<p>Note: Recursive solution is trivial, could you do it iteratively?</p>

<p><strong>Idea</strong>:</p>

<ul>
<li><p>Solution 1: recursive. list.add(root.val), then recursive to left and right</p></li>
<li><p>Soltuion 2: Iterative. Use stack. If root != null,store root.val in result list and push root to stack, keep go left. Otherwise, pop root, go right</p></li>
<li><p>Solution 3: Morris, without stack. Create links to the successor(use leaf node's left or right null pointer), in the solution below, we use the right pointer. See details on blog <a href="http://wishyouhappy.github.io/2014/12/17/morris%20traversal-traverse%20a%20binary%20tree%20without%20stack/">Morris traversal</a></p></li>
</ul>

<p><strong>Solution 1</strong>: Recursive</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> preorderTraversal(<span class="pl-smi">TreeNode</span> root) {
        <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
        <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
            <span class="pl-k">return</span> res;
        }
        preorderTraversal(root, res);
        <span class="pl-k">return</span> res;
    }
    <span class="pl-k">public</span> <span class="pl-k">void</span> preorderTraversal(<span class="pl-smi">TreeNode</span> root, <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> res) {
        <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
            <span class="pl-k">return</span>;
        }
        res<span class="pl-k">.</span>add(root<span class="pl-k">.</span>val);
        preorderTraversal(root<span class="pl-k">.</span>left, res);
        preorderTraversal(root<span class="pl-k">.</span>right, res);
    }</pre></div>

<p><strong>Solution 2</strong>: iterative with stack</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> preorderTraversal(<span class="pl-smi">TreeNode</span> root) {
        <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
        <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
            <span class="pl-k">return</span> res;
        }
        <span class="pl-k">Stack&lt;<span class="pl-smi">TreeNode</span>&gt;</span> stack <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">Stack&lt;<span class="pl-smi">TreeNode</span>&gt;</span>();
        <span class="pl-k">while</span> (root <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> <span class="pl-k">!</span>stack<span class="pl-k">.</span>isEmpty()) {
            <span class="pl-k">if</span> (root <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
                res<span class="pl-k">.</span>add(root<span class="pl-k">.</span>val);
                stack<span class="pl-k">.</span>push(root);
                root <span class="pl-k">=</span> root<span class="pl-k">.</span>left;
            } <span class="pl-k">else</span> {
                root <span class="pl-k">=</span> stack<span class="pl-k">.</span>pop();
                root <span class="pl-k">=</span> root<span class="pl-k">.</span>right;
            }
        }
        <span class="pl-k">return</span> res;
    }</pre></div>

<p><strong>Solution 3</strong>: Morris traversal</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> preorderTraversal(<span class="pl-smi">TreeNode</span> root) {
        <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
        <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
            <span class="pl-k">return</span> res;
        }
        <span class="pl-smi">TreeNode</span> pre <span class="pl-k">=</span> <span class="pl-c1">null</span>;
        <span class="pl-k">while</span> (root <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
            <span class="pl-k">if</span> (root<span class="pl-k">.</span>left <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
                res<span class="pl-k">.</span>add(root<span class="pl-k">.</span>val);
                root <span class="pl-k">=</span> root<span class="pl-k">.</span>right;
            } <span class="pl-k">else</span> {
                pre <span class="pl-k">=</span> root<span class="pl-k">.</span>left;
                <span class="pl-k">while</span> (pre<span class="pl-k">.</span>right <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> pre<span class="pl-k">.</span>right <span class="pl-k">!=</span> root) {
                    pre <span class="pl-k">=</span> pre<span class="pl-k">.</span>right;
                }
                <span class="pl-k">if</span> (pre<span class="pl-k">.</span>right <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
                    pre<span class="pl-k">.</span>right <span class="pl-k">=</span> root;
                    res<span class="pl-k">.</span>add(root<span class="pl-k">.</span>val);
                    root <span class="pl-k">=</span> root<span class="pl-k">.</span>left;
                } <span class="pl-k">else</span> {
                    pre<span class="pl-k">.</span>right <span class="pl-k">=</span> <span class="pl-c1">null</span>;
                    root <span class="pl-k">=</span> root<span class="pl-k">.</span>right;
                }
            }
        }
        <span class="pl-k">return</span> res;
    }</pre></div>

<p><br></p>

<p><strong>Related</strong>: Search in binary search tree</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-smi">TreeNode</span> search(<span class="pl-smi">TreeNode</span> root, <span class="pl-k">int</span> key) {
    <span class="pl-c">// Write your solution here.</span>
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span> <span class="pl-c1">null</span>;
    }
    <span class="pl-k">while</span> (root <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">if</span> (root<span class="pl-k">.</span>key <span class="pl-k">==</span> key) {
        <span class="pl-k">return</span> root;
      } <span class="pl-k">else</span> <span class="pl-k">if</span> (root<span class="pl-k">.</span>key <span class="pl-k">&gt;</span> key) {
        root <span class="pl-k">=</span> root<span class="pl-k">.</span>left;
      } <span class="pl-k">else</span> {
        root <span class="pl-k">=</span> root<span class="pl-k">.</span>right;
      }
    }
    <span class="pl-k">return</span> <span class="pl-c1">null</span>;
}
</pre></div>

<p><br></p>

<p><strong>Related</strong>: Insert in binary search tree</p>

<p><strong>Idea</strong>:</p>

<ul>
<li>if root is null, insert new element as root</li>
<li>Otherwise search insert position. If insert key greater than parent, insert as right child otherwise, insert as left child</li>
</ul>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-smi">TreeNode</span> insert(<span class="pl-smi">TreeNode</span> root, <span class="pl-k">int</span> key) {
    <span class="pl-c">// Write your solution here.</span>
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      root <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">TreeNode</span>(key);
      <span class="pl-k">return</span> root;
    }
    <span class="pl-smi">TreeNode</span> temp <span class="pl-k">=</span> root;
    <span class="pl-smi">TreeNode</span> pre <span class="pl-k">=</span> <span class="pl-c1">null</span>;
    <span class="pl-k">while</span> (temp <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
      pre <span class="pl-k">=</span> temp;
      <span class="pl-k">if</span> (temp<span class="pl-k">.</span>key <span class="pl-k">==</span> key) {
        <span class="pl-k">return</span> root;
      } <span class="pl-k">else</span> <span class="pl-k">if</span> (temp<span class="pl-k">.</span>key <span class="pl-k">&lt;</span> key) {
        temp <span class="pl-k">=</span> temp<span class="pl-k">.</span>right;
      } <span class="pl-k">else</span> {
        temp <span class="pl-k">=</span> temp<span class="pl-k">.</span>left;
      }
    }
    <span class="pl-k">if</span> (pre<span class="pl-k">.</span>key <span class="pl-k">&gt;</span> key) {
      pre<span class="pl-k">.</span>left <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">TreeNode</span>(key);
    } <span class="pl-k">else</span> {
      pre<span class="pl-k">.</span>right <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">TreeNode</span>(key);
    }
    <span class="pl-k">return</span> root;
  }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-145-binary-tree-postorder-traversal" class="anchor" href="https://github.com/wishyouhappy/Algorithm#145-binary-tree-postorder-traversal" aria-hidden="true"><span class="octicon octicon-link"></span></a>145 Binary Tree Postorder Traversal</h3>

<blockquote>
<p>Given a binary tree, return the postorder traversal of its nodes' values.</p>
</blockquote>

<pre>For example:
Given binary tree {1,#,2,3},
   1
    \
     2
    /
   3
return [3,2,1].

</pre>

<p>Note: Recursive solution is trivial, could you do it iteratively?</p>

<p><strong>Idea</strong>:</p>

<ul>
<li><p>Solution 1: recursive. recursive to left and right, then list.add(root.val)</p></li>
<li><p>Soltuion 2: Iterative. Use stack. If root != null,push root to stack, keep go left. Otherwise, pop root, go right then add root.val</p></li>
<li><p>Solution 3: Morris, without stack. Create links to the successor(use leaf node's left or right null pointer), in the solution below, we use the right pointer. See details on blog <a href="http://wishyouhappy.github.io/2014/12/17/morris%20traversal-traverse%20a%20binary%20tree%20without%20stack/">Morris traversal</a></p></li>
</ul>

<p><strong>Solution 1</strong>: recursive</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> postorderTraversal(<span class="pl-smi">TreeNode</span> root) {
    <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
        <span class="pl-k">return</span> res;
    }
    postorderTraversal(root, res);
    <span class="pl-k">return</span> res;
}
<span class="pl-k">public</span> <span class="pl-k">void</span> postorderTraversal(<span class="pl-smi">TreeNode</span> root, <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> res) {
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
        <span class="pl-k">return</span>;
    }
    postorderTraversal(root<span class="pl-k">.</span>left, res);
    postorderTraversal(root<span class="pl-k">.</span>right, res);
    res<span class="pl-k">.</span>add(root<span class="pl-k">.</span>val);
}</pre></div>

<p><em>Solution 2</em>*: Iterative, from wiki</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> postorderTraversal(<span class="pl-smi">TreeNode</span> root){
    <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
    <span class="pl-k">Stack&lt;<span class="pl-smi">TreeNode</span>&gt;</span> stack <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">Stack&lt;<span class="pl-smi">TreeNode</span>&gt;</span>();
    <span class="pl-smi">TreeNode</span> preVisited <span class="pl-k">=</span> <span class="pl-c1">null</span>;
    <span class="pl-k">while</span> (root <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> <span class="pl-k">!</span>stack<span class="pl-k">.</span>isEmpty()) {
        <span class="pl-k">if</span> (root <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
            stack<span class="pl-k">.</span>push(root);
            root <span class="pl-k">=</span> root<span class="pl-k">.</span>left;
        } <span class="pl-k">else</span> {
            <span class="pl-smi">TreeNode</span> top <span class="pl-k">=</span> stack<span class="pl-k">.</span>peek();
            <span class="pl-k">if</span> (top<span class="pl-k">.</span>right <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> preVisited <span class="pl-k">!=</span> top<span class="pl-k">.</span>right) {
                root <span class="pl-k">=</span> top<span class="pl-k">.</span>right;
            } <span class="pl-k">else</span> {
                top <span class="pl-k">=</span> stack<span class="pl-k">.</span>pop();
                res<span class="pl-k">.</span>add(top<span class="pl-k">.</span>val);
                preVisited <span class="pl-k">=</span> top;
            }
        }
    }
    <span class="pl-k">return</span> res;
}
</pre></div>

<p><strong>Another iterative solution</strong>, store the return status in statck</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> postorderTraversal(<span class="pl-smi">TreeNode</span> root){
        <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> list <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
        <span class="pl-k">Stack&lt;<span class="pl-smi">TreeNode</span>&gt;</span> stack <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">Stack&lt;<span class="pl-smi">TreeNode</span>&gt;</span>();
        <span class="pl-k">Stack&lt;<span class="pl-smi">Integer</span>&gt;</span> statusStack <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">Stack&lt;<span class="pl-smi">Integer</span>&gt;</span>();
        <span class="pl-k">int</span> status <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        statusStack<span class="pl-k">.</span>push(<span class="pl-c1">0</span>);
        <span class="pl-k">while</span> (root <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> <span class="pl-k">!</span>stack<span class="pl-k">.</span>isEmpty()) {
            <span class="pl-k">if</span> (status <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
                <span class="pl-k">if</span>(root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
                    status <span class="pl-k">=</span> statusStack<span class="pl-k">.</span>pop();
                    <span class="pl-k">continue</span>;
                }
                stack<span class="pl-k">.</span>push(root);
                statusStack<span class="pl-k">.</span>push(<span class="pl-c1">1</span>);
                root <span class="pl-k">=</span> root<span class="pl-k">.</span>left;
            } <span class="pl-k">else</span> <span class="pl-k">if</span>(status <span class="pl-k">==</span> <span class="pl-c1">1</span>) {
                root <span class="pl-k">=</span> stack<span class="pl-k">.</span>peek();
                root <span class="pl-k">=</span> root<span class="pl-k">.</span>right;
                statusStack<span class="pl-k">.</span>push(<span class="pl-c1">2</span>);
                status <span class="pl-k">=</span> <span class="pl-c1">0</span>;
            } <span class="pl-k">else</span> {
                list<span class="pl-k">.</span>add(stack<span class="pl-k">.</span>pop()<span class="pl-k">.</span>val);
                status <span class="pl-k">=</span> statusStack<span class="pl-k">.</span>pop();
            }
        }
        <span class="pl-k">return</span> list;
    }</pre></div>

<p><strong>Solution 3</strong>: Morris</p>

<p>See details on blog <a href="http://wishyouhappy.github.io/2014/12/17/morris%20traversal-traverse%20a%20binary%20tree%20without%20stack/">Morris traversal</a></p>

<p><br>
<br></p>

<h3><a id="user-content-147-insertion-sort-list" class="anchor" href="https://github.com/wishyouhappy/Algorithm#147-insertion-sort-list" aria-hidden="true"><span class="octicon octicon-link"></span></a>147 Insertion Sort List</h3>

<blockquote>
<p>Sort a linked list using insertion sort.</p>
</blockquote>

<p><strong>Idea</strong>: It's similar to insertion sort array. The difference is that in array, if we want to insert i into (0....i-1), we can swap form i-1 if array[i] &lt; array[i-1]. But we can not visit a linkedlist by index. What we can do is visit from the first element.</p>

<p>Something we can do to simplify the insert:</p>

<ul>
<li>1) first check if current.val &gt;= pre.val. If true, it's already in right place. we can just go to the next element. </li>
<li>2) then check if current.val &lt;= head.val. If true, we can just insert it before the head.</li>
<li>3) If it's not eh two cases above, we need to find the right place to insert the element. Because we have eliminate the corner case above, thus we just need to find the insertion spot, then change the relationship of the pointers.</li>
</ul>

<p>If we add a fakeHead pointer to avoid the null pointer cases, we can have more concise code.</p>

<p><strong>Time</strong>*: O(n^2)</p>

<p><br></p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-smi">ListNode</span> insertionSortList(<span class="pl-smi">ListNode</span> head) {
        <span class="pl-k">if</span>(head <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">return</span> <span class="pl-c1">null</span>;
        <span class="pl-smi">ListNode</span> fakeHead <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">ListNode</span>(<span class="pl-k">-</span><span class="pl-c1">1</span>);
        <span class="pl-smi">ListNode</span> cur <span class="pl-k">=</span> head;
        <span class="pl-smi">ListNode</span> temp <span class="pl-k">=</span> fakeHead;
        <span class="pl-k">while</span>(cur <span class="pl-k">!=</span> <span class="pl-c1">null</span>){
            <span class="pl-smi">ListNode</span> next <span class="pl-k">=</span> cur<span class="pl-k">.</span>next;
            <span class="pl-smi">ListNode</span> pre <span class="pl-k">=</span> fakeHead;
            temp <span class="pl-k">=</span> fakeHead<span class="pl-k">.</span>next;
            <span class="pl-k">while</span>(temp <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> temp<span class="pl-k">.</span>val <span class="pl-k">&lt;</span> cur<span class="pl-k">.</span>val){
                pre <span class="pl-k">=</span> temp;
                temp <span class="pl-k">=</span> temp<span class="pl-k">.</span>next;
            }
            pre<span class="pl-k">.</span>next <span class="pl-k">=</span> cur;
            cur<span class="pl-k">.</span>next <span class="pl-k">=</span> temp;
            cur <span class="pl-k">=</span> next;
        }
        <span class="pl-k">return</span> fakeHead<span class="pl-k">.</span>next;
    }</pre></div>

<p><br></p>

<pre><code>/* Actually, in some cases the code below is a little faster then above.    Because when the element is alreay in the right place, we don't need to find    from the beginning */
</code></pre>

<div class="highlight highlight-java"><pre>     <span class="pl-k">public</span> <span class="pl-smi">ListNode</span> insertionSortList(<span class="pl-smi">ListNode</span> head) {
            <span class="pl-k">if</span>(head <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">return</span> <span class="pl-c1">null</span>;
            <span class="pl-smi">ListNode</span> cur <span class="pl-k">=</span> head<span class="pl-k">.</span>next;
            <span class="pl-smi">ListNode</span> preCur <span class="pl-k">=</span> head;
            <span class="pl-k">while</span>(cur <span class="pl-k">!=</span> <span class="pl-c1">null</span>){
                <span class="pl-smi">ListNode</span> next <span class="pl-k">=</span> cur<span class="pl-k">.</span>next;
                <span class="pl-k">if</span>(cur<span class="pl-k">.</span>val <span class="pl-k">&gt;=</span> preCur<span class="pl-k">.</span>val){
                    preCur <span class="pl-k">=</span> cur;
                }<span class="pl-k">else</span> <span class="pl-k">if</span>(cur<span class="pl-k">.</span>val <span class="pl-k">&lt;=</span> head<span class="pl-k">.</span>val){
                    cur<span class="pl-k">.</span>next <span class="pl-k">=</span> head;
                    head <span class="pl-k">=</span> cur;
                    preCur<span class="pl-k">.</span>next <span class="pl-k">=</span> next;
                }<span class="pl-k">else</span>{
                    <span class="pl-smi">ListNode</span> insertPre <span class="pl-k">=</span> head;
                    <span class="pl-smi">ListNode</span> temp <span class="pl-k">=</span> head<span class="pl-k">.</span>next;
                    <span class="pl-k">while</span>(temp <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> temp<span class="pl-k">.</span>val <span class="pl-k">&lt;</span> cur<span class="pl-k">.</span>val){
                        insertPre <span class="pl-k">=</span> temp;
                        temp <span class="pl-k">=</span> temp<span class="pl-k">.</span>next;
                    }
                    insertPre<span class="pl-k">.</span>next <span class="pl-k">=</span> cur;
                    cur<span class="pl-k">.</span>next <span class="pl-k">=</span> temp;
                    preCur<span class="pl-k">.</span>next <span class="pl-k">=</span> next;
                }
                cur <span class="pl-k">=</span> next;
            }
            <span class="pl-k">return</span> head;
        }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-148-sort-list" class="anchor" href="https://github.com/wishyouhappy/Algorithm#148-sort-list" aria-hidden="true"><span class="octicon octicon-link"></span></a>148 Sort List</h3>

<blockquote>
<p>Sort a linked list in O(n log n) time using constant space complexity.</p>
</blockquote>

<p><strong>Idea</strong>: It require us to sort in O(nlgn) time. "Mergesort" and "Quicksort" is the typical O(nlgn) sort algorithm. When use merge sort, similar with mergesort an array, we fisrt need to find the mid of the list. (The typical two pointer method to find the middle). Then sort(left, mid-1), sort(mid , right) and merge the result.</p>

<p><br></p>

<div class="highlight highlight-java"><pre>       <span class="pl-k">public</span> <span class="pl-smi">ListNode</span> sortList(<span class="pl-smi">ListNode</span> head){
            <span class="pl-k">if</span>(head <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> head<span class="pl-k">.</span>next <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">return</span> head;
            <span class="pl-smi">ListNode</span> f <span class="pl-k">=</span> head;
            <span class="pl-smi">ListNode</span> s <span class="pl-k">=</span> head;
            <span class="pl-smi">ListNode</span> pre <span class="pl-k">=</span> <span class="pl-c1">null</span>;
            <span class="pl-k">while</span>(f <span class="pl-k">!=</span> <span class="pl-c1">null</span>){
                f <span class="pl-k">=</span> f<span class="pl-k">.</span>next;
                <span class="pl-k">if</span>(f <span class="pl-k">!=</span> <span class="pl-c1">null</span>){
                    f <span class="pl-k">=</span> f<span class="pl-k">.</span>next;
                    pre <span class="pl-k">=</span> s;
                    s <span class="pl-k">=</span> s<span class="pl-k">.</span>next;
                }
            }
            pre<span class="pl-k">.</span>next <span class="pl-k">=</span> <span class="pl-c1">null</span>;
            <span class="pl-k">return</span> merge(sortList(s), sortList(head));
        }

        <span class="pl-k">public</span> <span class="pl-smi">ListNode</span> merge(<span class="pl-smi">ListNode</span> l1, <span class="pl-smi">ListNode</span> l2){
            <span class="pl-k">if</span>(l1 <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">return</span> l2;
            <span class="pl-k">if</span>(l2 <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">return</span> l1;
            <span class="pl-smi">ListNode</span> fakeHead <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">ListNode</span>(<span class="pl-k">-</span><span class="pl-c1">1</span>);
            <span class="pl-smi">ListNode</span> temp <span class="pl-k">=</span> fakeHead;
            <span class="pl-k">while</span>(l1 <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> l2 <span class="pl-k">!=</span> <span class="pl-c1">null</span>){
                <span class="pl-k">if</span>(l1<span class="pl-k">.</span>val <span class="pl-k">&gt;</span> l2<span class="pl-k">.</span>val){
                    temp<span class="pl-k">.</span>next <span class="pl-k">=</span> l2;
                    l2 <span class="pl-k">=</span> l2<span class="pl-k">.</span>next;
                }<span class="pl-k">else</span>{
                    temp<span class="pl-k">.</span>next <span class="pl-k">=</span> l1;
                    l1 <span class="pl-k">=</span> l1<span class="pl-k">.</span>next;
                }
                temp <span class="pl-k">=</span> temp<span class="pl-k">.</span>next;
            }
            <span class="pl-k">if</span>(l1 <span class="pl-k">!=</span> <span class="pl-c1">null</span>) temp<span class="pl-k">.</span>next <span class="pl-k">=</span> l1;
            <span class="pl-k">if</span>(l2 <span class="pl-k">!=</span> <span class="pl-c1">null</span>) temp<span class="pl-k">.</span>next <span class="pl-k">=</span> l2;
            <span class="pl-k">return</span> fakeHead<span class="pl-k">.</span>next;
        }</pre></div>

<p><br>
<br></p>

<p>153 Find Minimum in Rotated Sorted Array</p>

<blockquote>
<p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>

<p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>

<p>Find the minimum element.</p>

<p>You may assume <strong><em>no duplicate</em></strong> exists in the array.</p>
</blockquote>

<p><strong>Idea</strong>: The idea is same to * <a href="https://github.com/wishyouhappy/Algorithm#33-search-in-rotated-sorted-array">33 Search in Rotated Sorted Array</a>. </p>

<p>Each time we find the increasing interval. For example, if A[mid] &gt; A[l], then the left part must in order. Thus we update the minimum if needed, then jump to the right part. </p>

<p>Time complexity: O(lgn)</p>

<p><strong>Java code</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> findMin(<span class="pl-k">int</span>[] nums) {
        <span class="pl-k">if</span> (nums <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> nums<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-smi">Integer</span><span class="pl-c1"><span class="pl-k">.</span>MIN_VALUE</span>;
        }
        <span class="pl-k">int</span> l <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> r <span class="pl-k">=</span> nums<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>;
        <span class="pl-k">int</span> result <span class="pl-k">=</span> <span class="pl-smi">Integer</span><span class="pl-c1"><span class="pl-k">.</span>MAX_VALUE</span>;
        <span class="pl-k">while</span> (l <span class="pl-k">&lt;=</span> r) {
            <span class="pl-k">int</span> mid <span class="pl-k">=</span> l <span class="pl-k">+</span> (r <span class="pl-k">-</span> l) <span class="pl-k">/</span> <span class="pl-c1">2</span>;
            <span class="pl-c">//the left half is in order</span>
            <span class="pl-k">if</span> (nums[mid] <span class="pl-k">&gt;=</span> nums[l]) {
                result <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>min(result, nums[l]);
                l <span class="pl-k">=</span> mid <span class="pl-k">+</span> <span class="pl-c1">1</span>;
            } <span class="pl-k">else</span> <span class="pl-k">if</span> (nums[mid] <span class="pl-k">&lt;</span> nums[r]) {
                <span class="pl-c">//can also use  else if (nums[mid] &lt; numd[r])</span>
                result <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>min(result, nums[mid]);
                r <span class="pl-k">=</span> mid <span class="pl-k">-</span> <span class="pl-c1">1</span>;
            }
        }
        <span class="pl-k">return</span> result;
    }</pre></div>

<p><br>
<br></p>

<p>154 Find Minimum in Rotated Sorted Array</p>

<blockquote>
<p>Follow up for "Find Minimum in Rotated Sorted Array":
<strong><em>What if duplicates are allowed?</em></strong></p>

<p>Would this affect the run-time complexity? How and why?
Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>

<p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>

<p>Find the minimum element.</p>

<p>The array may contain duplicates.</p>
</blockquote>

<p><strong>Idea</strong>: Same way to handle duplicates with *<a href="https://github.com/wishyouhappy/Algorithm#81-search-in-rotated-sorted-array-ii">81 Search in Rotated Sorted Array II</a>. </p>

<p>To find the minimum, use the method in 153. </p>

<p>Each time we find the increasing interval. For example, if A[mid] &gt; A[l], then the left part must in order. Thus we update the minimum if needed, then jump to the right part. </p>

<p><strong>Attention</strong>: When nums[mid] = nums[l], we need to check if we have to update minimum with A[l] before l++</p>

<p><strong>Java Solution</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> findMin(<span class="pl-k">int</span>[] nums) {
        <span class="pl-k">if</span> (nums <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> nums<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-smi">Integer</span><span class="pl-c1"><span class="pl-k">.</span>MIN_VALUE</span>;
        }
        <span class="pl-k">int</span> l <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> r <span class="pl-k">=</span> nums<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>;
        <span class="pl-k">int</span> result <span class="pl-k">=</span> <span class="pl-smi">Integer</span><span class="pl-c1"><span class="pl-k">.</span>MAX_VALUE</span>;
        <span class="pl-k">while</span> (l <span class="pl-k">&lt;=</span> r) {
            <span class="pl-k">int</span> mid <span class="pl-k">=</span> l <span class="pl-k">+</span> (r <span class="pl-k">-</span> l) <span class="pl-k">/</span> <span class="pl-c1">2</span>;
            <span class="pl-c">//the left half is in order</span>
            <span class="pl-k">if</span> (nums[mid] <span class="pl-k">&gt;</span> nums[l]) {
                result <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>min(result, nums[l]);
                l <span class="pl-k">=</span> mid <span class="pl-k">+</span> <span class="pl-c1">1</span>;
            } <span class="pl-k">else</span> <span class="pl-k">if</span> (nums[mid] <span class="pl-k">&lt;</span> nums[l]) {
                result <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>min(result, nums[mid]);
                r <span class="pl-k">=</span> mid <span class="pl-k">-</span> <span class="pl-c1">1</span>;
            } <span class="pl-k">else</span> {
                result <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>min(result, nums[l]);
                l<span class="pl-k">++</span>;
            }
        }
        <span class="pl-k">return</span> result;
    }

</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-151-reverse-words-in-a-string" class="anchor" href="https://github.com/wishyouhappy/Algorithm#151-reverse-words-in-a-string" aria-hidden="true"><span class="octicon octicon-link"></span></a>151-reverse-words-in-a-string</h3>

<p><strong>Idea</strong>:</p>

<ul>
<li>1) First remove spaces at beginning and at end</li>
<li>2) use regular expression split words.</li>
<li>3) recreate result string</li>
</ul>

<p><strong>Solution</strong>:</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-smi">String</span> reverseWords(<span class="pl-smi">String</span> input) {
    <span class="pl-k">if</span> (input <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> input<span class="pl-k">.</span>length() <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
      <span class="pl-k">return</span> input;
    }
    input <span class="pl-k">=</span> input<span class="pl-k">.</span>trim();
    <span class="pl-k">String</span>[] arr <span class="pl-k">=</span> input<span class="pl-k">.</span>split(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\\</span>s+<span class="pl-pds">"</span></span>);
    <span class="pl-smi">StringBuilder</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">StringBuilder</span>();
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> arr<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>; i <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>; i<span class="pl-k">--</span>) {
      res<span class="pl-k">.</span>append(arr[i] <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span>);
    }
    <span class="pl-k">return</span> res<span class="pl-k">.</span>toString()<span class="pl-k">.</span>trim();
}
</pre></div>

<p><br></p>

<p><strong>Related</strong>: 
<br>
<br></p>

<h3><a id="user-content-155-min-stack" class="anchor" href="https://github.com/wishyouhappy/Algorithm#155-min-stack" aria-hidden="true"><span class="octicon octicon-link"></span></a>155 Min Stack</h3>

<blockquote>
<p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>

<pre>push(x) -- Push element x onto stack.
pop() -- Removes the element on top of the stack.
top() -- Get the top element.
getMin() -- Retrieve the minimum element in the stack.
</pre>
</blockquote>

<p><strong>Idea</strong>: Memory limits. If we just a corresponding minstack with the same length of the stack, we would exceed the limit on leetcode. What should we do? We just need to keep the current smallest element. Eg: push(1) to stack, we push(1) to minstack. Next time we push(2) to stack, we don't need to push(2) to minstack. Because the min value is still 1. Thus, every time we push an element to stack, we check if element x &gt; minstack.peek(), if true, we don't need to push. When pop, we check if element x == minstack.peek(), if equals, minstack.pop().</p>

<p><strong>Attention</strong> : Duplicate elements. (less or equal than, push into min stack). Eg: push (0), push(1), push(0), the minstack should have element 0, 0. </p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Solution</span> {
  <span class="pl-k">private</span> <span class="pl-k">Stack&lt;<span class="pl-smi">Integer</span>&gt;</span> stack;
  <span class="pl-k">private</span> <span class="pl-k">Stack&lt;<span class="pl-smi">Integer</span>&gt;</span> minStack;
  <span class="pl-k">public</span> <span class="pl-en">Solution</span>() {
    <span class="pl-c">// write your solution here</span>
    stack <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">Stack&lt;<span class="pl-smi">Integer</span>&gt;</span>();
    minStack <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">Stack&lt;<span class="pl-smi">Integer</span>&gt;</span>();
  }

  <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">pop</span>() {
    <span class="pl-k">if</span> (stack<span class="pl-k">.</span>isEmpty()) {
      <span class="pl-k">return</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
    }
    <span class="pl-k">if</span> (stack<span class="pl-k">.</span>peek() <span class="pl-k">&lt;=</span> minStack<span class="pl-k">.</span>peek()) {
      minStack<span class="pl-k">.</span>pop();
    }
    <span class="pl-k">return</span> stack<span class="pl-k">.</span>pop();
  }

  <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">push</span>(<span class="pl-k">int</span> <span class="pl-v">element</span>) {
    <span class="pl-k">if</span> (minStack<span class="pl-k">.</span>isEmpty() <span class="pl-k">||</span> minStack<span class="pl-k">.</span>peek() <span class="pl-k">&gt;=</span> element) {
      minStack<span class="pl-k">.</span>push(element);
    } 
    stack<span class="pl-k">.</span>push(element);
  }

  <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">top</span>() {
    <span class="pl-k">return</span> stack<span class="pl-k">.</span>isEmpty() <span class="pl-k">?</span> <span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-k">:</span> stack<span class="pl-k">.</span>peek();
  }

  <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">getMin</span>() {
    <span class="pl-k">return</span> stack<span class="pl-k">.</span>isEmpty() <span class="pl-k">?</span> <span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-k">:</span> minStack<span class="pl-k">.</span>peek();
  }
}
</pre></div>

<p><strong>Related</strong>: Implement queue with two stacks</p>

<div class="highlight highlight-java"><pre><span class="pl-k">class</span> <span class="pl-en">Solution</span>
{
  <span class="pl-k">private</span> <span class="pl-k">Stack&lt;<span class="pl-smi">Integer</span>&gt;</span> stackOne;
  <span class="pl-k">private</span> <span class="pl-k">Stack&lt;<span class="pl-smi">Integer</span>&gt;</span> stackTwo;
  <span class="pl-k">private</span> <span class="pl-k">int</span> size;
  <span class="pl-k">public</span> <span class="pl-en">Solution</span>() {
    <span class="pl-c">// Write your solution here.</span>
    stackOne <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">Stack&lt;<span class="pl-smi">Integer</span>&gt;</span>();
    stackTwo <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">Stack&lt;<span class="pl-smi">Integer</span>&gt;</span>();
    size <span class="pl-k">=</span> <span class="pl-c1">0</span>;
  }

  <span class="pl-k">public</span> <span class="pl-smi">Integer</span> <span class="pl-en">poll</span>() {
    <span class="pl-k">if</span> (<span class="pl-k">!</span>stackTwo<span class="pl-k">.</span>isEmpty()) {
      size<span class="pl-k">--</span>;
      <span class="pl-k">return</span> stackTwo<span class="pl-k">.</span>pop();
    }
    <span class="pl-k">while</span> (<span class="pl-k">!</span>stackOne<span class="pl-k">.</span>isEmpty()) {
      stackTwo<span class="pl-k">.</span>push(stackOne<span class="pl-k">.</span>pop());
    }
    <span class="pl-k">if</span> (<span class="pl-k">!</span>stackTwo<span class="pl-k">.</span>isEmpty()) {
      size<span class="pl-k">--</span>;
      <span class="pl-k">return</span> stackTwo<span class="pl-k">.</span>pop();
    } <span class="pl-k">else</span> {
      <span class="pl-k">return</span> <span class="pl-c1">null</span>;
    }
  }

  <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">offer</span>(<span class="pl-k">int</span> <span class="pl-v">element</span>) {
    stackOne<span class="pl-k">.</span>push(element);
    size<span class="pl-k">++</span>;
  }

  <span class="pl-k">public</span> <span class="pl-smi">Integer</span> <span class="pl-en">peek</span>() {
    <span class="pl-k">if</span> (<span class="pl-k">!</span>stackTwo<span class="pl-k">.</span>isEmpty()) {
      <span class="pl-k">return</span> stackTwo<span class="pl-k">.</span>peek();
    }
    <span class="pl-k">while</span> (<span class="pl-k">!</span>stackOne<span class="pl-k">.</span>isEmpty()) {
      stackTwo<span class="pl-k">.</span>push(stackOne<span class="pl-k">.</span>pop());
    }
    <span class="pl-k">if</span> (<span class="pl-k">!</span>stackTwo<span class="pl-k">.</span>isEmpty()) {
      <span class="pl-k">return</span> stackTwo<span class="pl-k">.</span>peek();
    } <span class="pl-k">else</span> {
      <span class="pl-k">return</span> <span class="pl-c1">null</span>;
    }
  }

  <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">size</span>() {
    <span class="pl-k">return</span> size;
  }

  <span class="pl-k">public</span> <span class="pl-k">boolean</span> <span class="pl-en">isEmpty</span>() {
    <span class="pl-k">return</span> size <span class="pl-k">==</span> <span class="pl-c1">0</span>;
  }
}</pre></div>

<h3><a id="user-content-156-binary-tree-upside-down" class="anchor" href="https://github.com/wishyouhappy/Algorithm#156-binary-tree-upside-down" aria-hidden="true"><span class="octicon octicon-link"></span></a>156 Binary Tree Upside Down</h3>

<blockquote>
<p>Given a binary tree where all the right nodes are either leaf nodes with a sibling (a left node that shares a same parent node) or empty, flip it upside down and turn it into a tree where the original right nodes turned into left leaf nodes. Return the new root.</p>
</blockquote>

<pre>For example:
Given a binary tree {1,2,3,4,5},
    1
   / \
  2   3
 / \
4   5

return the root of the binary tree [4,5,2,#,#,3,1].
   4
  / \
 5   2
    / \
   3   1                   
   
</pre>

<p><strong>Idea:</strong> </p>

<p>The structure of the original tree: </p>

<ul>
<li>1) right child doesn't have children</li>
<li>2) If right child exist, left child must exist. </li>
</ul>

<p>Structure of result tree:</p>

<ul>
<li><p>1) Right child turn to left child: p.left = parent.right</p></li>
<li><p>2) Parant becomes right child: p.right = parent </p></li>
<li><p>3) Left child becomes root. </p></li>
</ul>

<p><strong>Solution</strong>: Iterative</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-smi">TreeNode</span> upsideDownBinaryTree(<span class="pl-smi">TreeNode</span> root){
    <span class="pl-smi">TreeNode</span> parent <span class="pl-k">=</span> <span class="pl-c1">null</span>;
    <span class="pl-smi">TreeNode</span> rightChild <span class="pl-k">=</span> <span class="pl-c1">null</span>;
    <span class="pl-smi">TreeNode</span> leftChild <span class="pl-k">=</span> <span class="pl-c1">null</span>;
    <span class="pl-k">while</span> (root <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
        leftChild <span class="pl-k">=</span> root<span class="pl-k">.</span>left;
        root<span class="pl-k">.</span>left <span class="pl-k">=</span> rightChild; <span class="pl-c">//  Right child turn to left child</span>
        rightChild <span class="pl-k">=</span> root<span class="pl-k">.</span>right;
        root<span class="pl-k">.</span>right <span class="pl-k">=</span> parent;   <span class="pl-c">//Parant becomes right child</span>
        parent <span class="pl-k">=</span> root;
        root <span class="pl-k">=</span> leftChild;  <span class="pl-c">//Left child becomes root</span>
    }
    <span class="pl-k">return</span> parent;  
}   
</pre></div>

<p><strong>Solution</strong>: recursive</p>

<p><strong>Note</strong>: In this method, after change the tree, we need to set root.left = null and root.right = null. Otherwise, there will be a cycle.</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-smi">TreeNode</span> UpsideDownBinaryTree(<span class="pl-smi">TreeNode</span> root) {  
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
        <span class="pl-k">return</span> <span class="pl-c1">null</span>;
    }  
    <span class="pl-smi">TreeNode</span> parent <span class="pl-k">=</span> root;
    <span class="pl-smi">TreeNode</span> left <span class="pl-k">=</span> root<span class="pl-k">.</span>left;
    <span class="pl-smi">TreeNode</span> right <span class="pl-k">=</span> root<span class="pl-k">.</span>right;  
    <span class="pl-k">if</span> (left <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {  
        <span class="pl-smi">TreeNode</span> ret <span class="pl-k">=</span> upsideDownBinaryTree(left);  
        left<span class="pl-k">.</span>left <span class="pl-k">=</span> right;  
        left<span class="pl-k">.</span>right <span class="pl-k">=</span> parent;  
        root<span class="pl-k">.</span>left <span class="pl-k">=</span> <span class="pl-c1">null</span>;
        root<span class="pl-k">.</span>right <span class="pl-k">=</span> <span class="pl-c1">null</span>;
        <span class="pl-k">return</span> ret;  
    } 

    <span class="pl-k">return</span> root;  
}   
</pre></div>

<p><br></p>

<p><strong>Related</strong>: reverse binary tree.</p>

<pre>        1

      /    \

    2        5

  /   \

3      4

is reversed to

        3

      /    \

    2        4

  /   \

1      5


</pre>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-smi">TreeNode</span> reverse(<span class="pl-smi">TreeNode</span> root) {
    <span class="pl-smi">TreeNode</span> parent <span class="pl-k">=</span> <span class="pl-c1">null</span>;
    <span class="pl-smi">TreeNode</span> preRight <span class="pl-k">=</span> <span class="pl-c1">null</span>;
    <span class="pl-smi">TreeNode</span> right <span class="pl-k">=</span> <span class="pl-c1">null</span>;
    <span class="pl-smi">TreeNode</span> left <span class="pl-k">=</span> <span class="pl-c1">null</span>;
    <span class="pl-k">while</span> (root <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
      left <span class="pl-k">=</span> root<span class="pl-k">.</span>left;
      right <span class="pl-k">=</span> root<span class="pl-k">.</span>right;
      root<span class="pl-k">.</span>left <span class="pl-k">=</span> parent;
      root<span class="pl-k">.</span>right <span class="pl-k">=</span> preRight;
      parent <span class="pl-k">=</span> root;
      root <span class="pl-k">=</span> left;
      preRight <span class="pl-k">=</span> right;
    }
    <span class="pl-k">return</span> parent;
  }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-157-read-n-characters-given-read4" class="anchor" href="https://github.com/wishyouhappy/Algorithm#157-read-n-characters-given-read4" aria-hidden="true"><span class="octicon octicon-link"></span></a>157 Read N Characters Given Read4</h3>

<blockquote>
<p>The API: int read4(char *buf) reads 4 characters at a time from a file.</p>

<p>The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.</p>

<p>By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.</p>

<p>Note:The read function will only be called once for each test case.</p>
</blockquote>

<p><strong>Idea:</strong>Iterative call read4 before end of file or each n, store and copy it to the destination buf. </p>

<p><strong>Ambiguity:</strong>What if n exceeds the buf's length? </p>

<div class="highlight highlight-java"><pre>    <span class="pl-c">/* read 4 characters each time, return the exact number of characters read. */</span>
    <span class="pl-k">int</span> read(<span class="pl-k">char</span>[] buf);
    <span class="pl-k">public</span> <span class="pl-k">int</span> read(<span class="pl-k">char</span>[] buf, <span class="pl-k">int</span> n){
        <span class="pl-k">char</span>[] buffer <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">char</span>[<span class="pl-c1">4</span>];
        <span class="pl-k">int</span> count <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> current <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> needAdd <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">while</span>(<span class="pl-c1">true</span>){
            current <span class="pl-k">=</span> read(buffer);
            <span class="pl-k">if</span>(current <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> n <span class="pl-k">==</span> count) <span class="pl-k">return</span> count;
            needAdd <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>min(n<span class="pl-k">-</span>count, current);
            <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> needAdd; i<span class="pl-k">++</span>){
                buf[count<span class="pl-k">++</span>] <span class="pl-k">=</span>  buffer[i];
            }
        }
    }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-158-read-n-characters-given-read4-ii---call-multiple-times" class="anchor" href="https://github.com/wishyouhappy/Algorithm#158-read-n-characters-given-read4-ii---call-multiple-times" aria-hidden="true"><span class="octicon octicon-link"></span></a>158 Read N Characters Given Read4 II - Call multiple times.</h3>

<blockquote>
<p>The API: int read4(char *buf) reads 4 characters at a time from a file.</p>

<p>The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.</p>

<p>By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.</p>

<p>Note:
The read function may be called multiple times.</p>
</blockquote>

<p><strong>Idea:</strong> Because the read function maybe called multiple times, so at the next call, there might be some data remain in the read4 buffer due to the up amount data of n at each readN bytes call. So we need to keep track of the state of read 4 buffer. If there remains data at read4 buffer at the call, we need start from that position instead of call read4 function. </p>

<div class="highlight highlight-java"><pre>    <span class="pl-c">/* read 4 characters each time, return the exact number of characters read. */</span>
    <span class="pl-k">int</span> read(<span class="pl-k">char</span>[] buf);
    <span class="pl-k">int</span> read4Ptr <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">int</span> read4Count <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">char</span>[] buffer <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">char</span>[<span class="pl-c1">4</span>];
    <span class="pl-k">public</span> <span class="pl-k">int</span> read(<span class="pl-k">char</span>[] buf, <span class="pl-k">int</span> n){ 
        <span class="pl-k">int</span> count <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">while</span>(<span class="pl-c1">true</span>){
            <span class="pl-k">if</span>(read4Ptr <span class="pl-k">==</span> <span class="pl-c1">0</span>){
                read4Count <span class="pl-k">=</span> read(buffer);
            }
            <span class="pl-k">if</span>(read4Count <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> n <span class="pl-k">==</span> count) <span class="pl-k">return</span> count;
            <span class="pl-k">while</span>(count <span class="pl-k">&lt;</span> n <span class="pl-k">&amp;&amp;</span> read4Ptr <span class="pl-k">&lt;</span> read4Count){
                buf[count<span class="pl-k">++</span>] <span class="pl-k">=</span>  buffer[read4Ptr<span class="pl-k">++</span>];
            }
            read4Ptr <span class="pl-k">=</span> read4Ptr<span class="pl-k">%</span>read4Count;

        }
    }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-159-longest-string-with-at-most-two-distinct-characters" class="anchor" href="https://github.com/wishyouhappy/Algorithm#159-longest-string-with-at-most-two-distinct-characters" aria-hidden="true"><span class="octicon octicon-link"></span></a>159 Longest String with At Most Two Distinct Characters</h3>

<blockquote>
<p>Given a string, find longest substring T that contains at most 2 distinct characters.For example, Given s = “eceba”,T is "ece" which its length is 3.</p>
</blockquote>

<p><strong>Idea</strong>: Using a slide window keep track of the substring with at most 2 distinct characters. Each time we encounter the third distinct character, we first calculate the length of the substring, then we move the start position of our slide window to the position that contains only the third character, the first character or the third character, the second character. </p>

<p><strong>Example:</strong> Assume the string is accacccbac....., when we encounter "b" at index 7, we calculate the length of substring accaccc and do related operations, then we move the start position of slide window to index 4, then keep going... </p>

<p><strong>Solution &amp;&amp; time complexity:</strong>    Time complexity: O(n), map contains only two elements. Here, we can use two variables to replace the hashmap, if we extend the problem to k characters, then hashmap maybe more convenient </p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-smi">String</span> subString(<span class="pl-smi">String</span> s){
        <span class="pl-k">int</span> start <span class="pl-k">=</span> <span class="pl-c1">0</span>; <span class="pl-c">// start of longest substring</span>
        <span class="pl-k">int</span> end <span class="pl-k">=</span> <span class="pl-c1">0</span>;   <span class="pl-c">// end of longest substring</span>
        <span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>;     <span class="pl-c">// start of slide window</span>
        <span class="pl-k">int</span> max <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">Map&lt;<span class="pl-smi">Character</span>, <span class="pl-smi">Integer</span>&gt;</span> map <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashMap&lt;<span class="pl-smi">Character</span>, <span class="pl-smi">Integer</span>&gt;</span>();
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> s<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>){
            <span class="pl-c">//check: contains &lt;= 2 characters &amp;&amp; substring ends at the end </span>
            <span class="pl-k">if</span>(i <span class="pl-k">==</span> s<span class="pl-k">.</span>length()<span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-k">&amp;&amp;</span> map<span class="pl-k">.</span>size() <span class="pl-k">&lt;=</span> <span class="pl-c1">2</span> <span class="pl-k">&amp;&amp;</span> map<span class="pl-k">.</span>containsKey(s<span class="pl-k">.</span>charAt(i))){
                <span class="pl-k">if</span>(end <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> s;
                <span class="pl-k">else</span>{
                    <span class="pl-k">if</span>(max <span class="pl-k">&lt;</span> s<span class="pl-k">.</span>length() <span class="pl-k">-</span> j){
                        start <span class="pl-k">=</span> j;
                        end <span class="pl-k">=</span> s<span class="pl-k">.</span>length()<span class="pl-k">-</span><span class="pl-c1">1</span>; 
                    }
                }
            }
            <span class="pl-k">if</span>(map<span class="pl-k">.</span>size() <span class="pl-k">==</span> <span class="pl-c1">2</span> <span class="pl-k">&amp;&amp;</span> <span class="pl-k">!</span>map<span class="pl-k">.</span>containsKey(s<span class="pl-k">.</span>charAt(i))){
                <span class="pl-k">if</span>(max <span class="pl-k">&lt;</span> i <span class="pl-k">-</span> j){
                    max <span class="pl-k">=</span> i <span class="pl-k">-</span> j ;
                    start <span class="pl-k">=</span> j;
                    end <span class="pl-k">=</span> i<span class="pl-k">-</span><span class="pl-c1">1</span>;
                }
                j <span class="pl-k">=</span> s<span class="pl-k">.</span>length();
                <span class="pl-k">char</span> needToRemove <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span> <span class="pl-pds">'</span></span>;
                <span class="pl-k">for</span>(<span class="pl-k">char</span> c <span class="pl-k">:</span> map<span class="pl-k">.</span>keySet()){
                    <span class="pl-k">if</span>(j <span class="pl-k">&gt;</span> map<span class="pl-k">.</span>get(c)){
                        j <span class="pl-k">=</span> map<span class="pl-k">.</span>get(c);
                        needToRemove <span class="pl-k">=</span> c;
                    }
                }
                j<span class="pl-k">++</span>;
                map<span class="pl-k">.</span>remove(needToRemove);
            }
                map<span class="pl-k">.</span>put(s<span class="pl-k">.</span>charAt(i), i);
        }
        <span class="pl-k">return</span> s<span class="pl-k">.</span>substring(start, end<span class="pl-k">+</span><span class="pl-c1">1</span>);

</pre></div>

<p><strong>Another way</strong>: This is <strong>not as fast as</strong> the method above. If we encounter the third different element, we can find back from this element and reset the start window to make it contains only two different elements.</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-smi">String</span> subStr(<span class="pl-smi">String</span> s){
        <span class="pl-k">if</span>(s <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> s<span class="pl-k">.</span>length() <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> s;
        <span class="pl-k">Map&lt;<span class="pl-smi">Character</span>, <span class="pl-smi">Integer</span>&gt;</span> map <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashMap&lt;<span class="pl-smi">Character</span>, <span class="pl-smi">Integer</span>&gt;</span>();
        <span class="pl-k">int</span> start <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> max <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> end <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> s<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>){
            <span class="pl-k">if</span>(i <span class="pl-k">==</span> s<span class="pl-k">.</span>length()<span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-k">&amp;&amp;</span> map<span class="pl-k">.</span>size() <span class="pl-k">&lt;=</span> <span class="pl-c1">2</span> <span class="pl-k">&amp;&amp;</span> map<span class="pl-k">.</span>containsKey(s<span class="pl-k">.</span>charAt(i))){
                <span class="pl-k">if</span>(end <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> s;
                <span class="pl-k">else</span>{
                    <span class="pl-k">if</span>(max <span class="pl-k">&lt;</span> s<span class="pl-k">.</span>length() <span class="pl-k">-</span> j){
                        start <span class="pl-k">=</span> j;
                        end <span class="pl-k">=</span> s<span class="pl-k">.</span>length()<span class="pl-k">-</span><span class="pl-c1">1</span>; 
                    }
                }
            }
            <span class="pl-k">if</span>(<span class="pl-k">!</span>map<span class="pl-k">.</span>containsKey(s<span class="pl-k">.</span>charAt(i)) <span class="pl-k">&amp;&amp;</span> map<span class="pl-k">.</span>size() <span class="pl-k">==</span> <span class="pl-c1">2</span>){
                <span class="pl-k">if</span>(i <span class="pl-k">-</span> j <span class="pl-k">&gt;</span> max){
                    start <span class="pl-k">=</span> j;
                    end <span class="pl-k">=</span> i<span class="pl-k">-</span><span class="pl-c1">1</span>;
                    max <span class="pl-k">=</span> i<span class="pl-k">-</span>j;
                }
                <span class="pl-k">int</span> temp <span class="pl-k">=</span> i<span class="pl-k">-</span><span class="pl-c1">1</span>;
                <span class="pl-k">char</span> c <span class="pl-k">=</span> s<span class="pl-k">.</span>charAt(temp);
                <span class="pl-k">while</span>(temp <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> s<span class="pl-k">.</span>charAt(temp) <span class="pl-k">==</span> c) temp<span class="pl-k">--</span>;
                j <span class="pl-k">=</span> temp <span class="pl-k">+</span> <span class="pl-c1">1</span>;
                map<span class="pl-k">.</span>remove(s<span class="pl-k">.</span>charAt(temp));
            }
            map<span class="pl-k">.</span>put(s<span class="pl-k">.</span>charAt(i), i);
        }
        <span class="pl-k">return</span> j <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">?</span> s <span class="pl-k">:</span> s<span class="pl-k">.</span>substring(start, end<span class="pl-k">+</span><span class="pl-c1">1</span>);

    }
</pre></div>

<p><strong>Extention:</strong> Find the longest substring contains at most k unique elements. Idea is much similar with k = 2. When we encounter the k+1 character, we need to calculate the length of string do related operations and move slide window, let it contains only k-1 different characters, add the k+1 character, and keep going.  </p>

<p><strong>Time Complexity:</strong> O(k * n)</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-smi">String</span> subString(<span class="pl-smi">String</span> s, <span class="pl-k">int</span> k){
        <span class="pl-k">int</span> start <span class="pl-k">=</span> <span class="pl-c1">0</span>; <span class="pl-c">// start of longest substring</span>
        <span class="pl-k">int</span> end <span class="pl-k">=</span> <span class="pl-c1">0</span>;   <span class="pl-c">// end of longest substring</span>
        <span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>;     <span class="pl-c">// start of slide window</span>
        <span class="pl-k">int</span> max <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">Map&lt;<span class="pl-smi">Character</span>, <span class="pl-smi">Integer</span>&gt;</span> map <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashMap&lt;<span class="pl-smi">Character</span>, <span class="pl-smi">Integer</span>&gt;</span>();
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> s<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>){
            <span class="pl-c">//check: contains &lt;= 2 characters &amp;&amp; substring ends at the end </span>
            <span class="pl-k">if</span>(i <span class="pl-k">==</span> s<span class="pl-k">.</span>length()<span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-k">&amp;&amp;</span> map<span class="pl-k">.</span>size() <span class="pl-k">&lt;=</span> k <span class="pl-k">&amp;&amp;</span> map<span class="pl-k">.</span>containsKey(s<span class="pl-k">.</span>charAt(i))){
                <span class="pl-k">if</span>(end <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> s;
                <span class="pl-k">else</span>{
                    <span class="pl-k">if</span>(max <span class="pl-k">&lt;</span> s<span class="pl-k">.</span>length() <span class="pl-k">-</span> j){
                        start <span class="pl-k">=</span> j;
                        end <span class="pl-k">=</span> s<span class="pl-k">.</span>length()<span class="pl-k">-</span><span class="pl-c1">1</span>; 
                    }
                }
            }
            <span class="pl-k">if</span>(map<span class="pl-k">.</span>size() <span class="pl-k">==</span> k <span class="pl-k">&amp;&amp;</span> <span class="pl-k">!</span>map<span class="pl-k">.</span>containsKey(s<span class="pl-k">.</span>charAt(i))){
                <span class="pl-k">if</span>(max <span class="pl-k">&lt;</span> i <span class="pl-k">-</span> j){
                    max <span class="pl-k">=</span> i <span class="pl-k">-</span> j ;
                    start <span class="pl-k">=</span> j;
                    end <span class="pl-k">=</span> i<span class="pl-k">-</span><span class="pl-c1">1</span>;
                }
                j <span class="pl-k">=</span> s<span class="pl-k">.</span>length();
                <span class="pl-k">char</span> needToRemove <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span> <span class="pl-pds">'</span></span>;
                <span class="pl-k">for</span>(<span class="pl-k">char</span> c <span class="pl-k">:</span> map<span class="pl-k">.</span>keySet()){
                    <span class="pl-k">if</span>(j <span class="pl-k">&gt;</span> map<span class="pl-k">.</span>get(c)){
                        j <span class="pl-k">=</span> map<span class="pl-k">.</span>get(c);
                        needToRemove <span class="pl-k">=</span> c;
                    }
                }
                j<span class="pl-k">++</span>;
                map<span class="pl-k">.</span>remove(needToRemove);
            }
                map<span class="pl-k">.</span>put(s<span class="pl-k">.</span>charAt(i), i);
        }
        <span class="pl-k">return</span> s<span class="pl-k">.</span>substring(start, end<span class="pl-k">+</span><span class="pl-c1">1</span>);
    }</pre></div>

<p><br>
<strong>Related</strong>: longest substring without repeating characters.</p>

<p><strong>Time complexity</strong>: O(2 * n) = O(n)</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">int</span> lengthOfLongestSubstring(<span class="pl-smi">String</span> s) {
    <span class="pl-k">if</span> (s <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> s<span class="pl-k">.</span>length() <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
      <span class="pl-k">return</span> <span class="pl-c1">0</span>;
    }
    <span class="pl-k">int</span> res <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">int</span> start <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">int</span> current <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">Set&lt;<span class="pl-smi">Character</span>&gt;</span> set <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashSet&lt;<span class="pl-smi">Character</span>&gt;</span>();
    <span class="pl-k">while</span> (current <span class="pl-k">&lt;</span> s<span class="pl-k">.</span>length()) {
      <span class="pl-k">char</span> c <span class="pl-k">=</span> s<span class="pl-k">.</span>charAt(current);
      <span class="pl-k">if</span> (<span class="pl-k">!</span>set<span class="pl-k">.</span>contains(c)) {
        set<span class="pl-k">.</span>add(c);
      } <span class="pl-k">else</span> {
        res <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(res, current <span class="pl-k">-</span> start);
        <span class="pl-k">while</span> (s<span class="pl-k">.</span>charAt(start) <span class="pl-k">!=</span> c) {
          set<span class="pl-k">.</span>remove(s<span class="pl-k">.</span>charAt(start<span class="pl-k">++</span>));
        }
        start<span class="pl-k">++</span>;
      }
      current<span class="pl-k">++</span>;
    }
    res <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(res, current <span class="pl-k">-</span> start);
    <span class="pl-k">return</span> res;
  }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-160-intersection-of-two-linked-lists" class="anchor" href="https://github.com/wishyouhappy/Algorithm#160-intersection-of-two-linked-lists" aria-hidden="true"><span class="octicon octicon-link"></span></a>160 Intersection of Two Linked Lists</h3>

<blockquote>
<p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>
</blockquote>

<pre>For example, the following two linked lists:

A:          a1 → a2
                   ↘
                     c1 → c2 → c3
                   ↗            
B:     b1 → b2 → b3

begin to intersect at node c1.

</pre>

<p>Notes:</p>

<p>If the two linked lists have no intersection at all, return null.</p>

<p>The linked lists must retain their original structure after the function returns.</p>

<p>You may assume there are no cycles anywhere in the entire linked structure.</p>

<p>Your code should preferably run in O(n) time and use only O(1) memory.</p>

<p><br></p>

<p><strong>Idea</strong>: </p>

<p>Solustion1: </p>

<p>We can get the length of two linkedlist, assume len1 &gt; len2. We move head1 move len1-len2 steps, then compare each node in list1 and list2, until two lists have the same nodes. </p>

<p>Solution2: We don't need to calculae the length of list1 and list2. Use two pointers p1 p2, when one pointer reaches the end, assume it's p1, we change p1  to head2. Then continues until p2 reach to the end. By this time, p1 is pointer to len2 -len1 of list2, we let p2 points to head1. So we can continue to compare until we encounter same nodes. </p>

<p><strong>Attention</strong>: Null pointer! We need to take care of null pointer for all linkedlist problems.</p>

<p>Solution1 :</p>

<div class="highlight highlight-java"><pre>     <span class="pl-k">public</span> <span class="pl-smi">ListNode</span> getIntersectionNode(<span class="pl-smi">ListNode</span> headA, <span class="pl-smi">ListNode</span> headB) {
           <span class="pl-k">if</span>(headA <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> headB <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">return</span> <span class="pl-c1">null</span>;
           <span class="pl-k">int</span> lenA <span class="pl-k">=</span> <span class="pl-c1">0</span>;
           <span class="pl-k">int</span> lenB <span class="pl-k">=</span> <span class="pl-c1">0</span>;
           <span class="pl-smi">ListNode</span> temp <span class="pl-k">=</span> headA;
           <span class="pl-k">while</span>(temp <span class="pl-k">!=</span> <span class="pl-c1">null</span>){
               lenA<span class="pl-k">++</span>;
               temp <span class="pl-k">=</span> temp<span class="pl-k">.</span>next;
           }
           temp <span class="pl-k">=</span> headB;
           <span class="pl-k">while</span>(temp <span class="pl-k">!=</span> <span class="pl-c1">null</span>){
               temp <span class="pl-k">=</span> temp<span class="pl-k">.</span>next;
               lenB<span class="pl-k">++</span>;
           }
           <span class="pl-k">int</span> diff <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>abs(lenA <span class="pl-k">-</span> lenB);
           <span class="pl-k">if</span>(lenA <span class="pl-k">&gt;</span> lenB){
               <span class="pl-k">while</span>(diff <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>) {
                   headA <span class="pl-k">=</span> headA<span class="pl-k">.</span>next;
                   diff<span class="pl-k">--</span>;
               }
           }<span class="pl-k">else</span>{
               <span class="pl-k">while</span>(diff <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>){
                   headB <span class="pl-k">=</span> headB<span class="pl-k">.</span>next;
                   diff<span class="pl-k">--</span>;
               }
           }
           <span class="pl-k">while</span>(headA <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> headB <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> <span class="pl-k">!</span>headA<span class="pl-k">.</span>equals(headB)){
               headA <span class="pl-k">=</span> headA<span class="pl-k">.</span>next;
               headB <span class="pl-k">=</span> headB<span class="pl-k">.</span>next;
           }
           <span class="pl-k">return</span> headA;
     }</pre></div>

<p>Solution2:</p>

<div class="highlight highlight-java"><pre>     <span class="pl-k">public</span> <span class="pl-smi">ListNode</span> getIntersectionNode2(<span class="pl-smi">ListNode</span> headA, <span class="pl-smi">ListNode</span> headB) {
           <span class="pl-k">if</span>(headA <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> headB <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">return</span> <span class="pl-c1">null</span>;
           <span class="pl-smi">ListNode</span> tempA <span class="pl-k">=</span> headA;
           <span class="pl-smi">ListNode</span> tempB <span class="pl-k">=</span> headB;
           <span class="pl-k">while</span>(tempA <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> tempB <span class="pl-k">!=</span> <span class="pl-c1">null</span>){
               tempA <span class="pl-k">=</span> tempA<span class="pl-k">.</span>next;
               tempB <span class="pl-k">=</span> tempB<span class="pl-k">.</span>next;
           }
           tempA <span class="pl-k">=</span> tempA <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">?</span> headB <span class="pl-k">:</span> tempA;
           tempB <span class="pl-k">=</span> tempB <span class="pl-k">==</span> <span class="pl-c1">null</span><span class="pl-k">?</span> headA <span class="pl-k">:</span> tempB;
           <span class="pl-k">while</span>(tempA <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> tempB <span class="pl-k">!=</span> <span class="pl-c1">null</span>){
               tempA <span class="pl-k">=</span> tempA<span class="pl-k">.</span>next;
               tempB <span class="pl-k">=</span> tempB<span class="pl-k">.</span>next;
           }
          tempA <span class="pl-k">=</span> tempA <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">?</span> headB <span class="pl-k">:</span> tempA;
          tempB <span class="pl-k">=</span> tempB <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">?</span> headA <span class="pl-k">:</span> tempB;
          <span class="pl-k">while</span>(tempA <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> tempB <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> <span class="pl-k">!</span>tempA<span class="pl-k">.</span>equals(tempB)){
              tempA <span class="pl-k">=</span> tempA<span class="pl-k">.</span>next;
              tempB <span class="pl-k">=</span> tempB<span class="pl-k">.</span>next;
          }
          <span class="pl-k">return</span> tempA;
     }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-161-one-edit-distance" class="anchor" href="https://github.com/wishyouhappy/Algorithm#161-one-edit-distance" aria-hidden="true"><span class="octicon octicon-link"></span></a>161 One edit distance</h3>

<blockquote>
<p>Given two string, after one edit, if they equals, return true, otherwise return false. </p>
</blockquote>

<p><strong>Idea</strong>:</p>

<ul>
<li><p>One edit contains: one delete, one add or one change.</p></li>
<li><p>if abs (word1.length() - word2.length()) &gt; 1, return false</p></li>
<li><p>if length equals, then they should have one different character</p></li>
<li><p>if length1 &lt; length2, then after find the first different character, the remain should be the same.</p></li>
</ul>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">boolean</span> isOneEditDistance(<span class="pl-smi">String</span> word1, <span class="pl-smi">String</span> word2){
        <span class="pl-c">//After swap, word1.length() &lt;= word2.length</span>
        <span class="pl-smi">String</span> temp <span class="pl-k">=</span> word1<span class="pl-k">.</span>length() <span class="pl-k">&lt;</span> word2<span class="pl-k">.</span>length() <span class="pl-k">?</span> word1 <span class="pl-k">:</span> word2;
        word2 <span class="pl-k">=</span> temp<span class="pl-k">.</span>equals(word1) <span class="pl-k">?</span> word2 <span class="pl-k">:</span> word1;
        word1 <span class="pl-k">=</span> temp<span class="pl-k">.</span>equals(word1) <span class="pl-k">?</span> word1 <span class="pl-k">:</span> temp;

        <span class="pl-k">int</span> len1 <span class="pl-k">=</span> word1<span class="pl-k">.</span>length();
        <span class="pl-k">int</span> len2 <span class="pl-k">=</span> word2<span class="pl-k">.</span>length();

        <span class="pl-k">if</span> (len2 <span class="pl-k">&gt;</span> len1<span class="pl-k">+</span><span class="pl-c1">1</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        <span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">while</span> (i <span class="pl-k">&lt;</span> len1 <span class="pl-k">&amp;&amp;</span> word1<span class="pl-k">.</span>charAt(i) <span class="pl-k">==</span> word2<span class="pl-k">.</span>charAt(i)) {
            i<span class="pl-k">++</span>;
        }
        <span class="pl-k">if</span> (i <span class="pl-k">==</span> len1) {
            <span class="pl-k">return</span> (len2<span class="pl-k">-</span>len1) <span class="pl-k">==</span> <span class="pl-c1">1</span>;
        }
        <span class="pl-k">if</span>(len1 <span class="pl-k">==</span> len2) {
            i<span class="pl-k">++</span>;
        }

        <span class="pl-c">/* if two len equals, two of them start from i+1, if not equals, word2 start from i+1*/</span>
        <span class="pl-k">while</span>(i <span class="pl-k">&lt;</span> len1 <span class="pl-k">&amp;&amp;</span> word1<span class="pl-k">.</span>charAt(i) <span class="pl-k">==</span> word2<span class="pl-k">.</span>charAt(i<span class="pl-k">+</span>len2<span class="pl-k">-</span>len1)) {
            i<span class="pl-k">++</span>;
        }
        <span class="pl-k">return</span> i <span class="pl-k">==</span> len1;
    }
</pre></div>

<p><br></p>

<p><strong>Related</strong>: Edit distance</p>

<blockquote>
<p>Given two strings, return the minimum edits to make them equal.</p>
</blockquote>

<p><strong>Idea</strong>:</p>

<ul>
<li><p>Base case: i = 0 , arr[i][j] = j
         j = 0, arr[i][j] = i</p></li>
<li><p>induction: arr[i][j] = arr[i-1][j-1] if one[i-1] = two[j-1] otherwise, arr[i][j] = min(arr[i-1][j-1], arr[i-1][j], arr[i][j-1]) + 1</p></li>
</ul>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">int</span> editDistance(<span class="pl-smi">String</span> one, <span class="pl-smi">String</span> two) {
    <span class="pl-k">int</span>[][] arr <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[one<span class="pl-k">.</span>length() <span class="pl-k">+</span> <span class="pl-c1">1</span>][two<span class="pl-k">.</span>length() <span class="pl-k">+</span> <span class="pl-c1">1</span>];
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;=</span> one<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>) {
      <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;=</span> two<span class="pl-k">.</span>length(); j<span class="pl-k">++</span>) {
        <span class="pl-c">//base case</span>
        <span class="pl-k">if</span> (i <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
          arr[i][j] <span class="pl-k">=</span> j;
        } <span class="pl-k">else</span> <span class="pl-k">if</span> (j <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
          arr[i][j] <span class="pl-k">=</span> i;
        } <span class="pl-k">else</span> <span class="pl-k">if</span> (one<span class="pl-k">.</span>charAt(i <span class="pl-k">-</span> <span class="pl-c1">1</span>) <span class="pl-k">==</span> two<span class="pl-k">.</span>charAt(j <span class="pl-k">-</span> <span class="pl-c1">1</span>)) {
          arr[i][j] <span class="pl-k">=</span> arr[i <span class="pl-k">-</span> <span class="pl-c1">1</span>][j <span class="pl-k">-</span> <span class="pl-c1">1</span>];
        } <span class="pl-k">else</span> {
          <span class="pl-k">int</span> min <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>min(arr[i <span class="pl-k">-</span> <span class="pl-c1">1</span>][j], arr[i][j <span class="pl-k">-</span> <span class="pl-c1">1</span>]);
          arr[i][j] <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>min(min, arr[i <span class="pl-k">-</span> <span class="pl-c1">1</span>][j <span class="pl-k">-</span> <span class="pl-c1">1</span>]) <span class="pl-k">+</span> <span class="pl-c1">1</span>;
        }
      }
    }
    <span class="pl-k">return</span> arr[one<span class="pl-k">.</span>length()][two<span class="pl-k">.</span>length()];
  }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-162-find-peak-element" class="anchor" href="https://github.com/wishyouhappy/Algorithm#162-find-peak-element" aria-hidden="true"><span class="octicon octicon-link"></span></a>162 Find Peak Element</h3>

<blockquote>
<p>A peak element is an element that is greater than its neighbors.</p>

<p>Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.</p>

<p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p>

<p>You may imagine that num[-1] = num[n] = -∞.</p>

<p>For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.</p>
</blockquote>

<p><strong>Idea</strong>: Since there is no duplicate, and num[-1] = num[n] = -inf, thus the peak must exist. We can eaisly solve this problem in brute force in O(n) time. Can we improve it? </p>

<p>Sure, use <strong>binary search!.</strong></p>

<p>Since we only need to return one of the peaks, thus if we encounter an element which satisfies that num[i-1] &lt; num[i], num[i] &gt; num[i+1], then we can return. </p>

<p>Then how to change window in binary search?
We move to the side that has has peeks. We can check if num[i-1] &gt; num[i], if it is true, then we move to the left, otherwise, we move to the right.</p>

<p>Look at the following picture:</p>

<p><a href="./wishyouhappy_Algorithm_files/68747470733a2f2f77697368796f7568617070792e6769746875622e696f2f70696374757265732f7065616b656c656d656e742e706e67" target="_blank"><img src="./wishyouhappy_Algorithm_files/68747470733a2f2f77697368796f7568617070792e6769746875622e696f2f70696374757265732f7065616b656c656d656e742e706e67" alt="peak" data-canonical-src="https://wishyouhappy.github.io/pictures/peakelement.png" style="max-width:100%;"></a></p>

<p>Suppose in the above three cases, 5 is the mid.</p>

<ul>
<li>case 1: return 5, because 5 is a peak</li>
<li>case 2: num[mid -1] &gt; num[mid], thus there must exist a peak on the left side. Why? If 7 is larger than the element on the left side of it, then 7 is a peak, otherwise, the element on the left side of 7 might be a peak. Because we know that there is a -inf on the leftmost.</li>
<li>case 3: num[mid - 1] &lt; num[mid], then we move to the right part. Because the element on the right side of 5 must be larger than 5. Otherwise, 5 is a peak.</li>
</ul>

<p>*<em>Java code *</em>: </p>

<p><strong>Binary search</strong>: TIME : O(lgn)</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> findPeakElement(<span class="pl-k">int</span>[] nums) {
        <span class="pl-k">if</span> (nums <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> nums<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
        }
        <span class="pl-k">int</span> l <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> r <span class="pl-k">=</span> nums<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>;
        <span class="pl-k">while</span> (l <span class="pl-k">&lt;=</span> r) {
            <span class="pl-k">int</span> mid <span class="pl-k">=</span> l <span class="pl-k">+</span> (r <span class="pl-k">-</span> l) <span class="pl-k">/</span> <span class="pl-c1">2</span>;
            <span class="pl-k">if</span> ((mid <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> nums[mid] <span class="pl-k">&gt;</span> nums[mid <span class="pl-k">-</span> <span class="pl-c1">1</span>]) <span class="pl-k">&amp;&amp;</span> (mid <span class="pl-k">==</span> nums<span class="pl-k">.</span>length <span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-k">||</span> nums[mid] <span class="pl-k">&gt;</span> nums[mid <span class="pl-k">+</span> <span class="pl-c1">1</span>])) {
                <span class="pl-k">return</span> mid;
            } <span class="pl-k">else</span> <span class="pl-k">if</span> (mid <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> nums[mid] <span class="pl-k">&lt;</span> nums[mid <span class="pl-k">-</span> <span class="pl-c1">1</span>]) {
                r <span class="pl-k">=</span> mid <span class="pl-k">-</span> <span class="pl-c1">1</span>;
            } <span class="pl-k">else</span> {
                l <span class="pl-k">=</span> mid <span class="pl-k">+</span> <span class="pl-c1">1</span>;
            }
        }
        <span class="pl-k">return</span> l;
    }
</pre></div>

<p><strong>Brute force</strong>: Time complexity: O(n)</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> findPeakElement1(<span class="pl-k">int</span>[] num) {
        <span class="pl-k">if</span>(num <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> num<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
        <span class="pl-k">if</span>(num<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">1</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> num<span class="pl-k">.</span>length<span class="pl-k">-</span><span class="pl-c1">1</span>; i<span class="pl-k">++</span>){
            <span class="pl-k">if</span>(i <span class="pl-k">==</span> <span class="pl-c1">0</span>){
                <span class="pl-k">if</span>(num[i] <span class="pl-k">&gt;</span> num[i<span class="pl-k">+</span><span class="pl-c1">1</span>]) <span class="pl-k">return</span> i;
            }<span class="pl-k">else</span>{
                <span class="pl-k">if</span>(num[i] <span class="pl-k">&gt;</span> num[i<span class="pl-k">+</span><span class="pl-c1">1</span>] <span class="pl-k">&amp;&amp;</span> num[i] <span class="pl-k">&gt;</span> num[i<span class="pl-k">-</span><span class="pl-c1">1</span>]) <span class="pl-k">return</span> i;
            }
        }
        <span class="pl-k">if</span>(num[num<span class="pl-k">.</span>length<span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">&gt;</span> num[num<span class="pl-k">.</span>length<span class="pl-k">-</span><span class="pl-c1">2</span>]) <span class="pl-k">return</span> num<span class="pl-k">.</span>length <span class="pl-k">-</span><span class="pl-c1">1</span>;
        <span class="pl-k">return</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
    }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-166-fraction-to-recurring-decimal" class="anchor" href="https://github.com/wishyouhappy/Algorithm#166-fraction-to-recurring-decimal" aria-hidden="true"><span class="octicon octicon-link"></span></a>166 Fraction to Recurring Decimal</h3>

<blockquote>
<p>Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.</p>

<p>If the fractional part is repeating, enclose the repeating part in parentheses.</p>
</blockquote>

<pre><code>For example,

Given numerator = 1, denominator = 2, return "0.5".
Given numerator = 2, denominator = 1, return "2".
Given numerator = 2, denominator = 3, return "0.(6)".
</code></pre>

<p><br></p>

<p><strong>Idea</strong>: Just do the divide like what we normally do in math. </p>

<p>For example, 3/7 </p>

<ul>
<li>quotient = 0, remainer = 3 , string = 0.</li>
<li><strong>3 * 10/7</strong> quotient = 4, remainder = 2; string = 0.4</li>
<li>2 * 10/ 7 quotient = 2, remainder = 6; string = 0.42</li>
<li>6 * 10/7 quotient = 8, remainder = 4; string = 0.428</li>
<li>4 * 10 /7 quotient = 5, remainder = 5; string = 0.4285</li>
<li>5 * 10/7 quotient = 7, remainder = 1, string = 0.42857</li>
<li>1 * 10/7 quotient = 1, remainder = 3, string = 0.428571</li>
<li><strong>3 * 10/7</strong></li>
</ul>

<p>Thus, we know the result is 0.(428571)</p>

<p>In order to know when the recuisive begins, we need to record the remainder at each iteration.</p>

<p><strong>Attention</strong></p>

<ul>
<li>1)We need to do abs for both numbers, otherwise, there might be unnecessary "-" in the result string</li>
<li>2)abs(Integer.MIN_VALUE)</li>
<li>3)use hashmap to record the position of each remainder.</li>
</ul>

<p><br></p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-smi">String</span> fractionToDecimal(<span class="pl-k">int</span> numerator, <span class="pl-k">int</span> denominator) {
        <span class="pl-k">if</span>(denominator <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> numerator <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>0<span class="pl-pds">"</span></span>;
        <span class="pl-smi">StringBuilder</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">StringBuilder</span>();
        <span class="pl-k">Map&lt;<span class="pl-smi">Long</span>, <span class="pl-smi">Integer</span>&gt;</span> map <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashMap&lt;<span class="pl-smi">Long</span>, <span class="pl-smi">Integer</span>&gt;</span>();
        <span class="pl-k">boolean</span> positive <span class="pl-k">=</span> ((numerator <span class="pl-k">^</span> denominator) <span class="pl-k">&gt;&gt;&gt;</span> <span class="pl-c1">31</span>) <span class="pl-k">==</span> <span class="pl-c1">0</span>;
        <span class="pl-k">if</span>(<span class="pl-k">!</span>positive) res<span class="pl-k">.</span>append(<span class="pl-s"><span class="pl-pds">"</span>-<span class="pl-pds">"</span></span>);
        <span class="pl-k">long</span> num <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>abs((<span class="pl-k">long</span>)numerator);
        <span class="pl-k">long</span> den <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>abs((<span class="pl-k">long</span>)denominator);
        res<span class="pl-k">.</span>append(num<span class="pl-k">/</span>den);
        <span class="pl-k">if</span>(num <span class="pl-k">%</span> den <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> res<span class="pl-k">.</span>toString();
        res<span class="pl-k">.</span>append(<span class="pl-s"><span class="pl-pds">"</span>.<span class="pl-pds">"</span></span>);
        <span class="pl-k">long</span> mod <span class="pl-k">=</span> num <span class="pl-k">%</span> den;
        <span class="pl-k">while</span>(mod <span class="pl-k">!=</span> <span class="pl-c1">0</span>){
            <span class="pl-k">if</span>(map<span class="pl-k">.</span>containsKey(mod)){
                res<span class="pl-k">.</span>insert(map<span class="pl-k">.</span>get(mod), <span class="pl-s"><span class="pl-pds">"</span>(<span class="pl-pds">"</span></span>);
                res<span class="pl-k">.</span>append(<span class="pl-s"><span class="pl-pds">"</span>)<span class="pl-pds">"</span></span>);
                <span class="pl-k">return</span> res<span class="pl-k">.</span>toString();
            }
            map<span class="pl-k">.</span>put(mod, res<span class="pl-k">.</span>length());
            mod <span class="pl-k">=</span> mod <span class="pl-k">*</span> <span class="pl-c1">10</span>;
            <span class="pl-k">long</span> divide <span class="pl-k">=</span> mod<span class="pl-k">/</span>den;
            mod <span class="pl-k">=</span> mod <span class="pl-k">%</span> den;
            res<span class="pl-k">.</span>append(divide);
        }
        <span class="pl-k">return</span> res<span class="pl-k">.</span>toString();
    }
</pre></div>

<p><br></p>

<p><br></p>

<h3><a id="user-content-167-two-sum-ii-input-array-is-sorted" class="anchor" href="https://github.com/wishyouhappy/Algorithm#167-two-sum-ii-input-array-is-sorted" aria-hidden="true"><span class="octicon octicon-link"></span></a>167 Two Sum II Input array is sorted</h3>

<blockquote>
<p>Given an array of integers that is already <strong>sorted in ascending order</strong>, find two numbers such that they add up to a specific target number.</p>

<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are <strong>not zero-based</strong>.
You may assume that each input would have exactly one solution.</p>
</blockquote>

<pre><code>Input: numbers={2, 7, 11, 15}, target=9
Output: index1=1, index2=2
</code></pre>

<p><br></p>

<p><strong>Idea</strong>: We can solve this problem use the second method in * <a href="https://github.com/wishyouhappy/Algorithm#1-two-sum">1 Two Sum</a>. Just use two pointers, one at the beginning, one at the ending. Compare num[l] + num[r] and target. If the former is larger, then r--, if the latter is larger, l++.</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span>[] twoSum(<span class="pl-k">int</span>[] numbers, <span class="pl-k">int</span> target){
        <span class="pl-k">int</span>[] res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[<span class="pl-c1">2</span>];
        <span class="pl-k">if</span>(numbers <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> numbers<span class="pl-k">.</span>length <span class="pl-k">&lt;=</span> <span class="pl-c1">1</span>) <span class="pl-k">return</span> res;
        <span class="pl-k">int</span> l <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> r <span class="pl-k">=</span> numbers<span class="pl-k">.</span>length <span class="pl-k">-</span><span class="pl-c1">1</span>;
        <span class="pl-k">while</span>(l <span class="pl-k">&lt;</span> r){
            <span class="pl-k">if</span>(numbers[l] <span class="pl-k">+</span> numbers[r] <span class="pl-k">==</span> target){
                res[<span class="pl-c1">0</span>] <span class="pl-k">=</span> l<span class="pl-k">+</span><span class="pl-c1">1</span>;
                res[<span class="pl-c1">1</span>] <span class="pl-k">=</span> r<span class="pl-k">+</span><span class="pl-c1">1</span>;
                <span class="pl-k">return</span> res;
            }<span class="pl-k">else</span> <span class="pl-k">if</span>(numbers[l] <span class="pl-k">+</span> numbers[r] <span class="pl-k">&gt;</span> target) r<span class="pl-k">--</span>;
            <span class="pl-k">else</span> l<span class="pl-k">++</span>;
        }
        <span class="pl-k">return</span> res;
    }
</pre></div>

<p><br></p>

<p><br></p>

<h3><a id="user-content-170-two-sum-iii-data-structure-design" class="anchor" href="https://github.com/wishyouhappy/Algorithm#170-two-sum-iii-data-structure-design" aria-hidden="true"><span class="octicon octicon-link"></span></a>170 Two Sum III Data Structure Design</h3>

<blockquote>
<p>Design and implement a TwoSum class. It should support the following operations: add and find.</p>

<p>add - Add the number to an internal data structure.</p>

<p>find - Find if there exists any pair of numbers which sum is equal to the value.</p>
</blockquote>

<pre><code>For example,
add(1); add(3); add(5);
find(4) -&gt; true
find(7) -&gt; false
</code></pre>

<p><br></p>

<p><strong>Idea</strong>: How to design the structure is based on our needs. Remember in * <a href="https://github.com/wishyouhappy/Algorithm#1-two-sum">1 Two Sum</a> , the first method we use hashmap to record each number, and check if sum - number exist. If we do this the same way in this problem, we can use hashmap to record each number when add, and find the number use the method in * <a href="https://github.com/wishyouhappy/Algorithm#1-two-sum">1 Two Sum</a>. </p>

<p><strong>Time complexity</strong> : add O(1) find O(n)</p>

<p><strong>Space</strong>: O(n)</p>

<p><strong><em>What if we want to find sum in O(1)?</em></strong></p>

<p>We need to record the all possible sum when add new numbers. Then the time complexity would change to O(n). Also, we need a set to record the possible sum. So we need to increase the space. </p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">TwoSum</span>{
        <span class="pl-k">private</span> <span class="pl-k">Map&lt;<span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>&gt;</span> map <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashMap&lt;<span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>&gt;</span>();
        <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">add</span>(<span class="pl-k">int</span> <span class="pl-v">number</span>){
            <span class="pl-k">if</span>(map<span class="pl-k">.</span>containsKey(number)) map<span class="pl-k">.</span>put(number, map<span class="pl-k">.</span>get(number)<span class="pl-k">+</span><span class="pl-c1">1</span>);
            <span class="pl-k">else</span> map<span class="pl-k">.</span>put(number, <span class="pl-c1">1</span>);
        }

        <span class="pl-k">public</span> <span class="pl-k">boolean</span> <span class="pl-en">find</span>(<span class="pl-k">int</span> <span class="pl-v">value</span>){
            <span class="pl-k">for</span>(<span class="pl-smi">Integer</span> i <span class="pl-k">:</span> map<span class="pl-k">.</span>keySet()){
                <span class="pl-k">int</span> remain <span class="pl-k">=</span> value <span class="pl-k">-</span>i;
                <span class="pl-k">if</span>(map<span class="pl-k">.</span>containsKey(remain)){
                    <span class="pl-k">if</span>(remain <span class="pl-k">==</span> i <span class="pl-k">&amp;&amp;</span> map<span class="pl-k">.</span>get(remain) <span class="pl-k">&lt;</span> <span class="pl-c1">2</span>) <span class="pl-k">continue</span>;
                    <span class="pl-k">else</span> <span class="pl-k">return</span> <span class="pl-c1">true</span>;
                }
            }
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
    }
</pre></div>

<p><br></p>

<p><br></p>

<h3><a id="user-content-171-excel-sheet-column-number" class="anchor" href="https://github.com/wishyouhappy/Algorithm#171-excel-sheet-column-number" aria-hidden="true"><span class="octicon octicon-link"></span></a>171 Excel Sheet Column Number</h3>

<blockquote>
<p>Given a column title as appear in an Excel sheet, return its corresponding column number.</p>

<p>For example:</p>

<pre><code>  A -&gt; 1
  B -&gt; 2
  C -&gt; 3
  ...
  Z -&gt; 26
  AA -&gt; 27
  AB -&gt; 28 
</code></pre>
</blockquote>

<p><strong>Analysis:</strong> </p>

<p>for example: CABD</p>

<p><code>C * 26 ^ 3 + A * 26 ^ 2 + B * 26 ^ 1 + D * 26 ^ 0</code></p>

<p>which is</p>

<p><code>3 * 26 ^ 3 + 1 * 26 ^ 2 + 2 * 26 ^ 1 + 4</code></p>

<p>The following code takes O(N) time and O(1) space.</p>

<div class="highlight highlight-C"><pre><span class="pl-k">int</span> <span class="pl-en">titleToNumber</span>(<span class="pl-k">char</span> *s) {
    <span class="pl-k">int</span> i = <span class="pl-c1">0</span>, val = <span class="pl-c1">0</span>, x = <span class="pl-c1">1</span>;

    <span class="pl-k">if</span> (s[<span class="pl-c1">0</span>] == <span class="pl-c1">0</span>) { <span class="pl-k">return</span> <span class="pl-c1">0</span>; } <span class="pl-c">// if empty string</span>
    <span class="pl-k">for</span> (; s[i+<span class="pl-c1">1</span>] != <span class="pl-c1">0</span>; i ++); <span class="pl-c">// find the end of string</span>

    <span class="pl-k">for</span> (; i &gt;= <span class="pl-c1">0</span>; i --) {
        val += x * (s[i] - <span class="pl-s"><span class="pl-pds">'</span>A<span class="pl-pds">'</span></span> + <span class="pl-c1">1</span>);
        x *= <span class="pl-c1">26</span>; <span class="pl-c">// if we use something like pow(26, length - i) it </span>
                 <span class="pl-c">// will cause extra calculation and takes more time.</span>
    }

    <span class="pl-k">return</span> val;
}</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-173-binary-search-tree-iterator" class="anchor" href="https://github.com/wishyouhappy/Algorithm#173-binary-search-tree-iterator" aria-hidden="true"><span class="octicon octicon-link"></span></a>173 Binary Search Tree Iterator</h3>

<blockquote>
<p>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.</p>

<p>Calling next() will return the next smallest number in the BST.</p>

<p>Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.</p>
</blockquote>

<p><strong>Idea</strong>:</p>

<ul>
<li>1) Here we maintain a stack, from top to bottom is the smallest to largest. Because we use the stack data structure, thus we visit the tree in the following order: right -&gt; root -&gt; left. In this way, the top element in the stack would be the smallest element. </li>
</ul>

<p>However, the space would be O(n). So how could we solve it in O(h) space? </p>

<ul>
<li>2) O(h) is the height of the tree, thus we can store an path of root to leaf element in stack. Because we need to return the next smallest element each time, thus we need to traverse the tree inorder. And each time we return the next successor</li>
</ul>

<p>In this method, we fist store the left path of the tree in stack. When right child is not empty, we need to store the left path of its right child in stack until stack is empty. </p>

<p><strong>Solution 1</strong>: O(n) space, unqualified</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">BinarySearchTreeIterator</span> {
    <span class="pl-k">Stack&lt;<span class="pl-smi">Integer</span>&gt;</span> stack; 
    <span class="pl-k">public</span> <span class="pl-en">BSTIterator</span>(<span class="pl-smi">TreeNode</span> <span class="pl-v">root</span>) {
        stack <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">Stack&lt;<span class="pl-smi">Integer</span>&gt;</span>();
        inorderReverse(stack, root);
    }

    <span class="pl-c">/** @return whether we have a next smallest number */</span>
    <span class="pl-k">public</span> <span class="pl-k">boolean</span> <span class="pl-en">hasNext</span>() {
        <span class="pl-k">return</span> <span class="pl-k">!</span>stack<span class="pl-k">.</span>isEmpty();
    }

    <span class="pl-c">/** @return the next smallest number */</span>
    <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">next</span>() {
        <span class="pl-k">if</span> (hasNext()) {
            <span class="pl-k">return</span> stack<span class="pl-k">.</span>pop();
        }
        <span class="pl-k">return</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
    }

    <span class="pl-k">private</span> <span class="pl-k">void</span> <span class="pl-en">inorderReverse</span>(<span class="pl-k">Stack&lt;<span class="pl-smi">Integer</span>&gt;</span> <span class="pl-v">stack</span>, <span class="pl-smi">TreeNode</span> <span class="pl-v">root</span>) {
        <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
            <span class="pl-k">return</span>;
        }
        inorderReverse(stack, root<span class="pl-k">.</span>right);
        stack<span class="pl-k">.</span>push(root<span class="pl-k">.</span>val);
        inorderReverse(stack, root<span class="pl-k">.</span>left);
    }
}</pre></div>

<p><br></p>

<p><strong>Solution 2</strong>:</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">BSTIterator</span> {
    <span class="pl-k">Stack&lt;<span class="pl-smi">TreeNode</span>&gt;</span> stack; 
    <span class="pl-k">public</span> <span class="pl-en">BSTIterator</span>(<span class="pl-smi">TreeNode</span> <span class="pl-v">root</span>) {
        stack <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">Stack&lt;<span class="pl-smi">TreeNode</span>&gt;</span>();
        <span class="pl-k">while</span>(root <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
            stack<span class="pl-k">.</span>push(root);
            root <span class="pl-k">=</span> root<span class="pl-k">.</span>left;
        }
    }

    <span class="pl-c">/** @return whether we have a next smallest number */</span>
    <span class="pl-k">public</span> <span class="pl-k">boolean</span> <span class="pl-en">hasNext</span>() {
        <span class="pl-k">return</span> <span class="pl-k">!</span>stack<span class="pl-k">.</span>isEmpty();
    }

    <span class="pl-c">/** @return the next smallest number */</span>
    <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">next</span>() {
        <span class="pl-k">if</span> (stack<span class="pl-k">.</span>isEmpty()) {
            <span class="pl-k">return</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
        }
        <span class="pl-smi">TreeNode</span> cur <span class="pl-k">=</span> stack<span class="pl-k">.</span>pop();
        <span class="pl-k">int</span> res <span class="pl-k">=</span> cur<span class="pl-k">.</span>val;
        <span class="pl-k">if</span> (cur<span class="pl-k">.</span>right <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
            cur <span class="pl-k">=</span> cur<span class="pl-k">.</span>right;
            <span class="pl-k">while</span>(cur <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
                stack<span class="pl-k">.</span>push(cur);
                cur <span class="pl-k">=</span> cur<span class="pl-k">.</span>left;
            }
        }
        <span class="pl-k">return</span> res;
    }
}
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-188-best-time-to-buy-and-sell-stock-iv" class="anchor" href="https://github.com/wishyouhappy/Algorithm#188-best-time-to-buy-and-sell-stock-iv" aria-hidden="true"><span class="octicon octicon-link"></span></a>188 Best Time to Buy and Sell Stock IV</h3>

<blockquote>
<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>

<p>Design an algorithm to find the maximum profit. You may complete <strong>at most k transactions</strong>.</p>

<p>Note:</p>

<p>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
</blockquote>

<p><strong>First try:</strong> Use the idea in <a href="https://github.com/wishyouhappy/Algorithm#123-best-time-to-buy-and-sell-stock-iii">Best time to buy and sale stock iii</a>.
global[i][j]: denotes max profit, at most j transactions before day i:</p>

<p><strong>global[i][j]=max(local[i][j],global[i-1][j])</strong></p>

<p>local[i][j]: denotes max profit, at most j transactions before day i, and last transaction is saled on day i: </p>

<p><strong>local[i][j]=max(global[i-1][j-1]+max(diff,0),local[i-1][j]+diff)</strong></p>

<p><strong>Time complexity</strong>: O(k * n)</p>

<p><strong>Space</strong> : O(k)</p>

<p>Looks good, right? But we'll get out of memory error. Because in one test case, k = 100000. </p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> maxProfit(<span class="pl-k">int</span> k, <span class="pl-k">int</span>[] prices){
        <span class="pl-k">if</span>(prices <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> prices<span class="pl-k">.</span>length <span class="pl-k">&lt;=</span> <span class="pl-c1">1</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span>[] global <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[k<span class="pl-k">+</span><span class="pl-c1">1</span>];
        <span class="pl-k">int</span>[] local <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[k<span class="pl-k">+</span><span class="pl-c1">1</span>];
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;</span> prices<span class="pl-k">.</span>length; i<span class="pl-k">++</span>){
            <span class="pl-k">int</span> dif <span class="pl-k">=</span> prices[i] <span class="pl-k">-</span> prices[i<span class="pl-k">-</span><span class="pl-c1">1</span>];
            <span class="pl-k">for</span>(<span class="pl-k">int</span> j <span class="pl-k">=</span> k; j <span class="pl-k">&gt;=</span> <span class="pl-c1">1</span>; j<span class="pl-k">--</span>){
                local[j] <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(global[j<span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">+</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(dif, <span class="pl-c1">0</span>), local[j] <span class="pl-k">+</span> dif);
                global[j] <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(local[j], global[j]);
            }
        }
        <span class="pl-k">return</span> global[k];
    }</pre></div>

<p><strong>Solution:</strong></p>

<p><br>
<br></p>

<h3><a id="user-content-189-rotate-array" class="anchor" href="https://github.com/wishyouhappy/Algorithm#189-rotate-array" aria-hidden="true"><span class="octicon octicon-link"></span></a>189 Rotate Array</h3>

<blockquote>
<p>Rotate an array of n elements to the right by k steps.</p>
</blockquote>

<p>For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].</p>

<p>Note:
Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</p>

<p><strong>Idea</strong></p>

<ul>
<li>1)Solution1:  In place. Reverse the array three times. (0, n-1) (0, k-1), (k-n-1)</li>
<li>2)Solution2:  Use an extra array, and copy to the right place.</li>
</ul>

<p><br>
<strong>Solution1</strong>:</p>

<div class="highlight highlight-java"><pre>   <span class="pl-k">public</span> <span class="pl-k">void</span> rotate(<span class="pl-k">int</span>[] nums, <span class="pl-k">int</span> k) {
       <span class="pl-k">if</span>(nums <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> nums<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> k <span class="pl-k">&lt;=</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span>;
       k <span class="pl-k">=</span> k <span class="pl-k">%</span> nums<span class="pl-k">.</span>length;
       reverse(nums, <span class="pl-c1">0</span>, nums<span class="pl-k">.</span>length<span class="pl-k">-</span><span class="pl-c1">1</span>);
       reverse(nums, <span class="pl-c1">0</span>, k<span class="pl-k">-</span><span class="pl-c1">1</span>);
       reverse(nums, k, nums<span class="pl-k">.</span>length<span class="pl-k">-</span><span class="pl-c1">1</span>);
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> reverse(<span class="pl-k">int</span>[] nums, <span class="pl-k">int</span> left, <span class="pl-k">int</span> right){
        <span class="pl-k">while</span>(left <span class="pl-k">&lt;</span> right){
            <span class="pl-k">int</span> temp <span class="pl-k">=</span> nums[left];
            nums[left] <span class="pl-k">=</span> nums[right];
            nums[right] <span class="pl-k">=</span> temp;
            left<span class="pl-k">++</span>;
            right<span class="pl-k">--</span>;
        }
    }</pre></div>

<p><strong>Solution 2</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">void</span> rotate1(<span class="pl-k">int</span>[] nums, <span class="pl-k">int</span> k) {
        <span class="pl-k">if</span>(nums <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> nums<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> k <span class="pl-k">&lt;=</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span>;
        <span class="pl-k">int</span>[] result <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[nums<span class="pl-k">.</span>length];
        k <span class="pl-k">=</span> k <span class="pl-k">%</span> nums<span class="pl-k">.</span>length;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> k; i<span class="pl-k">++</span>){
            result[i] <span class="pl-k">=</span> nums[nums<span class="pl-k">.</span>length <span class="pl-k">-</span>k <span class="pl-k">+</span> i];
        }
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> k; i <span class="pl-k">&lt;</span> nums<span class="pl-k">.</span>length; i<span class="pl-k">++</span>){
            result[i] <span class="pl-k">=</span> nums[i<span class="pl-k">-</span>k];
        }
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> nums<span class="pl-k">.</span>length; i<span class="pl-k">++</span>){
            nums[i] <span class="pl-k">=</span> result[i];
        }
    }</pre></div>

<h3><a id="user-content-190-reverse-bits" class="anchor" href="https://github.com/wishyouhappy/Algorithm#190-reverse-bits" aria-hidden="true"><span class="octicon octicon-link"></span></a>190 Reverse Bits</h3>

<blockquote>
<p>Reverse bits of a given 32 bits unsigned integer.</p>

<p>For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as 00111001011110000010100101000000).</p>

<p>Follow up:</p>

<p>If this function is called many times, how would you optimize it?</p>

<p>Related problem: Reverse Integer</p>
</blockquote>

<p><strong>Idea</strong>: Like reverse a string, we swap each bit i with 32 -i -1 for 1/2 of the total bit length. </p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> reverseBits(<span class="pl-k">int</span> n) {
        <span class="pl-k">if</span>(n <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-c1">16</span>; i<span class="pl-k">++</span>){
            n <span class="pl-k">=</span> swap(n, i, <span class="pl-c1">32</span><span class="pl-k">-</span>i<span class="pl-k">-</span><span class="pl-c1">1</span>);
        }
        <span class="pl-k">return</span> n;
    }

    <span class="pl-k">public</span> <span class="pl-k">int</span> swap(<span class="pl-k">int</span> n,<span class="pl-k">int</span> i, <span class="pl-k">int</span> j){
        <span class="pl-k">int</span> bitI <span class="pl-k">=</span> (n <span class="pl-k">&gt;&gt;</span> i) <span class="pl-k">&amp;</span> <span class="pl-c1">1</span>;
        <span class="pl-k">int</span> bitJ <span class="pl-k">=</span> (n <span class="pl-k">&gt;&gt;</span> j) <span class="pl-k">&amp;</span> <span class="pl-c1">1</span>;
        <span class="pl-k">if</span>((bitI <span class="pl-k">^</span> bitJ) <span class="pl-k">!=</span> <span class="pl-c1">0</span>){
            n <span class="pl-k">=</span> n <span class="pl-k">^</span> ((<span class="pl-c1">1</span> <span class="pl-k">&lt;&lt;</span> i) <span class="pl-k">|</span> (<span class="pl-c1">1</span> <span class="pl-k">&lt;&lt;</span> j));
        }
        <span class="pl-k">return</span> n;
    }
</pre></div>

<p><strong>Another solution in c++</strong>: If the binary of number  a is  10001111 we can represent it as 2 ^ 7 + 2 ^ 3 + 2 ^2 + 2 ^ 1 + 2 ^ 0. Thus we use mod 2 and * 2 to reserve this number. Because in java int is not unsigned, so use this method in java have sign problem.</p>

<div class="highlight highlight-c++"><pre>    <span class="pl-c1">uint32_t</span> <span class="pl-en">reverseBits</span>(<span class="pl-c1">uint32_t</span> n) {
        <span class="pl-k">if</span>(n == <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> res = <span class="pl-c1">0</span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i = <span class="pl-c1">0</span>; i &lt; <span class="pl-c1">32</span>; i++){
            <span class="pl-k">int</span> mod = n % <span class="pl-c1">2</span>;
            n = n &gt;&gt; <span class="pl-c1">1</span>;
            res = (res &lt;&lt; <span class="pl-c1">1</span>) + mod;
        }
        <span class="pl-k">return</span> res;
    }

</pre></div>

<p><br></p>

<p><br></p>

<h3><a id="user-content-191-number-of-1-bits" class="anchor" href="https://github.com/wishyouhappy/Algorithm#191-number-of-1-bits" aria-hidden="true"><span class="octicon octicon-link"></span></a>191 Number of 1 Bits</h3>

<blockquote>
<p>Write a function that takes an unsigned integer and returns the number of ’1' bits it has (also known as the Hamming weight).</p>

<p>For example, the 32-bit integer ’11' has binary representation 00000000000000000000000000001011, so the function should return 3.</p>
</blockquote>

<p><strong>Idea</strong>: There are three ways to deal with this problem.</p>

<ul>
<li>1) n &amp; 1, if result is 1, count ++, n &gt;&gt;&gt;= 1, till n = 0; ** Remember use &gt;&gt;&gt;**</li>
<li>2) use n = n &amp; n-1 to remove the rightmost 1. <strong>Time complexity is O(number od 1s)</strong></li>
<li>3) use left shift. </li>
</ul>

<p><strong>Solution1 : Java code</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> hammingWeight(<span class="pl-k">int</span> n) {
        <span class="pl-k">if</span>(n <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> res <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">while</span>(n <span class="pl-k">!=</span> <span class="pl-c1">0</span>){
            <span class="pl-k">if</span>((n <span class="pl-k">&amp;</span> <span class="pl-c1">1</span>) <span class="pl-k">!=</span> <span class="pl-c1">0</span>) res<span class="pl-k">++</span>;
            n <span class="pl-k">=</span> n <span class="pl-k">&gt;&gt;&gt;</span> <span class="pl-c1">1</span>;
        }
        <span class="pl-k">return</span> res;
    }
</pre></div>

<p><strong>Solution 2: c++ code</strong>:</p>

<div class="highlight highlight-c++"><pre>    <span class="pl-k">int</span> <span class="pl-en">hammingWeight</span>(<span class="pl-c1">uint32_t</span> n) {
          <span class="pl-k">int</span> res = <span class="pl-c1">0</span>;
          <span class="pl-k">while</span>(n &gt; <span class="pl-c1">0</span>){
              n &amp;= n-<span class="pl-c1">1</span>;
              res++;
          }
          <span class="pl-k">return</span> res;
    }
</pre></div>

<p><strong>Solution 3: c++ code</strong>:</p>

<div class="highlight highlight-c++"><pre>    <span class="pl-k">int</span> <span class="pl-en">hammingWeight</span>(<span class="pl-c1">uint32_t</span> n) {
      <span class="pl-k">int</span> res = <span class="pl-c1">0</span>;
      <span class="pl-k">unsigned</span> <span class="pl-k">int</span> flag = <span class="pl-c1">1</span>;
      <span class="pl-k">while</span>(flag){
         <span class="pl-k">if</span>(n&amp;flag){
            res++;
        }
        flag = flag &lt;&lt; <span class="pl-c1">1</span>;
      }
      <span class="pl-k">return</span> res;
    }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-198-house-robber" class="anchor" href="https://github.com/wishyouhappy/Algorithm#198-house-robber" aria-hidden="true"><span class="octicon octicon-link"></span></a>198 House Robber</h3>

<blockquote>
<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p>

<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>
</blockquote>

<p><strong>Idea</strong>: It's an one dimensional dp problem, like the **Best time to buy and sell stocks. We need to find the maximum nonadjacent sum. Thus, for each room our choice is either rob or not rob, based on the previous room, and we need to mantain the max money on the current. If we want to rob this room, the condition is that we don't rob the previous room. Thus robYes = robNo + room[i]. And if we don't rob this room, then we can choose the max from previous robYes and robNo. See details on the following code.</p>

<p>*<em>Solution 1 *</em>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> rob(<span class="pl-k">int</span>[] num) {
        <span class="pl-k">if</span>(num <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> num<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> robYes <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> robNo <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> money <span class="pl-k">:</span> num){
            <span class="pl-k">int</span> temp <span class="pl-k">=</span> robNo;
            robNo <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(robYes, robNo);
            robYes <span class="pl-k">=</span> temp <span class="pl-k">+</span> money;
        }
        <span class="pl-k">return</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(robYes, robNo);
    }

</pre></div>

<p><strong>Solution 2</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> rob(<span class="pl-k">int</span>[] num) {
        <span class="pl-k">if</span>(num <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> num<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> even <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> odd <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> num<span class="pl-k">.</span>length; i<span class="pl-k">++</span>){
            <span class="pl-k">if</span>(i <span class="pl-k">%</span> <span class="pl-c1">2</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>){
                even <span class="pl-k">+=</span> num[i];
                even <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(even, odd);
            }<span class="pl-k">else</span>{
                odd <span class="pl-k">+=</span> num[i];
                odd <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(even, odd);
            }
        }
        <span class="pl-k">return</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(odd, even);
    }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-199-binary-tree-right-side-view" class="anchor" href="https://github.com/wishyouhappy/Algorithm#199-binary-tree-right-side-view" aria-hidden="true"><span class="octicon octicon-link"></span></a>199 Binary Tree Right Side View</h3>

<blockquote>
<p>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p>
</blockquote>

<pre>For example:
Given the following binary tree,
   1         
 /   \
2     3         
 \     \
  5     4      
You should return [1, 3, 4].

</pre>

<p><strong>Idea</strong>: This problem is similar to the <strong>breadth first search</strong> of a binary search tree. If you can figure out this, the problem is easy. We use a queue, more precisely a deque to store element of each level. Then each time we store the rightmost element in each level to the result list. </p>

<p><strong>Java code</strong>:</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> rightSideView(<span class="pl-smi">TreeNode</span> root) {
    <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
        <span class="pl-k">return</span> res;
    }
    <span class="pl-k">Deque&lt;<span class="pl-smi">TreeNode</span>&gt;</span> deque <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">LinkedList&lt;<span class="pl-smi">TreeNode</span>&gt;</span>();
    deque<span class="pl-k">.</span>offer(root);
    <span class="pl-k">while</span> (<span class="pl-k">!</span>deque<span class="pl-k">.</span>isEmpty()) {
        <span class="pl-smi">TreeNode</span> cur <span class="pl-k">=</span> <span class="pl-c1">null</span>;
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>, size <span class="pl-k">=</span> deque<span class="pl-k">.</span>size(); i <span class="pl-k">&lt;</span> size; i<span class="pl-k">++</span>) {
            cur <span class="pl-k">=</span> deque<span class="pl-k">.</span>pollLast();
            <span class="pl-k">if</span> (cur<span class="pl-k">.</span>right <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
                deque<span class="pl-k">.</span>addFirst(cur<span class="pl-k">.</span>right);
            }
            <span class="pl-k">if</span> (cur<span class="pl-k">.</span>left <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
                deque<span class="pl-k">.</span>addFirst(cur<span class="pl-k">.</span>left);
            }
            <span class="pl-k">if</span>(i <span class="pl-k">==</span> <span class="pl-c1">0</span>){
                res<span class="pl-k">.</span>add(cur<span class="pl-k">.</span>val);
            } 
        }
    }
    <span class="pl-k">return</span> res;
}
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-200-number-of-islands" class="anchor" href="https://github.com/wishyouhappy/Algorithm#200-number-of-islands" aria-hidden="true"><span class="octicon octicon-link"></span></a>200 Number of Islands</h3>

<blockquote>
<p>Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
</blockquote>

<pre>Example 1:

11110
11010
11000
00000
Answer: 1

Example 2:

11000
11000
00100
00011
Answer: 3


</pre>

<p><strong>Idea</strong>: Basically, the idea is similar to flood fill or bfs/dfs of graph. Each time we visited a land, we marked it as visited, then go north/west/south/east. When dfs ends, that means we have visited every land of a certain island. In the same way, we can count the number of all islands.</p>

<p><strong>Java code</strong>:</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">int</span> numIslands(<span class="pl-k">char</span>[][] grid) {
        <span class="pl-k">if</span>(grid <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> grid<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> grid[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        <span class="pl-k">boolean</span>[][] visited <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">boolean</span>[grid<span class="pl-k">.</span>length][grid[<span class="pl-c1">0</span>].length];
        <span class="pl-k">int</span> res <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> grid<span class="pl-k">.</span>length; i<span class="pl-k">++</span>){
            <span class="pl-k">for</span>(<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;</span> grid[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length; j<span class="pl-k">++</span>){
                <span class="pl-k">if</span>(grid[i][j] <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>1<span class="pl-pds">'</span></span> <span class="pl-k">&amp;&amp;</span> visited[i][j] <span class="pl-k">==</span> <span class="pl-c1">false</span>){
                    dfs(visited, grid, i, j);
                    res<span class="pl-k">++</span>;
                }
            }
        }
        <span class="pl-k">return</span> res;
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> dfs(<span class="pl-k">boolean</span>[][] visited, <span class="pl-k">char</span>[][] grid, <span class="pl-k">int</span> i, <span class="pl-k">int</span> j){
        <span class="pl-k">if</span>(i <span class="pl-k">&lt;</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> i <span class="pl-k">&gt;=</span> grid<span class="pl-k">.</span>length <span class="pl-k">||</span> j <span class="pl-k">&lt;</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> j <span class="pl-k">&gt;=</span> grid[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length)
            <span class="pl-k">return</span>;
        <span class="pl-k">if</span>(visited[i][j] <span class="pl-k">==</span> <span class="pl-c1">true</span> <span class="pl-k">||</span> grid[i][j] <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>0<span class="pl-pds">'</span></span>)
            <span class="pl-k">return</span>;
        visited[i][j] <span class="pl-k">=</span> <span class="pl-c1">true</span>;
        dfs(visited, grid, i<span class="pl-k">-</span><span class="pl-c1">1</span>, j);
        dfs(visited, grid, i, j<span class="pl-k">-</span><span class="pl-c1">1</span>);
        dfs(visited, grid, i<span class="pl-k">+</span><span class="pl-c1">1</span>, j);
        dfs(visited, grid, i, j<span class="pl-k">+</span><span class="pl-c1">1</span>);
    }
</pre></div>

<p><br></p>

<p><strong>Related</strong>: Longest 1s</p>

<blockquote>
<p>Given an array containing only 0s and 1s, find the length of the longest subarray of consecutive 1s.</p>
</blockquote>

<p><strong>Idea</strong>: One-d dp. </p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">int</span> longest(<span class="pl-k">int</span>[] array) {
    <span class="pl-k">int</span>[] arr <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[array<span class="pl-k">.</span>length <span class="pl-k">+</span> <span class="pl-c1">1</span>];
    <span class="pl-k">int</span> res <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;=</span> array<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
      <span class="pl-k">if</span> (array[i <span class="pl-k">-</span> <span class="pl-c1">1</span>] <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
        arr[i] <span class="pl-k">=</span> <span class="pl-c1">0</span>;
      } <span class="pl-k">else</span> {
        arr[i] <span class="pl-k">=</span> arr[i <span class="pl-k">-</span> <span class="pl-c1">1</span>] <span class="pl-k">+</span> <span class="pl-c1">1</span>;
        res <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(res, arr[i]);
      }
    }
    <span class="pl-k">return</span> res;
  }
</pre></div>

<p><br></p>

<p><strong>Related</strong>: Longest cross of 1s</p>

<blockquote>
<p>Given a 2d grid map of '1's and 0s, find the largest cross which contains only 1s, with the same arm lengths and the four arms joining at the central point.</p>
</blockquote>

<p><strong>Idea</strong>: For each row and columns, calcualte the longest 1s, then we take the minimum of left/right/up/down.</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">int</span> largest(<span class="pl-k">int</span>[][] matrix) {
    <span class="pl-k">int</span> m <span class="pl-k">=</span> matrix<span class="pl-k">.</span>length;
    <span class="pl-k">int</span> n <span class="pl-k">=</span> m <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">?</span> matrix[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length <span class="pl-k">:</span> <span class="pl-c1">0</span>;
    <span class="pl-c">//calculate left</span>
    <span class="pl-k">int</span>[][] left <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[m][n <span class="pl-k">+</span> <span class="pl-c1">1</span>];
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> m; i<span class="pl-k">++</span>) {
      <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">1</span>; j <span class="pl-k">&lt;=</span> n; j<span class="pl-k">++</span>) {
        <span class="pl-k">if</span> (matrix[i][j <span class="pl-k">-</span> <span class="pl-c1">1</span>] <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
          left[i][j] <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        } <span class="pl-k">else</span> {
          left[i][j] <span class="pl-k">=</span> left[i][j <span class="pl-k">-</span> <span class="pl-c1">1</span>] <span class="pl-k">+</span> <span class="pl-c1">1</span>;
        }
      }
    }
    <span class="pl-c">//calculate right</span>
    <span class="pl-k">int</span>[][] right <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[m][n <span class="pl-k">+</span> <span class="pl-c1">1</span>];
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> m; i<span class="pl-k">++</span>) {
      <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> n <span class="pl-k">-</span> <span class="pl-c1">1</span>; j <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>; j<span class="pl-k">--</span>) {
        <span class="pl-k">if</span> (matrix[i][j] <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
          right[i][j] <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        } <span class="pl-k">else</span> {
          right[i][j] <span class="pl-k">=</span> right[i][j <span class="pl-k">+</span> <span class="pl-c1">1</span>] <span class="pl-k">+</span> <span class="pl-c1">1</span>;
        }
      }
    }

    <span class="pl-c">//calculate up</span>
    <span class="pl-k">int</span>[][] up <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[m <span class="pl-k">+</span> <span class="pl-c1">1</span>][n];
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> n; i<span class="pl-k">++</span>) {
      <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">1</span>; j <span class="pl-k">&lt;=</span> m; j<span class="pl-k">++</span>) {
        <span class="pl-k">if</span> (matrix[j <span class="pl-k">-</span> <span class="pl-c1">1</span>][i] <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
          up[j][i] <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        } <span class="pl-k">else</span> {
          up[j][i] <span class="pl-k">=</span> up[j <span class="pl-k">-</span> <span class="pl-c1">1</span>][i] <span class="pl-k">+</span> <span class="pl-c1">1</span>;
        }
      }
    }

    <span class="pl-c">//calculate down</span>
    <span class="pl-k">int</span>[][] down <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[m <span class="pl-k">+</span> <span class="pl-c1">1</span>][n];
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> n; i<span class="pl-k">++</span>) {
      <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> m <span class="pl-k">-</span> <span class="pl-c1">1</span>; j <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>; j<span class="pl-k">--</span>) {
        <span class="pl-k">if</span> (matrix[j][i] <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
          down[j][i] <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        } <span class="pl-k">else</span> {
          down[j][i] <span class="pl-k">=</span> down[j <span class="pl-k">+</span> <span class="pl-c1">1</span>][i] <span class="pl-k">+</span> <span class="pl-c1">1</span>;
        }
      }
    }

    <span class="pl-k">int</span> res <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> m; i<span class="pl-k">++</span>) {
      <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;</span> n; j<span class="pl-k">++</span>) {
        <span class="pl-k">int</span> minRow <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>min(left[i][j <span class="pl-k">+</span> <span class="pl-c1">1</span>], right[i][j]);
        <span class="pl-k">int</span> minCol <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>min(up[i <span class="pl-k">+</span> <span class="pl-c1">1</span>][j], down[i][j]);
        res <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(res, <span class="pl-smi">Math</span><span class="pl-k">.</span>min(minRow, minCol));
      }
    }
    <span class="pl-k">return</span> res;
  }
</pre></div>

<p><br></p>

<p><strong>Related</strong>: Largest X Of 1s</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">int</span> largest(<span class="pl-k">int</span>[][] matrix) {
    <span class="pl-k">int</span> m <span class="pl-k">=</span> matrix<span class="pl-k">.</span>length;
    <span class="pl-k">int</span> n <span class="pl-k">=</span> m <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">?</span> matrix[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length <span class="pl-k">:</span> <span class="pl-c1">0</span>;
    <span class="pl-c">//calculate left</span>
    <span class="pl-k">int</span>[][] left <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[m][n];
    <span class="pl-k">int</span>[][] up <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[m][n];
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> m; i<span class="pl-k">++</span>) {
      <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;</span> n; j<span class="pl-k">++</span>) {
        <span class="pl-k">if</span> (matrix[i][j] <span class="pl-k">==</span> <span class="pl-c1">1</span>) {
          left[i][j] <span class="pl-k">=</span> getNum(left, i <span class="pl-k">-</span> <span class="pl-c1">1</span>, j <span class="pl-k">-</span> <span class="pl-c1">1</span>, m, n) <span class="pl-k">+</span> <span class="pl-c1">1</span>;
          up[i][j] <span class="pl-k">=</span> getNum(up, i <span class="pl-k">-</span> <span class="pl-c1">1</span>, j <span class="pl-k">+</span> <span class="pl-c1">1</span>, m, n) <span class="pl-k">+</span> <span class="pl-c1">1</span>;
        }
      }
    }
    <span class="pl-c">//calculate down</span>
    <span class="pl-k">int</span>[][] right <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[m][n];
    <span class="pl-k">int</span>[][] down <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[m][n];
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> m <span class="pl-k">-</span> <span class="pl-c1">1</span>; i <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>; i<span class="pl-k">--</span>) {
      <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> n <span class="pl-k">-</span> <span class="pl-c1">1</span>; j <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>; j<span class="pl-k">--</span>) {
        <span class="pl-k">if</span> (matrix[i][j] <span class="pl-k">==</span> <span class="pl-c1">1</span>) {
          right[i][j] <span class="pl-k">=</span> getNum(right, i <span class="pl-k">+</span> <span class="pl-c1">1</span>, j <span class="pl-k">+</span> <span class="pl-c1">1</span>, m, n) <span class="pl-k">+</span> <span class="pl-c1">1</span>;
          down[i][j] <span class="pl-k">=</span> getNum(down, i <span class="pl-k">+</span> <span class="pl-c1">1</span>, j <span class="pl-k">-</span> <span class="pl-c1">1</span>, m, n) <span class="pl-k">+</span> <span class="pl-c1">1</span>;
        }
      }
    }

    <span class="pl-k">int</span> res <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> m; i<span class="pl-k">++</span>) {
      <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;</span> n; j<span class="pl-k">++</span>) {
        <span class="pl-k">int</span> minRow <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>min(left[i][j], right[i][j]);
        <span class="pl-k">int</span> minCol <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>min(up[i][j], down[i][j]);
        res <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(res, <span class="pl-smi">Math</span><span class="pl-k">.</span>min(minRow, minCol));
      }
    }
    <span class="pl-k">return</span> res;
  }

  <span class="pl-k">private</span> <span class="pl-k">int</span> getNum(<span class="pl-k">int</span>[][] arr, <span class="pl-k">int</span> i, <span class="pl-k">int</span> j, <span class="pl-k">int</span> m, <span class="pl-k">int</span> n) {
    <span class="pl-k">return</span> i <span class="pl-k">&lt;</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> j <span class="pl-k">&lt;</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> i <span class="pl-k">&gt;=</span> m <span class="pl-k">||</span> j <span class="pl-k">&gt;=</span> n <span class="pl-k">?</span> <span class="pl-c1">0</span> <span class="pl-k">:</span> arr[i][j];
  }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-201-bitwise-and-of-numbers-range" class="anchor" href="https://github.com/wishyouhappy/Algorithm#201-bitwise-and-of-numbers-range" aria-hidden="true"><span class="octicon octicon-link"></span></a>201 Bitwise AND of Numbers Range</h3>

<blockquote>
<p>Given a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive.</p>

<p>For example, given the range [5, 7], you should return 4.</p>
</blockquote>

<p><strong>Idea</strong>: what we need to do is to  find the similar bits of of m and n on the left side. For eample, if n = 111, m = 101, then the similar part on the left side is 1, then the result is 100. Then we left shift 1 by 2 we can get the result.</p>

<p><strong>Java code</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> rangeBitwiseAnd(<span class="pl-k">int</span> m, <span class="pl-k">int</span> n) {
        <span class="pl-k">int</span> count <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">while</span>(m <span class="pl-k">!=</span> n){
            m <span class="pl-k">&gt;&gt;</span><span class="pl-k">=</span> <span class="pl-c1">1</span>;
            n <span class="pl-k">&gt;&gt;</span><span class="pl-k">=</span> <span class="pl-c1">1</span>;
            count<span class="pl-k">++</span>;
        }
        <span class="pl-k">return</span> m <span class="pl-k">&lt;&lt;</span> count;
    }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-202-happy-number" class="anchor" href="https://github.com/wishyouhappy/Algorithm#202-happy-number" aria-hidden="true"><span class="octicon octicon-link"></span></a>202 Happy Number</h3>

<blockquote>
<p>Write an algorithm to determine if a number is "happy".</p>

<p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p>
</blockquote>

<pre>Example: 19 is a happy number

1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1

</pre>

<p><strong>Idea</strong>:If it is not a happy number, then it will have a circle, that is, when we continue calculate, we will return to a certain value. So we need to save the history number. When we find that a number has existed before, then it is not a happy number. </p>

<p><strong>Java code</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">boolean</span> isHappy(<span class="pl-k">int</span> n) {
        <span class="pl-k">if</span>(n <span class="pl-k">&lt;=</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        <span class="pl-k">Set&lt;<span class="pl-smi">Integer</span>&gt;</span> set <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashSet&lt;<span class="pl-smi">Integer</span>&gt;</span>();
        set<span class="pl-k">.</span>add(n);
        <span class="pl-k">while</span>(n <span class="pl-k">!=</span> <span class="pl-c1">1</span>){
            <span class="pl-k">int</span> temp <span class="pl-k">=</span> <span class="pl-c1">0</span>;
            <span class="pl-k">while</span>(n <span class="pl-k">!=</span> <span class="pl-c1">0</span>){
                temp <span class="pl-k">+=</span> (n<span class="pl-k">%</span><span class="pl-c1">10</span>) <span class="pl-k">*</span> (n<span class="pl-k">%</span><span class="pl-c1">10</span>);
                n <span class="pl-k">=</span> n<span class="pl-k">/</span><span class="pl-c1">10</span>;
            }
            <span class="pl-k">if</span>(set<span class="pl-k">.</span>contains(temp)) <span class="pl-k">return</span> <span class="pl-c1">false</span>;
            set<span class="pl-k">.</span>add(temp);
            n <span class="pl-k">=</span> temp;
        }
        <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }
</pre></div>

<p>In python, we can use the string convertion for this problem:</p>

<div class="highlight highlight-python"><pre><span class="pl-k">class</span> <span class="pl-en">Solution</span>:
    <span class="pl-c"># @param {integer} n</span>
    <span class="pl-c"># @return {boolean}</span>
    <span class="pl-k">def</span> <span class="pl-en">isHappy</span>(<span class="pl-smi">self</span>, <span class="pl-smi">n</span>):
        m <span class="pl-k">=</span> n
        mem <span class="pl-k">=</span> <span class="pl-c1">set</span>()
        <span class="pl-k">while</span> m <span class="pl-k">not</span> <span class="pl-k">in</span> mem:
            mem.add(m)
            m <span class="pl-k">=</span> <span class="pl-c1">sum</span>([<span class="pl-c1">int</span>(x) <span class="pl-k">**</span> <span class="pl-c1">2</span> <span class="pl-k">for</span> x <span class="pl-k">in</span> <span class="pl-c1">str</span>(m)])
            <span class="pl-k">if</span> m <span class="pl-k">==</span> <span class="pl-c1">1</span>:
                <span class="pl-k">return</span> <span class="pl-c1">True</span>
        <span class="pl-k">return</span> <span class="pl-c1">False</span></pre></div>

<p><br>
<br></p>

<h3><a id="user-content-203-remove-linked-list-elements" class="anchor" href="https://github.com/wishyouhappy/Algorithm#203-remove-linked-list-elements" aria-hidden="true"><span class="octicon octicon-link"></span></a>203 Remove Linked List Elements</h3>

<blockquote>
<p>Remove all elements from a linked list of integers that have value val.</p>

<p>Example
Given: <code>1 --&gt; 2 --&gt; 6 --&gt; 3 --&gt; 4 --&gt; 5 --&gt; 6, val = 6</code>
Return: <code>1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5</code></p>
</blockquote>

<p>The <code>head</code> of this problem contains value. If it doesn't contains the value,
declaration of <code>p</code> and <code>q</code> to <code>p, q = head, head-&gt;next</code>.</p>

<p>Becareful if:</p>

<ul>
<li>The node is <code>head</code></li>
<li>The node is <code>tail</code>, which means <code>.next = None</code></li>
<li>How to move the pointers ahead.</li>
</ul>

<p><strong>Java code</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-smi">ListNode</span> removeElements(<span class="pl-smi">ListNode</span> head, <span class="pl-k">int</span> val) {
        <span class="pl-k">if</span>(head <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-k">return</span> head;
        <span class="pl-smi">ListNode</span> fakeHead <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">ListNode</span>(<span class="pl-k">-</span><span class="pl-c1">1</span>);
        fakeHead<span class="pl-k">.</span>next <span class="pl-k">=</span> head;
        <span class="pl-smi">ListNode</span> pre <span class="pl-k">=</span> fakeHead;
        <span class="pl-k">while</span>(head <span class="pl-k">!=</span> <span class="pl-c1">null</span>){
            <span class="pl-k">if</span>(head<span class="pl-k">.</span>val <span class="pl-k">==</span> val){
                pre<span class="pl-k">.</span>next <span class="pl-k">=</span> head<span class="pl-k">.</span>next;
                head <span class="pl-k">=</span> pre<span class="pl-k">.</span>next;
            }<span class="pl-k">else</span>{
                pre <span class="pl-k">=</span> head;
                head <span class="pl-k">=</span> head<span class="pl-k">.</span>next;
            }
        }
        <span class="pl-k">return</span> fakeHead<span class="pl-k">.</span>next;
    }
</pre></div>

<p><strong>python</strong>:</p>

<div class="highlight highlight-python"><pre><span class="pl-c"># Definition for singly-linked list.</span>
<span class="pl-c"># class ListNode:</span>
<span class="pl-c">#     def __init__(self, x):</span>
<span class="pl-c">#         self.val = x</span>
<span class="pl-c">#         self.next = None</span>

<span class="pl-k">class</span> <span class="pl-en">Solution</span>:
    <span class="pl-c"># @param {ListNode} head</span>
    <span class="pl-c"># @param {integer} val</span>
    <span class="pl-c"># @return {ListNode}</span>
    <span class="pl-k">def</span> <span class="pl-en">removeElements</span>(<span class="pl-smi">self</span>, <span class="pl-smi">head</span>, <span class="pl-smi">val</span>):
        <span class="pl-k">if</span> <span class="pl-k">not</span> head:
            <span class="pl-k">return</span> <span class="pl-c1">None</span>

        p, q <span class="pl-k">=</span> <span class="pl-c1">None</span>, head

        <span class="pl-k">while</span> q <span class="pl-k">is</span> <span class="pl-k">not</span> <span class="pl-c1">None</span>:
            <span class="pl-k">if</span> q.val <span class="pl-k">==</span> val:
                <span class="pl-k">if</span> p <span class="pl-k">is</span> <span class="pl-c1">None</span>:  <span class="pl-c"># q is head  </span>
                    head <span class="pl-k">=</span> q.next
                <span class="pl-k">else</span>:
                    p.next <span class="pl-k">=</span> q.next
                q <span class="pl-k">=</span> q.next
            <span class="pl-k">else</span>:
                p, q <span class="pl-k">=</span> q, q.next

        <span class="pl-k">return</span> head</pre></div>

<h3><a id="user-content-204-count-primes" class="anchor" href="https://github.com/wishyouhappy/Algorithm#204-count-primes" aria-hidden="true"><span class="octicon octicon-link"></span></a>204 Count Primes</h3>

<blockquote>
<p>Description:Count the number of prime numbers less than a non-negative number, n</p>
</blockquote>

<p><strong>Idea</strong>: The straight forward way is that we check each number, if it is prime, resut++.</p>

<p>So at first try code like this:</p>

<div class="highlight highlight-java"><pre> <span class="pl-k">public</span> <span class="pl-k">int</span> countPrimes1(<span class="pl-k">int</span> n) {
        <span class="pl-k">if</span>(n <span class="pl-k">&lt;=</span> <span class="pl-c1">2</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        }
        <span class="pl-k">boolean</span>[] prime <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">boolean</span>[n];
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">2</span>; i <span class="pl-k">&lt;=</span> n<span class="pl-k">/</span><span class="pl-c1">2</span>; i<span class="pl-k">++</span> ) {
            <span class="pl-c">// if i is prime</span>
            <span class="pl-k">if</span>(<span class="pl-k">!</span>prime[i]){
                <span class="pl-k">for</span>(<span class="pl-k">int</span> j <span class="pl-k">=</span> i<span class="pl-k">+</span>i; j <span class="pl-k">&lt;</span> n; j <span class="pl-k">+=</span> i) {
                    prime[j] <span class="pl-k">=</span> <span class="pl-c1">true</span>;
                }
            }
        }
        <span class="pl-k">int</span> res <span class="pl-k">=</span> <span class="pl-c1">1</span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">3</span>; i <span class="pl-k">&lt;</span> n; i<span class="pl-k">++</span>){
            <span class="pl-k">if</span>(<span class="pl-k">!</span>prime[i]){
                res<span class="pl-k">++</span>;
            }
        }
        <span class="pl-k">return</span> res;
    }

</pre></div>

<p><strong><em>There are a few places can be modified.</em></strong></p>

<p>1) the outer loop, i can be changed to sqrt(n)</p>

<p>2) when count the primes in the last loop, i can be changed to i+2</p>

<p>3) the inside loop, i can be changed to i*i</p>

<p>then the changed code is below:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> countPrimes(<span class="pl-k">int</span> n) {
        <span class="pl-k">if</span>(n <span class="pl-k">&lt;=</span> <span class="pl-c1">2</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        }
        <span class="pl-k">boolean</span>[] prime <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">boolean</span>[n];
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">2</span>, sqr <span class="pl-k">=</span> (<span class="pl-k">int</span>)<span class="pl-smi">Math</span><span class="pl-k">.</span>sqrt(n); i <span class="pl-k">&lt;=</span> sqr; i<span class="pl-k">++</span> ) {
            <span class="pl-c">// if i is prime</span>
            <span class="pl-k">if</span>(<span class="pl-k">!</span>prime[i]){
                <span class="pl-k">for</span>(<span class="pl-k">int</span> j <span class="pl-k">=</span> i<span class="pl-k">*</span>i; j <span class="pl-k">&lt;</span> n; j <span class="pl-k">+=</span> i) {
                    prime[j] <span class="pl-k">=</span> <span class="pl-c1">true</span>;
                }
            }
        }
        <span class="pl-k">int</span> res <span class="pl-k">=</span> <span class="pl-c1">1</span>;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">3</span>; i <span class="pl-k">&lt;</span> n; i <span class="pl-k">+=</span> <span class="pl-c1">2</span>){
            <span class="pl-k">if</span>(<span class="pl-k">!</span>prime[i]){
                res<span class="pl-k">++</span>;
            }
        }
        <span class="pl-k">return</span> res;
    }
</pre></div>

<p>From the suggestions of friends, I realized that I can use bitset to save space.  If you are not familiar with bitset like me, check this <a href="https://docs.oracle.com/javase/7/docs/api/java/util/BitSet.html">link</a> The code is below:</p>

<div class="highlight highlight-java"><pre> <span class="pl-k">public</span> <span class="pl-k">int</span> countPrimes(<span class="pl-k">int</span> n) {
        <span class="pl-k">if</span>(n <span class="pl-k">&lt;=</span> <span class="pl-c1">2</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        }
        <span class="pl-smi">BitSet</span> set <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">BitSet</span>();
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">2</span>, sqr <span class="pl-k">=</span> (<span class="pl-k">int</span>)<span class="pl-smi">Math</span><span class="pl-k">.</span>sqrt(n); i <span class="pl-k">&lt;=</span> sqr; i<span class="pl-k">++</span> ) {
            <span class="pl-c">// if i is prime</span>
            <span class="pl-k">if</span>(<span class="pl-k">!</span>set<span class="pl-k">.</span>get(i)){
                <span class="pl-k">for</span>(<span class="pl-k">int</span> j <span class="pl-k">=</span> i<span class="pl-k">*</span>i; j <span class="pl-k">&lt;</span> n; j <span class="pl-k">+=</span> i) {
                    set<span class="pl-k">.</span>set(j);
                }
            }
        }
        set<span class="pl-k">.</span>set(<span class="pl-c1">0</span>);
        set<span class="pl-k">.</span>set(<span class="pl-c1">1</span>);
        <span class="pl-k">return</span> n <span class="pl-k">-</span> set<span class="pl-k">.</span>cardinality();
    }

</pre></div>

<p><br></p>

<p><br></p>

<h3><a id="user-content-205-isomorphic-strings" class="anchor" href="https://github.com/wishyouhappy/Algorithm#205-isomorphic-strings" aria-hidden="true"><span class="octicon octicon-link"></span></a>205 Isomorphic Strings</h3>

<blockquote>
<p>Given two strings s and t, determine if they are isomorphic.</p>

<p>Two strings are isomorphic if the characters in s can be replaced to get t.</p>

<p>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.</p>

<p>For example,</p>

<p>Given "egg", "add", return true.</p>

<p>Given "foo", "bar", return false.</p>

<p>Given "paper", "title", return true.</p>

<p>Note:
You may assume both s and t have the same length.</p>
</blockquote>

<p><strong>Idea</strong>:</p>

<ul>
<li><p>method 1: Use one hashmap, check their map relation. Since <strong>we need to use the containsvalue, it takes O(n)</strong>, thus the worst case time complexity is O(n ^ 2)</p></li>
<li><p>method 2: Use two hashmap, store the map relation of two string. Time: O(n). We need more space. </p></li>
<li><p>method 3: if we only consider Ascii, then we can use array to replace hashmap in method 2.</p></li>
</ul>

<p><strong>Java code</strong>:</p>

<p><em>Method 1</em>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">boolean</span> isIsomorphic(<span class="pl-smi">String</span> s, <span class="pl-smi">String</span> t) {
        <span class="pl-k">Map&lt;<span class="pl-smi">Character</span>, <span class="pl-smi">Character</span>&gt;</span> map <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashMap&lt;<span class="pl-smi">Character</span>, <span class="pl-smi">Character</span>&gt;</span>();
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> s<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>) {
           <span class="pl-k">char</span> cs <span class="pl-k">=</span> s<span class="pl-k">.</span>charAt(i);
           <span class="pl-k">char</span> ct <span class="pl-k">=</span> t<span class="pl-k">.</span>charAt(i);
           <span class="pl-k">if</span>(<span class="pl-k">!</span>map<span class="pl-k">.</span>containsKey(cs)) {
               <span class="pl-k">if</span>(map<span class="pl-k">.</span>containsValue(ct)) {
                   <span class="pl-k">return</span> <span class="pl-c1">false</span>;
               }
               map<span class="pl-k">.</span>put(cs, ct);
           } <span class="pl-k">else</span> {
               <span class="pl-k">if</span>(map<span class="pl-k">.</span>get(cs) <span class="pl-k">!=</span> ct) {
                   <span class="pl-k">return</span> <span class="pl-c1">false</span>;
               }
           }
        }
        <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }
</pre></div>

<p><em>Method 2</em>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">boolean</span> isIsomorphic(<span class="pl-smi">String</span> s, <span class="pl-smi">String</span> t) {
        <span class="pl-k">Map&lt;<span class="pl-smi">Character</span>, <span class="pl-smi">Character</span>&gt;</span> maps <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashMap&lt;<span class="pl-smi">Character</span>, <span class="pl-smi">Character</span>&gt;</span>();
        <span class="pl-k">Map&lt;<span class="pl-smi">Character</span>, <span class="pl-smi">Character</span>&gt;</span> mapt <span class="pl-k">=</span>  <span class="pl-k">new</span> <span class="pl-k">HashMap&lt;<span class="pl-smi">Character</span>, <span class="pl-smi">Character</span>&gt;</span>();
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> s<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>) {
           <span class="pl-k">char</span> cs <span class="pl-k">=</span> s<span class="pl-k">.</span>charAt(i);
           <span class="pl-k">char</span> ct <span class="pl-k">=</span> t<span class="pl-k">.</span>charAt(i);
           maps<span class="pl-k">.</span>putIfAbsent(cs, ct);
           mapt<span class="pl-k">.</span>putIfAbsent(ct, cs);
           <span class="pl-k">if</span>(maps<span class="pl-k">.</span>get(cs) <span class="pl-k">!=</span> ct <span class="pl-k">||</span> mapt<span class="pl-k">.</span>get(ct) <span class="pl-k">!=</span> cs) {
               <span class="pl-k">return</span> <span class="pl-c1">false</span>;
           }
        }
        <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }
</pre></div>

<p><em>Method 3</em>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">boolean</span> isIsomorphic2(<span class="pl-smi">String</span> s, <span class="pl-smi">String</span> t) {
        <span class="pl-k">int</span>[] sArr <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[<span class="pl-c1">256</span>];
        <span class="pl-k">int</span>[] tArr <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[<span class="pl-c1">256</span>];
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> s<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>) {
            <span class="pl-k">if</span>(sArr[s<span class="pl-k">.</span>charAt(i)] <span class="pl-k">!=</span> tArr[t<span class="pl-k">.</span>charAt(i)]) {
                <span class="pl-k">return</span> <span class="pl-c1">false</span>;
            }
            sArr[s<span class="pl-k">.</span>charAt(i)] <span class="pl-k">=</span> i<span class="pl-k">+</span><span class="pl-c1">1</span>;
            tArr[t<span class="pl-k">.</span>charAt(i)] <span class="pl-k">=</span> i<span class="pl-k">+</span><span class="pl-c1">1</span>;
        }
        <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-206-reverse-linked-list" class="anchor" href="https://github.com/wishyouhappy/Algorithm#206-reverse-linked-list" aria-hidden="true"><span class="octicon octicon-link"></span></a>206 Reverse Linked List</h3>

<blockquote>
<p>Reverse a singly linked list.</p>
</blockquote>

<p><strong>Idea</strong>: Really straight forward. Let the next node pointer to the previous node until to the end of the list. Just need to take care of the null pointer. 
<strong>Iterative</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-smi">ListNode</span> reverseList(<span class="pl-smi">ListNode</span> head) {
        <span class="pl-k">if</span> (head <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> head<span class="pl-k">.</span>next <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
            <span class="pl-k">return</span> head;
        }
        <span class="pl-smi">ListNode</span> pre <span class="pl-k">=</span> <span class="pl-c1">null</span>;
        <span class="pl-smi">ListNode</span> next <span class="pl-k">=</span> <span class="pl-c1">null</span>;
        <span class="pl-k">while</span> (head <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
            next <span class="pl-k">=</span> head<span class="pl-k">.</span>next;
            head<span class="pl-k">.</span>next <span class="pl-k">=</span> pre;
            pre <span class="pl-k">=</span> head;
            head <span class="pl-k">=</span> next;
        }
        <span class="pl-k">return</span> pre;
    }
</pre></div>

<p><br>
<strong>Recursive</strong>:</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-smi">ListNode</span> reverse(<span class="pl-smi">ListNode</span> head) {
    <span class="pl-k">if</span> (head <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> head<span class="pl-k">.</span>next <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span> head;
    }
    <span class="pl-smi">ListNode</span> res <span class="pl-k">=</span> reverse(head<span class="pl-k">.</span>next);
    head<span class="pl-k">.</span>next<span class="pl-k">.</span>next <span class="pl-k">=</span> head;
    head<span class="pl-k">.</span>next <span class="pl-k">=</span> <span class="pl-c1">null</span>;
    <span class="pl-k">return</span> res;
  }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-207-course-schedule" class="anchor" href="https://github.com/wishyouhappy/Algorithm#207-course-schedule" aria-hidden="true"><span class="octicon octicon-link"></span></a>207 Course Schedule</h3>

<blockquote>
<p>There are a total of n courses you have to take, labeled from 0 to n - 1.</p>

<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p>

<p>Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</p>

<p>For example:</p>

<p>2, [[1,0]]
There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.</p>

<p>2, [[1,0],[0,1]]
There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.</p>

<p>Note:
The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.</p>
</blockquote>

<p><strong>Idea</strong>: </p>

<ul>
<li><p>1) solution 1: This problem is a typical example of topological sort. We can firt create the adjacent matrix, then do topological sort to check if all courses are finished. </p></li>
<li><p>2) solution 2: For each edge we can use a stack to check if there is a cycle. If cycle exist, then we can not finish all the courses. </p></li>
</ul>

<p><strong>Java Solution</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">boolean</span> canFinish(<span class="pl-k">int</span> numCourses, <span class="pl-k">int</span>[][] prerequisites) {
        <span class="pl-k">if</span> (prerequisites <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> prerequisites<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> numCourses <span class="pl-k">&lt;=</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">true</span>;
        }
        <span class="pl-k">int</span>[][] adj <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[numCourses][numCourses];
        <span class="pl-k">int</span>[] inDegree <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[numCourses];
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> prerequisites<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
            <span class="pl-k">int</span> in <span class="pl-k">=</span> prerequisites[i][<span class="pl-c1">1</span>];
            <span class="pl-k">int</span> out <span class="pl-k">=</span> prerequisites[i][<span class="pl-c1">0</span>];
            <span class="pl-k">if</span> (adj[in][out] <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
                inDegree[out]<span class="pl-k">++</span>;
            }
            adj[in][out] <span class="pl-k">=</span> <span class="pl-c1">1</span>;
        }

        <span class="pl-k">Queue&lt;<span class="pl-smi">Integer</span>&gt;</span> zeroDegrees <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">LinkedList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> numCourses; i<span class="pl-k">++</span>) {
            <span class="pl-k">if</span> (inDegree[i] <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
                zeroDegrees<span class="pl-k">.</span>offer(i);
            }
        }

        <span class="pl-k">int</span> count <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">while</span> (<span class="pl-k">!</span>zeroDegrees<span class="pl-k">.</span>isEmpty()) {
            <span class="pl-k">int</span> temp <span class="pl-k">=</span> zeroDegrees<span class="pl-k">.</span>poll();
            count<span class="pl-k">++</span>;
            <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> numCourses; i<span class="pl-k">++</span>) {
                <span class="pl-k">if</span> (adj[temp][i] <span class="pl-k">==</span> <span class="pl-c1">1</span>) {
                    inDegree[i]<span class="pl-k">--</span>;
                    <span class="pl-k">if</span> (inDegree[i] <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
                        zeroDegrees<span class="pl-k">.</span>offer(i);
                    }
                }
            }

        }

        <span class="pl-k">return</span> count <span class="pl-k">==</span> numCourses;
    }
</pre></div>

<p><br>
<br>
<br></p>

<h3><a id="user-content-208-implement-trie-prefix-tree" class="anchor" href="https://github.com/wishyouhappy/Algorithm#208-implement-trie-prefix-tree" aria-hidden="true"><span class="octicon octicon-link"></span></a>208 Implement Trie Prefix Tree</h3>

<blockquote>
<p>Implement a trie with insert, search, and startsWith methods.</p>

<p>Note:You may assume that all inputs are consist of lowercase letters a-z.</p>
</blockquote>

<p><strong>Idea</strong>: If you are not familiar with Trie, look at my blog <a href="http://wishyouhappy.github.io/2015/05/27/Trie/">Trie</a></p>

<p><strong>Solution1</strong>: the most original and simple method</p>

<div class="highlight highlight-java"><pre><span class="pl-k">class</span> <span class="pl-en">TrieNode</span> {
    <span class="pl-c">// Initialize your data structure here.</span>
    <span class="pl-k">public</span> <span class="pl-k">TrieNode</span>[] edges;
    <span class="pl-k">public</span> <span class="pl-k">boolean</span> isLeaf; <span class="pl-c">//check if a trienode is a leaf node</span>
    <span class="pl-k">public</span> <span class="pl-en">TrieNode</span>() {
        <span class="pl-c">// all possible sons</span>
        edges <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">TrieNode</span>[<span class="pl-c1">26</span>];
    }
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Trie</span> {
    <span class="pl-k">private</span> <span class="pl-smi">TrieNode</span> root;

    <span class="pl-k">public</span> <span class="pl-en">Trie</span>() {
        root <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">TrieNode</span>();
    }

    <span class="pl-c">// Inserts a word into the trie.</span>
    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">insert</span>(<span class="pl-smi">String</span> <span class="pl-v">word</span>) {
        <span class="pl-k">if</span> (word <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> word<span class="pl-k">.</span>length() <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span>;
        }
        root <span class="pl-k">=</span> insert(root, word, <span class="pl-c1">0</span>);
    }

    <span class="pl-k">public</span> <span class="pl-smi">TrieNode</span> <span class="pl-en">insert</span>(<span class="pl-smi">TrieNode</span> <span class="pl-v">node</span>, <span class="pl-smi">String</span> <span class="pl-v">word</span>, <span class="pl-k">int</span> <span class="pl-v">len</span>) {
        <span class="pl-k">if</span> (node <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
            node <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">TrieNode</span>();
        }
        <span class="pl-k">if</span> (len <span class="pl-k">==</span> word<span class="pl-k">.</span>length()) {
            node<span class="pl-k">.</span>isLeaf <span class="pl-k">=</span> <span class="pl-c1">true</span>;
            <span class="pl-k">return</span> node;
        }
        <span class="pl-k">int</span> pos <span class="pl-k">=</span> word<span class="pl-k">.</span>charAt(len) <span class="pl-k">-</span> <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>;
        node<span class="pl-k">.</span>edges[pos] <span class="pl-k">=</span> insert(node<span class="pl-k">.</span>edges[pos], word, len <span class="pl-k">+</span> <span class="pl-c1">1</span>);
        <span class="pl-k">return</span> node;
    }

    <span class="pl-c">// Returns if the word is in the trie.</span>
    <span class="pl-k">public</span> <span class="pl-k">boolean</span> <span class="pl-en">search</span>(<span class="pl-smi">String</span> <span class="pl-v">word</span>) {
       <span class="pl-smi">TrieNode</span> temp <span class="pl-k">=</span> searchHelper(root, word, <span class="pl-c1">0</span>);
       <span class="pl-k">return</span> temp <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">?</span> <span class="pl-c1">false</span> <span class="pl-k">:</span> temp<span class="pl-k">.</span>isLeaf;    
    }

    <span class="pl-c">// Returns if there is any word in the trie</span>
    <span class="pl-c">// that starts with the given prefix.</span>
    <span class="pl-k">public</span> <span class="pl-k">boolean</span> <span class="pl-en">startsWith</span>(<span class="pl-smi">String</span> <span class="pl-v">prefix</span>) {
        <span class="pl-smi">TrieNode</span> temp <span class="pl-k">=</span> searchHelper(root, prefix, <span class="pl-c1">0</span>);
        <span class="pl-k">return</span> temp <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">?</span> <span class="pl-c1">false</span> <span class="pl-k">:</span> <span class="pl-c1">true</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">TrieNode</span> <span class="pl-en">searchHelper</span>(<span class="pl-smi">TrieNode</span> <span class="pl-v">node</span>, <span class="pl-smi">String</span> <span class="pl-v">word</span>, <span class="pl-k">int</span> <span class="pl-v">len</span>) {
        <span class="pl-k">if</span> (node <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">null</span>;
        }
        <span class="pl-k">if</span> (len <span class="pl-k">==</span> word<span class="pl-k">.</span>length()) {
            <span class="pl-k">return</span> node;
        }
        <span class="pl-k">int</span> pos <span class="pl-k">=</span> word<span class="pl-k">.</span>charAt(len) <span class="pl-k">-</span> <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>;
        <span class="pl-k">return</span> searchHelper(node<span class="pl-k">.</span>edges[pos], word, len <span class="pl-k">+</span> <span class="pl-c1">1</span>);
    }
}</pre></div>

<p><strong>Solution2</strong>: using hashmap</p>

<div class="highlight highlight-java"><pre><span class="pl-k">class</span> <span class="pl-en">TrieNode</span> {
    <span class="pl-c">// Initialize your data structure here.</span>
    <span class="pl-k">public</span> <span class="pl-k">Map&lt;<span class="pl-smi">Character</span>, <span class="pl-smi">TrieNode</span>&gt;</span> edges;
    <span class="pl-k">public</span> <span class="pl-k">boolean</span> isLeaf; <span class="pl-c">//check if a trienode is a leaf node</span>
    <span class="pl-k">public</span> <span class="pl-en">TrieNode</span>() {
        edges <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashMap&lt;<span class="pl-smi">Character</span>, <span class="pl-smi">TrieNode</span>&gt;</span>(); <span class="pl-c">// all possible sons</span>
    }
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Trie</span> {
    <span class="pl-k">private</span> <span class="pl-smi">TrieNode</span> root;

    <span class="pl-k">public</span> <span class="pl-en">Trie</span>() {
        root <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">TrieNode</span>();
    }

    <span class="pl-c">// Inserts a word into the trie.</span>
   <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">insert</span>(<span class="pl-smi">String</span> <span class="pl-v">word</span>) {
        <span class="pl-k">Map&lt;<span class="pl-smi">Character</span>, <span class="pl-smi">TrieNode</span>&gt;</span> edges <span class="pl-k">=</span> root<span class="pl-k">.</span>edges;
        <span class="pl-k">for</span>(<span class="pl-k">int</span> i<span class="pl-k">=</span><span class="pl-c1">0</span>; i<span class="pl-k">&lt;</span>word<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>){
            <span class="pl-k">char</span> c <span class="pl-k">=</span> word<span class="pl-k">.</span>charAt(i);
            <span class="pl-smi">TrieNode</span> current <span class="pl-k">=</span> <span class="pl-c1">null</span>;
            <span class="pl-k">if</span>(edges<span class="pl-k">.</span>containsKey(c)){
                current <span class="pl-k">=</span> edges<span class="pl-k">.</span>get(c);
            }<span class="pl-k">else</span>{
                current <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">TrieNode</span>();
                edges<span class="pl-k">.</span>put(c, current);
            }
            edges <span class="pl-k">=</span> current<span class="pl-k">.</span>edges;
            <span class="pl-k">if</span> (i <span class="pl-k">==</span> word<span class="pl-k">.</span>length() <span class="pl-k">-</span> <span class="pl-c1">1</span>) {
                current<span class="pl-k">.</span>isLeaf <span class="pl-k">=</span> <span class="pl-c1">true</span>;
            }
        }
    }

    <span class="pl-c">// Returns if the word is in the trie.</span>
    <span class="pl-k">public</span> <span class="pl-k">boolean</span> <span class="pl-en">search</span>(<span class="pl-smi">String</span> <span class="pl-v">word</span>) {
        <span class="pl-smi">TrieNode</span> res <span class="pl-k">=</span> searchHelper(word);
        <span class="pl-k">return</span> res <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">?</span> <span class="pl-c1">false</span> <span class="pl-k">:</span> res<span class="pl-k">.</span>isLeaf;
    }


    <span class="pl-c">// Returns if there is any word in the trie</span>
    <span class="pl-c">// that starts with the given prefix.</span>
    <span class="pl-k">public</span> <span class="pl-k">boolean</span> <span class="pl-en">startsWith</span>(<span class="pl-smi">String</span> <span class="pl-v">prefix</span>) {
       <span class="pl-smi">TrieNode</span> res <span class="pl-k">=</span> searchHelper(prefix);
       <span class="pl-k">return</span> res <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">?</span> <span class="pl-c1">false</span> <span class="pl-k">:</span> <span class="pl-c1">true</span>;
    }

    <span class="pl-k">private</span> <span class="pl-smi">TrieNode</span> <span class="pl-en">searchHelper</span>(<span class="pl-smi">String</span> <span class="pl-v">word</span>) {
        <span class="pl-k">Map&lt;<span class="pl-smi">Character</span>, <span class="pl-smi">TrieNode</span>&gt;</span> edges <span class="pl-k">=</span> root<span class="pl-k">.</span>edges;
        <span class="pl-smi">TrieNode</span> res <span class="pl-k">=</span> <span class="pl-c1">null</span>;
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> word<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>) {
            <span class="pl-k">char</span> c <span class="pl-k">=</span> word<span class="pl-k">.</span>charAt(i);
            <span class="pl-k">if</span> (edges<span class="pl-k">.</span>containsKey(c)) {
                res <span class="pl-k">=</span> edges<span class="pl-k">.</span>get(c);
                edges <span class="pl-k">=</span> res<span class="pl-k">.</span>edges;
            } <span class="pl-k">else</span> {
                <span class="pl-k">return</span> <span class="pl-c1">null</span>;
            }
        }
        <span class="pl-k">return</span> res;
    }

}</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-209-minimum-size-subarray-sum" class="anchor" href="https://github.com/wishyouhappy/Algorithm#209-minimum-size-subarray-sum" aria-hidden="true"><span class="octicon octicon-link"></span></a>209 Minimum Size Subarray Sum</h3>

<blockquote>
<p>Given an array of n positive integers and a positive integer s, find the minimal length of a subarray of which the sum ≥ s. If there isn't one, return 0 instead.</p>

<p>For example, given the array [2,3,1,2,4,3] and s = 7,
the subarray [4,3] has the minimal length under the problem constraint.<strong>Subarray should be contiguous</strong>.</p>
</blockquote>

<p><strong>More practice: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).</strong></p>

<p><strong>Idea</strong>:  </p>

<ul>
<li><p>solution 1 : Sliding window. Use two pointers to record the beginning and the end of the subarray. If current sum &gt;= s then update the min length of subarray and move the left pointer of the sliding window one step right. Otherwise, move the right pointer one step right and update the current sum. Time complexity is O(n)</p></li>
<li><p>solution 2: nlgn solution. We can use binary search obtain lgn but the array should be sorted. Since the subarray should be contiguous,
thus we shouldn't sort the array. Then how could we implement the nlgn solution? </p></li>
</ul>

<p><strong>We need to get the minimum size subarray sum, we can sum the elements before i, then we can get a sorted array and apply binary search</strong>
See details in the code below. </p>

<p><strong>Solution 1</strong>: O(n) time complexity</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> minSubArrayLen(<span class="pl-k">int</span> s, <span class="pl-k">int</span>[] nums) {
        <span class="pl-k">if</span> (nums <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> nums<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> s <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        }
        <span class="pl-k">int</span> start <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> end <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">int</span> res <span class="pl-k">=</span> <span class="pl-smi">Integer</span><span class="pl-c1"><span class="pl-k">.</span>MAX_VALUE</span>;
        <span class="pl-k">int</span> sum <span class="pl-k">=</span> nums[<span class="pl-c1">0</span>];
        <span class="pl-k">while</span> (end <span class="pl-k">&lt;</span> nums<span class="pl-k">.</span>length  <span class="pl-k">&amp;&amp;</span> start <span class="pl-k">&lt;=</span> end) {
            <span class="pl-k">if</span> (sum <span class="pl-k">&lt;</span> s) {
                end<span class="pl-k">++</span>;
                <span class="pl-k">if</span> (end <span class="pl-k">&lt;</span> nums<span class="pl-k">.</span>length) {
                    sum <span class="pl-k">+=</span> nums[end];
                }
            }
            <span class="pl-k">if</span> (sum <span class="pl-k">&gt;=</span> s) {
                res <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>min(end <span class="pl-k">-</span> start <span class="pl-k">+</span> <span class="pl-c1">1</span>, res);
                sum <span class="pl-k">-=</span> nums[start<span class="pl-k">++</span>];
            }
        }
        <span class="pl-k">return</span> res <span class="pl-k">==</span> <span class="pl-smi">Integer</span><span class="pl-c1"><span class="pl-k">.</span>MAX_VALUE</span> <span class="pl-k">?</span> <span class="pl-c1">0</span> <span class="pl-k">:</span> res;
    }</pre></div>

<p><strong>Solution 2</strong>: O(nlgn) time complexity</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span> minSubArrayLen(<span class="pl-k">int</span> s, <span class="pl-k">int</span>[] nums) {
        <span class="pl-k">if</span> (nums <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> nums<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> s <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        }
        <span class="pl-k">int</span>[] sums <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[nums<span class="pl-k">.</span>length];
        sums[<span class="pl-c1">0</span>] <span class="pl-k">=</span> nums[<span class="pl-c1">0</span>];
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;</span> nums<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
            sums[i] <span class="pl-k">=</span> sums[i<span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">+</span> nums[i];
        }
        <span class="pl-k">if</span> (sums[sums<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>] <span class="pl-k">&lt;</span> s) {
            <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        }
        <span class="pl-k">int</span> res <span class="pl-k">=</span> <span class="pl-smi">Integer</span><span class="pl-c1"><span class="pl-k">.</span>MAX_VALUE</span>;
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> nums<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
            <span class="pl-k">int</span> l <span class="pl-k">=</span> i;
            <span class="pl-k">int</span> r <span class="pl-k">=</span> nums<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>;
            <span class="pl-k">while</span> (l <span class="pl-k">&lt;=</span> r) {
                <span class="pl-k">int</span> mid <span class="pl-k">=</span> l <span class="pl-k">+</span> (r <span class="pl-k">-</span> l) <span class="pl-k">/</span> <span class="pl-c1">2</span>;
                <span class="pl-k">if</span> (sums[mid] <span class="pl-k">-</span> sums[i] <span class="pl-k">+</span> nums[i] <span class="pl-k">&gt;=</span> s) {
                    res <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>min(res, mid <span class="pl-k">-</span> i <span class="pl-k">+</span> <span class="pl-c1">1</span>);
                    r <span class="pl-k">=</span> mid <span class="pl-k">-</span> <span class="pl-c1">1</span>;
                } <span class="pl-k">else</span> {
                    l <span class="pl-k">=</span> mid <span class="pl-k">+</span> <span class="pl-c1">1</span>;
                }
            }
        }
        <span class="pl-k">return</span> res <span class="pl-k">==</span> <span class="pl-smi">Integer</span><span class="pl-c1"><span class="pl-k">.</span>MAX_VALUE</span> <span class="pl-k">?</span> <span class="pl-c1">0</span> <span class="pl-k">:</span> res;
    }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-210-course-schedule-ii" class="anchor" href="https://github.com/wishyouhappy/Algorithm#210-course-schedule-ii" aria-hidden="true"><span class="octicon octicon-link"></span></a>210 Course Schedule II</h3>

<blockquote>
<p>There are a total of n courses you have to take, labeled from 0 to n - 1.</p>
</blockquote>

<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p>

<p>Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.</p>

<p>There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.</p>

<p>For example:</p>

<p>2, [[1,0]]
There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1]</p>

<p>4, [[1,0],[2,0],[3,1],[3,2]]
There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is[0,2,1,3].</p>

<p>Note:
The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.</p>

<p><br></p>

<p><strong>Idea</strong>: same method with Course Schedule I. Use topological sort</p>

<p><strong>Accept solution</strong>: Time complexity: O(V + E)</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span>[] findOrder(<span class="pl-k">int</span> numCourses, <span class="pl-k">int</span>[][] prerequisites) {
        <span class="pl-k">if</span> (numCourses <span class="pl-k">&lt;=</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">null</span>;
        }
        <span class="pl-k">int</span>[] res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[numCourses];
        <span class="pl-k">if</span> (prerequisites <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> prerequisites<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> numCourses; i<span class="pl-k">++</span>) {
                res[i] <span class="pl-k">=</span> i;
            }
            <span class="pl-k">return</span> res;
        }
        <span class="pl-k">int</span>[] inDegree <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[numCourses];
        <span class="pl-k">Map&lt;<span class="pl-smi">Integer</span>, <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> map <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashMap&lt;<span class="pl-smi">Integer</span>, <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>();
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> prerequisites<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
            <span class="pl-k">int</span> key <span class="pl-k">=</span> prerequisites[i][<span class="pl-c1">1</span>];
            <span class="pl-k">int</span> val <span class="pl-k">=</span> prerequisites[i][<span class="pl-c1">0</span>];
            <span class="pl-k">if</span> (<span class="pl-k">!</span>map<span class="pl-k">.</span>containsKey(key)) {
               map<span class="pl-k">.</span>put(key, <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>());
            }
            map<span class="pl-k">.</span>get(key)<span class="pl-k">.</span>add(val);
            inDegree[val]<span class="pl-k">++</span>;
        }


        <span class="pl-k">Queue&lt;<span class="pl-smi">Integer</span>&gt;</span> zeroDegrees <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">LinkedList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> numCourses; i<span class="pl-k">++</span>) {
            <span class="pl-k">if</span> (inDegree[i] <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
                zeroDegrees<span class="pl-k">.</span>offer(i);
            }
        }

        <span class="pl-k">int</span> count <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">while</span> (<span class="pl-k">!</span>zeroDegrees<span class="pl-k">.</span>isEmpty()) {
            <span class="pl-k">int</span> temp <span class="pl-k">=</span> zeroDegrees<span class="pl-k">.</span>poll();
            res[count<span class="pl-k">++</span>] <span class="pl-k">=</span> temp;
            <span class="pl-k">if</span> (map<span class="pl-k">.</span>get(temp) <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
                <span class="pl-k">for</span> (<span class="pl-smi">Integer</span> i<span class="pl-k">:</span> map<span class="pl-k">.</span>get(temp)) {
                    <span class="pl-k">if</span> (inDegree[i] <span class="pl-k">&gt;=</span> <span class="pl-c1">1</span>) {
                        inDegree[i]<span class="pl-k">--</span>;
                        <span class="pl-k">if</span> (inDegree[i] <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
                            zeroDegrees<span class="pl-k">.</span>offer(i);
                        }
                    }
                }
            }
        }

        <span class="pl-k">return</span> count <span class="pl-k">==</span> numCourses <span class="pl-k">?</span> res <span class="pl-k">:</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[<span class="pl-c1">0</span>];
    }</pre></div>

<p><strong>Here is an memory limit exceeded solution</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span>[] findOrder(<span class="pl-k">int</span> numCourses, <span class="pl-k">int</span>[][] prerequisites) {
        <span class="pl-k">if</span> (numCourses <span class="pl-k">&lt;=</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">null</span>;
        }
        <span class="pl-k">int</span>[] res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[numCourses];
        <span class="pl-k">if</span> (prerequisites <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> prerequisites<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> numCourses; i<span class="pl-k">++</span>) {
                res[i] <span class="pl-k">=</span> i;
            }
            <span class="pl-k">return</span> res;
        }
        <span class="pl-k">int</span>[][] adj <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[numCourses][numCourses];
        <span class="pl-k">int</span>[] inDegree <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[numCourses];
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> prerequisites<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
            <span class="pl-k">int</span> in <span class="pl-k">=</span> prerequisites[i][<span class="pl-c1">1</span>];
            <span class="pl-k">int</span> out <span class="pl-k">=</span> prerequisites[i][<span class="pl-c1">0</span>];
            <span class="pl-k">if</span> (adj[in][out] <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
                inDegree[out]<span class="pl-k">++</span>;
            }
            adj[in][out] <span class="pl-k">=</span> <span class="pl-c1">1</span>;
        }


        <span class="pl-k">Queue&lt;<span class="pl-smi">Integer</span>&gt;</span> zeroDegrees <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">LinkedList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> numCourses; i<span class="pl-k">++</span>) {
            <span class="pl-k">if</span> (inDegree[i] <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
                zeroDegrees<span class="pl-k">.</span>offer(i);
            }
        }

        <span class="pl-k">int</span> count <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">while</span> (<span class="pl-k">!</span>zeroDegrees<span class="pl-k">.</span>isEmpty()) {
            <span class="pl-k">int</span> temp <span class="pl-k">=</span> zeroDegrees<span class="pl-k">.</span>poll();
            res[count<span class="pl-k">++</span>] <span class="pl-k">=</span> temp;

            <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> numCourses; i<span class="pl-k">++</span>) {
                <span class="pl-k">if</span> (adj[temp][i] <span class="pl-k">==</span> <span class="pl-c1">1</span>) {
                    inDegree[i]<span class="pl-k">--</span>;
                    <span class="pl-k">if</span> (inDegree[i] <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
                        zeroDegrees<span class="pl-k">.</span>offer(i);
                    }
                }
            }

        }

        <span class="pl-k">return</span> count <span class="pl-k">==</span> numCourses <span class="pl-k">?</span> res <span class="pl-k">:</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[<span class="pl-c1">0</span>];
    }</pre></div>

<h3><a id="user-content-216-combination-sum-iii" class="anchor" href="https://github.com/wishyouhappy/Algorithm#216-combination-sum-iii" aria-hidden="true"><span class="octicon octicon-link"></span></a>216 Combination Sum III</h3>

<blockquote>
<p>Find all possible combinations of k numbers that add up to a number n, given that only numbers from <strong>1 to 9</strong> can be used and each combination should be a <strong>unique set of numbers</strong>.</p>

<p>Ensure that numbers within the set are <strong>sorted in ascending order</strong>.</p>
</blockquote>

<pre>Example 1:

Input: k = 3, n = 7

Output:

[[1,2,4]]

Example 2:

Input: k = 3, n = 9

Output:

[[1,2,6], [1,3,5], [2,3,4]]

</pre>

<p><strong>Idea</strong>: This problem is the combination of <a href="https://github.com/wishyouhappy/leetcode#40-combination-sum-ii">40 Combination Sum II</a> and <a href="https://github.com/wishyouhappy/leetcode#77-combinations">77 Combinations</a>. In the recursion termination condition, we need to take care of bothe the sum and number of elements. </p>

<p><strong>Solution</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> combinationSum3(<span class="pl-k">int</span> k, <span class="pl-k">int</span> n) {
        <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>();
        <span class="pl-k">if</span> (k <span class="pl-k">*</span> <span class="pl-c1">9</span> <span class="pl-k">&lt;</span> n) {
            <span class="pl-k">return</span> res;
        }
        combinationSum3(k, n, <span class="pl-c1">1</span>, res, <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>(), <span class="pl-c1">0</span>);
        <span class="pl-k">return</span> res;
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> combinationSum3(<span class="pl-k">int</span> k, <span class="pl-k">int</span> n, <span class="pl-k">int</span> start, <span class="pl-k">List&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> res, <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> item, <span class="pl-k">int</span> sum) {
        <span class="pl-k">if</span> (item<span class="pl-k">.</span>size() <span class="pl-k">==</span> k <span class="pl-k">&amp;&amp;</span> sum <span class="pl-k">==</span> n) {
            res<span class="pl-k">.</span>add(<span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>(item));
            <span class="pl-k">return</span>;
        } 
        <span class="pl-k">if</span> (sum <span class="pl-k">&gt;=</span> n <span class="pl-k">||</span> item<span class="pl-k">.</span>size()<span class="pl-k">&gt;=</span> k) {
            <span class="pl-k">return</span>;
        }
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> start; i <span class="pl-k">&lt;=</span> <span class="pl-c1">9</span>; i<span class="pl-k">++</span>) {
            item<span class="pl-k">.</span>add(i);
            combinationSum3(k, n, i <span class="pl-k">+</span> <span class="pl-c1">1</span>, res, item, sum <span class="pl-k">+</span> i);
            item<span class="pl-k">.</span>remove(item<span class="pl-k">.</span>size() <span class="pl-k">-</span> <span class="pl-c1">1</span>);
        }

    }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-222-count-complete-tree-nodes" class="anchor" href="https://github.com/wishyouhappy/Algorithm#222-count-complete-tree-nodes" aria-hidden="true"><span class="octicon octicon-link"></span></a>222 Count Complete Tree Nodes</h3>

<blockquote>
<p>Given a complete binary tree, count the number of nodes.</p>

<p>Definition of a complete binary tree from Wikipedia:</p>

<p>In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.</p>
</blockquote>

<p><strong>Idea</strong>: </p>

<p>A O(n) solution is pretty straight forward. Here we discuss a O(logn * logn) solution</p>

<p>Look at the following picture: </p>

<p><a href="./wishyouhappy_Algorithm_files/68747470733a2f2f77697368796f7568617070792e6769746875622e696f2f70696374757265732f636f6d706c657465747265652e706e67" target="_blank"><img src="./wishyouhappy_Algorithm_files/68747470733a2f2f77697368796f7568617070792e6769746875622e696f2f70696374757265732f636f6d706c657465747265652e706e67" alt="completetree" data-canonical-src="https://wishyouhappy.github.io/pictures/completetree.png" style="max-width:100%;"></a></p>

<p>For a complete tree, it's easier to find the height of a tree or subtree. We can divide the count work into two parts. COunt the nodes in the left subtree and count the node in the right subtree, then sum them. </p>

<p>How can we determine how many nodes to add?</p>

<p>In the figure above, we can first check if height of subtree root at 2 is equal tp height of subtree rooted at 3. There are two cases:</p>

<ul>
<li><p>1) If it doesn't equal, then we know that right subtree's last level is empty. So we add 2 ^ (height of right subtree) - 1 + 1(parent). And go to the left subtree. **Note that in this case, the right subtree is full, but its height is 1 smaller than the height of the left subtree. </p></li>
<li><p>2) What if they equal, then we know that left subtree is full. So we add 2 ^ (height of left subtree) - 1 + 1(parent). And go to the right subtree. </p></li>
</ul>

<p>Let's go over the above figure. </p>

<ul>
<li><p>1) count = 0; root = 1; height(2) = 3, height(3) = 2. Thus height(2) != height(3). It's case 1, so count += 2 ^ 2 - 1 + 1 = 4. root = root.left = 2;</p></li>
<li><p>2) count = 4; root = 2, height(4) = height(5) = 2. Thus it's case 2. So count += 2 ^ 2 - 1 + 1 = 8. root = root.right = 5</p></li>
<li><p>3) count = 8; root = 5, height(1) = height(2) = 1. Thus it's case 2. So count += 2 ^ 1 - 1 + 1 = 10. root = root.right = 2</p></li>
<li><p>4) count = 10; root = 2, height(left) = height(right) = 0. It's case 2. so count += 2 ^ 0 - 1 + 1 = 11. root = root.right = null.</p></li>
<li><p>5) count = 11; root = null. Stop, return 11. </p></li>
</ul>

<p><strong>Solution</strong>:</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">int</span> countNodes(<span class="pl-smi">TreeNode</span> root) {
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
        <span class="pl-k">return</span> <span class="pl-c1">0</span>;
    }
    <span class="pl-k">int</span> res <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">int</span> h <span class="pl-k">=</span> getHeight(root);
    <span class="pl-k">while</span> (root <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
        <span class="pl-c">//if left subtree is full</span>
        <span class="pl-k">if</span> (getHeight(root<span class="pl-k">.</span>right) <span class="pl-k">==</span> h <span class="pl-k">-</span> <span class="pl-c1">1</span>) {
            res <span class="pl-k">+=</span> <span class="pl-c1">1</span> <span class="pl-k">&lt;&lt;</span> (h <span class="pl-k">-</span> <span class="pl-c1">1</span>);
            root <span class="pl-k">=</span> root<span class="pl-k">.</span>right;
        } <span class="pl-k">else</span> {
            <span class="pl-c">//if missing nodes begins at left subtree.</span>
            res <span class="pl-k">+=</span> <span class="pl-c1">1</span> <span class="pl-k">&lt;&lt;</span> (h <span class="pl-k">-</span> <span class="pl-c1">2</span>);
            root <span class="pl-k">=</span> root<span class="pl-k">.</span>left;
        }
        h<span class="pl-k">--</span>;
    }
    <span class="pl-k">return</span> res;
}
<span class="pl-k">public</span> <span class="pl-k">int</span> getHeight(<span class="pl-smi">TreeNode</span> root) {
    <span class="pl-k">return</span> root <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">?</span> <span class="pl-c1">0</span> <span class="pl-k">:</span> <span class="pl-c1">1</span> <span class="pl-k">+</span> getHeight(root<span class="pl-k">.</span>left);
}
</pre></div>

<p><br></p>

<p><strong>Related</strong>: Check if a binary tree is complete?</p>

<p><strong>Idea</strong>: Use level order traversal, once we find a node does not have both left chil and right child, then the remian nodes in the queue must be leaf node. </p>

<p><strong>Solution</strong>:</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">boolean</span> isCompleted(<span class="pl-smi">TreeNode</span> root) {
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }
    <span class="pl-k">Queue&lt;<span class="pl-smi">TreeNode</span>&gt;</span> queue <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">LinkedList&lt;<span class="pl-smi">TreeNode</span>&gt;</span>();
    queue<span class="pl-k">.</span>offer(root);
    <span class="pl-k">boolean</span> isFull <span class="pl-k">=</span> <span class="pl-c1">true</span>;
    <span class="pl-k">while</span> (<span class="pl-k">!</span>queue<span class="pl-k">.</span>isEmpty()) {
      <span class="pl-smi">TreeNode</span> cur <span class="pl-k">=</span> queue<span class="pl-k">.</span>poll();
      <span class="pl-k">if</span> (cur<span class="pl-k">.</span>left <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
        <span class="pl-k">if</span> (<span class="pl-k">!</span>isFull) {
          <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        queue<span class="pl-k">.</span>offer(cur<span class="pl-k">.</span>left);
      } <span class="pl-k">else</span> {
        isFull <span class="pl-k">=</span> <span class="pl-c1">false</span>;
      }
      <span class="pl-k">if</span> (cur<span class="pl-k">.</span>right <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
        <span class="pl-k">if</span> (<span class="pl-k">!</span>isFull) {
          <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        queue<span class="pl-k">.</span>offer(cur<span class="pl-k">.</span>right);
      } <span class="pl-k">else</span> {
        isFull <span class="pl-k">=</span> <span class="pl-c1">false</span>;
      }
    }
    <span class="pl-k">return</span> <span class="pl-c1">true</span>;
  }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-237-delete-node-in-a-linked-list" class="anchor" href="https://github.com/wishyouhappy/Algorithm#237-delete-node-in-a-linked-list" aria-hidden="true"><span class="octicon octicon-link"></span></a>237 Delete Node in a Linked List</h3>

<blockquote>
<p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p>

<p>Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4 and you are given the third node with value 3, the linked list should become 1 -&gt; 2 -&gt; 4 after calling your function.</p>
</blockquote>

<p><strong>Idea</strong>: Copy the next.val to the deleteNode.val, then point deleteNode.next = deleteNode.next.next.</p>

<p><strong>Solution</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">void</span> deleteNode(<span class="pl-smi">ListNode</span> node) {
       <span class="pl-k">if</span> (node <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
           <span class="pl-k">return</span>;
       }
       <span class="pl-smi">ListNode</span> next <span class="pl-k">=</span> node<span class="pl-k">.</span>next;
       <span class="pl-k">if</span> (next <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
           node <span class="pl-k">=</span> <span class="pl-c1">null</span>;
       }
       <span class="pl-smi">ListNode</span> nextNext <span class="pl-k">=</span> next<span class="pl-k">.</span>next;
       node<span class="pl-k">.</span>val <span class="pl-k">=</span> next<span class="pl-k">.</span>val;
       node<span class="pl-k">.</span>next <span class="pl-k">=</span> nextNext;
    }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-238-product-of-array-except-self" class="anchor" href="https://github.com/wishyouhappy/Algorithm#238-product-of-array-except-self" aria-hidden="true"><span class="octicon octicon-link"></span></a>238 Product of Array Except Self</h3>

<blockquote>
<p>Given an array of n integers where n &gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].</p>

<p>Solve it without division and in O(n).</p>

<p>For example, given [1,2,3,4], return [24,12,8,6].</p>

<p>Follow up:
Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.)</p>
</blockquote>

<p><strong>idea</strong>: O(n) space solution is pretty straightforward. </p>

<p>We first calculate the product left of A[i] except A[i], then calculate the product right of A[i] except A[i]. Then we make product of them, we can get the product of array except self.</p>

<p>What about O(1) space solution?</p>

<p>We can use a variable to record the product left of A[i] or the product right of A[i] use a variable.</p>

<p>Here is the O(1) space solution below.</p>

<p><strong>Solution</strong>: O(1) space</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">int</span>[] productExceptSelf(<span class="pl-k">int</span>[] nums) {
        <span class="pl-k">int</span>[] res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[nums<span class="pl-k">.</span>length];
        res[<span class="pl-c1">0</span>] <span class="pl-k">=</span> <span class="pl-c1">1</span>;
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;</span> nums<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
            res[i] <span class="pl-k">=</span> res[i <span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">*</span> nums[i <span class="pl-k">-</span> <span class="pl-c1">1</span>];
        }
        <span class="pl-k">int</span> pre <span class="pl-k">=</span> <span class="pl-c1">1</span>;
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> nums<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">2</span>; i <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>; i<span class="pl-k">--</span>) {
            pre <span class="pl-k">*=</span> nums[i <span class="pl-k">+</span> <span class="pl-c1">1</span>];
            res[i] <span class="pl-k">=</span> res[i] <span class="pl-k">*</span> pre;
        }
        <span class="pl-k">return</span> res;
    }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-241-different-ways-to-add-parentheses" class="anchor" href="https://github.com/wishyouhappy/Algorithm#241-different-ways-to-add-parentheses" aria-hidden="true"><span class="octicon octicon-link"></span></a>241 Different Ways to Add Parentheses</h3>

<blockquote>
<p>Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *.</p>
</blockquote>

<pre>Example 1
Input: "2-1-1".

((2-1)-1) = 0
(2-(1-1)) = 2
Output: [0, 2]


Example 2
Input: "2*3-4*5"

(2*(3-(4*5))) = -34
((2*3)-(4*5)) = -14
((2*(3-4))*5) = -10
(2*((3-4)*5)) = -10
(((2*3)-4)*5) = 10
Output: [-34, -14, -10, -10, 10]

</pre>

<p><strong>Idea</strong>: Divide and conquer. Divide the String into two parts based on the operator. We calculate the left part and right part separately, then combine the result.</p>

<p><strong>Solution 1</strong> :</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> diffWaysToCompute(<span class="pl-smi">String</span> input) {
  <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
  <span class="pl-k">if</span> (input <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> input<span class="pl-k">.</span>length() <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
      <span class="pl-k">return</span> res;
  }
  <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> input<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>) {
      <span class="pl-k">if</span> (isOperator(input<span class="pl-k">.</span>charAt(i))) {
          <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> left <span class="pl-k">=</span> diffWaysToCompute(input<span class="pl-k">.</span>substring(<span class="pl-c1">0</span>, i));
          <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> right <span class="pl-k">=</span> diffWaysToCompute(input<span class="pl-k">.</span>substring(i <span class="pl-k">+</span> <span class="pl-c1">1</span>));
          <span class="pl-k">for</span> (<span class="pl-smi">Integer</span> num1 <span class="pl-k">:</span> left) {
              <span class="pl-k">for</span> (<span class="pl-smi">Integer</span> num2 <span class="pl-k">:</span> right) {
                  res<span class="pl-k">.</span>add(input<span class="pl-k">.</span>charAt(i) <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>+<span class="pl-pds">'</span></span> <span class="pl-k">?</span> num1 <span class="pl-k">+</span> num2 <span class="pl-k">:</span> (input<span class="pl-k">.</span>charAt(i) <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>-<span class="pl-pds">'</span></span> <span class="pl-k">?</span> num1 <span class="pl-k">-</span> num2 <span class="pl-k">:</span> num1 <span class="pl-k">*</span> num2)); 
              }
          }
      }
  }
  <span class="pl-k">if</span> (res<span class="pl-k">.</span>size() <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
      res<span class="pl-k">.</span>add(<span class="pl-smi">Integer</span><span class="pl-k">.</span>parseInt(input));
  } 
  <span class="pl-k">return</span> res;
}
<span class="pl-k">private</span> <span class="pl-k">boolean</span> isOperator(<span class="pl-k">char</span> c) {
  <span class="pl-k">return</span> c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>+<span class="pl-pds">'</span></span> <span class="pl-k">||</span> c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>-<span class="pl-pds">'</span></span> <span class="pl-k">||</span> c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>*<span class="pl-pds">'</span></span>;
}
</pre></div>

<p><br>
There is some repeat operations in the above calculation. We can reduce it by store the calculated string into hashMap.</p>

<p>Here is the modified solution based on solution 1.</p>

<p><strong>Solution 2</strong>:</p>

<div class="highlight highlight-java"><pre>    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> diffWaysToCompute(<span class="pl-smi">String</span> input) {
        <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
        <span class="pl-k">if</span> (input <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> input<span class="pl-k">.</span>length() <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> res;
        }
        <span class="pl-k">Map&lt;<span class="pl-smi">String</span>, <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> map <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashMap&lt;<span class="pl-smi">String</span>, <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>();
        <span class="pl-k">return</span> diffWaysToCompute(input, map);
    }
    <span class="pl-k">private</span> <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> diffWaysToCompute(<span class="pl-smi">String</span> input, <span class="pl-k">Map&lt;<span class="pl-smi">String</span>, <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> map) {
        <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> input<span class="pl-k">.</span>length(); i<span class="pl-k">++</span>) {
            <span class="pl-k">if</span> (isOperator(input<span class="pl-k">.</span>charAt(i))) {
                <span class="pl-smi">String</span> lPart <span class="pl-k">=</span> input<span class="pl-k">.</span>substring(<span class="pl-c1">0</span>, i);
                <span class="pl-smi">String</span> rPart <span class="pl-k">=</span> input<span class="pl-k">.</span>substring(i <span class="pl-k">+</span> <span class="pl-c1">1</span>);
                <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> left <span class="pl-k">=</span> map<span class="pl-k">.</span>containsKey(lPart) <span class="pl-k">?</span> map<span class="pl-k">.</span>get(lPart) <span class="pl-k">:</span> diffWaysToCompute(lPart);
                <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> right <span class="pl-k">=</span> map<span class="pl-k">.</span>containsKey(rPart) <span class="pl-k">?</span> map<span class="pl-k">.</span>get(rPart) <span class="pl-k">:</span> diffWaysToCompute(rPart);
                map<span class="pl-k">.</span>put(lPart, left);
                map<span class="pl-k">.</span>put(rPart, right);
                <span class="pl-k">for</span> (<span class="pl-smi">Integer</span> num1 <span class="pl-k">:</span> left) {
                    <span class="pl-k">for</span> (<span class="pl-smi">Integer</span> num2 <span class="pl-k">:</span> right) {
                        res<span class="pl-k">.</span>add(input<span class="pl-k">.</span>charAt(i) <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>+<span class="pl-pds">'</span></span> <span class="pl-k">?</span> num1 <span class="pl-k">+</span> num2 <span class="pl-k">:</span> (input<span class="pl-k">.</span>charAt(i) <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>-<span class="pl-pds">'</span></span> <span class="pl-k">?</span> num1 <span class="pl-k">-</span> num2 <span class="pl-k">:</span> num1 <span class="pl-k">*</span> num2)); 
                    }
                }
            }
        }
        <span class="pl-k">if</span> (res<span class="pl-k">.</span>size() <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            res<span class="pl-k">.</span>add(<span class="pl-smi">Integer</span><span class="pl-k">.</span>parseInt(input));
        } 
        <span class="pl-k">return</span> res;
    }
    <span class="pl-k">private</span> <span class="pl-k">boolean</span> isOperator(<span class="pl-k">char</span> c) {
        <span class="pl-k">return</span> c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>+<span class="pl-pds">'</span></span> <span class="pl-k">||</span> c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>-<span class="pl-pds">'</span></span> <span class="pl-k">||</span> c <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>*<span class="pl-pds">'</span></span>;
    }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-242-valid-anagram" class="anchor" href="https://github.com/wishyouhappy/Algorithm#242-valid-anagram" aria-hidden="true"><span class="octicon octicon-link"></span></a>242 Valid Anagram</h3>

<blockquote>
<p>Given two strings s and t, write a function to determine if t is an anagram of s.</p>

<p>For example,</p>

<p>s = "anagram", t = "nagaram", return true.</p>

<p>s = "rat", t = "car", return false.</p>
</blockquote>

<p><strong>Idea</strong>:</p>

<ul>
<li><p>Solution 1 : sort two String, then compare.</p></li>
<li><p>Solution 2 : use hash table, check if two strings have the same number of each char.</p></li>
</ul>

<p><strong>Java code</strong>:</p>

<p><strong>Solution 1</strong>:</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">boolean</span> isAnagram(<span class="pl-smi">String</span> s, <span class="pl-smi">String</span> t) {
    <span class="pl-k">if</span> (s <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> t <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
        <span class="pl-k">return</span> <span class="pl-c1">false</span>;
    }
    <span class="pl-k">char</span>[] sArr <span class="pl-k">=</span> s<span class="pl-k">.</span>toCharArray();
    <span class="pl-k">char</span>[] tArr <span class="pl-k">=</span> t<span class="pl-k">.</span>toCharArray();
    <span class="pl-smi">Arrays</span><span class="pl-k">.</span>sort(sArr);
    <span class="pl-smi">Arrays</span><span class="pl-k">.</span>sort(tArr);
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-smi">String</span>(sArr)<span class="pl-k">.</span>equals(<span class="pl-k">new</span> <span class="pl-smi">String</span>(tArr));
}</pre></div>

<p><br></p>

<p><strong>Solution 2</strong>:</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">boolean</span> isAnagram(<span class="pl-smi">String</span> s, <span class="pl-smi">String</span> t) {
    <span class="pl-k">if</span> (s <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> t <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> s<span class="pl-k">.</span>length() <span class="pl-k">!=</span> t<span class="pl-k">.</span>length()) {
        <span class="pl-k">return</span> <span class="pl-c1">false</span>;
    }
    <span class="pl-k">Map&lt;<span class="pl-smi">Character</span>, <span class="pl-smi">Integer</span>&gt;</span> map <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashMap&lt;<span class="pl-smi">Character</span>, <span class="pl-smi">Integer</span>&gt;</span>();
    <span class="pl-k">char</span>[] sArr <span class="pl-k">=</span> s<span class="pl-k">.</span>toCharArray();
    <span class="pl-k">char</span>[] tArr <span class="pl-k">=</span> t<span class="pl-k">.</span>toCharArray();
    <span class="pl-k">for</span> (<span class="pl-k">char</span> c <span class="pl-k">:</span> sArr) {
        <span class="pl-smi">Integer</span> temp <span class="pl-k">=</span> map<span class="pl-k">.</span>get(c);
        <span class="pl-k">if</span> (temp <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
            map<span class="pl-k">.</span>put(c, <span class="pl-c1">1</span>);
        } <span class="pl-k">else</span> {
            map<span class="pl-k">.</span>put(c, temp <span class="pl-k">+</span> <span class="pl-c1">1</span>);
        }
    }
    <span class="pl-k">for</span> (<span class="pl-k">char</span> c <span class="pl-k">:</span> tArr) {
        <span class="pl-smi">Integer</span> temp <span class="pl-k">=</span> map<span class="pl-k">.</span>get(c);
        <span class="pl-k">if</span> (temp <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> temp <span class="pl-k">&lt;=</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        } <span class="pl-k">else</span> {
            map<span class="pl-k">.</span>put(c, temp <span class="pl-k">-</span> <span class="pl-c1">1</span>);
        }
    }
    <span class="pl-k">return</span> <span class="pl-c1">true</span>;
}</pre></div>

<p><br>
<br></p>

<h2><a id="user-content-similar-questions-from-other-sources" class="anchor" href="https://github.com/wishyouhappy/Algorithm#similar-questions-from-other-sources" aria-hidden="true"><span class="octicon octicon-link"></span></a>Similar questions from other sources.</h2>

<h3><a id="user-content-1-search-a-2d-matrix-ii" class="anchor" href="https://github.com/wishyouhappy/Algorithm#1-search-a-2d-matrix-ii" aria-hidden="true"><span class="octicon octicon-link"></span></a>1 Search a 2D Matrix II</h3>

<blockquote>
<p>Write an efficient algorithm that searches for a value in an n x m table (two-dimensional array). This table is sorted along the rows and columns — that is,</p>

<p>Integers in each row are sorted from left to right.</p>

<p>Integers in each column are sorted from up to bottom.</p>
</blockquote>

<pre>eg:


1 4 7
2 5 8
3 6 9

</pre>

<p><strong>Idea</strong>:</p>

<p><strong>Solution 1</strong>: We can use the idea in solution 1 of * <a href="https://github.com/wishyouhappy/leetcode#74-search-a-2d-matrix">74 Search a 2D Matrix</a>. We search from the upright, each time we can ignore one row or one column. Thus the overall time complexity if O(m+n)</p>

<p><strong>Solution 2</strong>: Use divide and conquer to solve this problem. For each element in the matrix,if we treat it as a center element, we can divide the matrix into 4 submatrix. There are three ways to apply partition, row-based, column-based and diagonal. </p>

<p>Considering the three cases int he following picture:</p>

<p><a href="./wishyouhappy_Algorithm_files/68747470733a2f2f77697368796f7568617070792e6769746875622e696f2f70696374757265732f6d61747269782e706e67" target="_blank"><img src="./wishyouhappy_Algorithm_files/68747470733a2f2f77697368796f7568617070792e6769746875622e696f2f70696374757265732f6d61747269782e706e67" alt="matrix" data-canonical-src="https://wishyouhappy.github.io/pictures/matrix.png" style="max-width:100%;"></a></p>

<ul>
<li><p>1) column-based: we search from the middle column,  if we need to find 10, then we first search on the hightlighted column, we find that 10 is between 6-11, then we search from the upright and bottomleft sub-matrix</p></li>
<li><p>2) row-based: we search from the middle row, if we need to find 8, then we first search on the hightlighted row, we find that 8 is between 6-10, then we search from the upright and bottomleft sub-matrix</p></li>
<li><p>3) diagonal: <strong>note that if you want to use diagonal method, the matrix need to have a square matrix</strong>. if we need to find 10, then we first search on the hightlighted column, we find that 10 is between 7-13, then we search from the upright and bottomleft sub-matrix</p></li>
</ul>

<p><strong>Solution 3</strong>: Improve the method in solution 2. We can apply binary search to three ways described above. </p>

<p>** Java Solution**:</p>

<p><strong>Solution 1</strong>: Time complexity: O(m + n)</p>

<div class="highlight highlight-java"><pre>     <span class="pl-k">public</span> <span class="pl-k">boolean</span> searchMatrix(<span class="pl-k">int</span>[][] matrix, <span class="pl-k">int</span> target) {
         <span class="pl-k">if</span> (matrix <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> matrix<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> matrix[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
             <span class="pl-k">return</span> <span class="pl-c1">false</span>;
         }
         <span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>;
         <span class="pl-k">int</span> j <span class="pl-k">=</span> matrix[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>;
         <span class="pl-k">int</span> row <span class="pl-k">=</span> matrix<span class="pl-k">.</span>length;
         <span class="pl-k">while</span>(i <span class="pl-k">&lt;</span> row <span class="pl-k">&amp;&amp;</span> j <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>) {
             <span class="pl-k">if</span> (matrix[i][j] <span class="pl-k">==</span> target) {
                 <span class="pl-k">return</span> <span class="pl-c1">true</span>;
             } <span class="pl-k">else</span> <span class="pl-k">if</span> (matrix[i][j] <span class="pl-k">&gt;</span> target) {
                 j<span class="pl-k">--</span>;
             } <span class="pl-k">else</span> {
                 i<span class="pl-k">++</span>;
             }
         }
         <span class="pl-k">return</span> <span class="pl-c1">false</span>;
     }</pre></div>

<p><strong>Solution 2</strong>: Time complexity O(nlgn)</p>

<p>1) In the code below, we apply search on the diagonal direction.<strong>matrix must be square</strong></p>

<div class="highlight highlight-java"><pre>     <span class="pl-k">public</span> <span class="pl-k">boolean</span> searchMatrix1(<span class="pl-k">int</span>[][] matrix, <span class="pl-k">int</span> target) {
         <span class="pl-k">return</span> helper(matrix, target, <span class="pl-c1">0</span>, matrix[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, matrix<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>);
     }

     <span class="pl-c">/* l r u b stands for left, right, top, bottom.*/</span> 
     <span class="pl-k">public</span> <span class="pl-k">boolean</span> searchMatrix1(<span class="pl-k">int</span>[][] matrix, <span class="pl-k">int</span> target, <span class="pl-k">int</span> l, <span class="pl-k">int</span> r, <span class="pl-k">int</span> t, <span class="pl-k">int</span> b) {
         <span class="pl-k">if</span> (l <span class="pl-k">&gt;</span> r <span class="pl-k">||</span> t <span class="pl-k">&gt;</span> b) {
             <span class="pl-k">return</span> <span class="pl-c1">false</span>;
         }
         <span class="pl-k">int</span> currentRow <span class="pl-k">=</span> t;
         <span class="pl-k">int</span> currentCol <span class="pl-k">=</span> l;
         <span class="pl-k">while</span>(currentRow <span class="pl-k">&lt;=</span> b <span class="pl-k">&amp;&amp;</span> currentCol <span class="pl-k">&lt;=</span> r <span class="pl-k">&amp;&amp;</span> matrix[currentRow][currentCol] <span class="pl-k">&lt;=</span> target) {
             <span class="pl-k">if</span> (matrix[currentRow][currentCol] <span class="pl-k">==</span> target) {
                 <span class="pl-k">return</span> <span class="pl-c1">true</span>;
             }
             currentRow<span class="pl-k">++</span>;
             currentCol<span class="pl-k">++</span>;
         }
         <span class="pl-k">return</span> helper(matrix, target, l, currentCol <span class="pl-k">-</span> <span class="pl-c1">1</span>, currentRow, b) <span class="pl-k">||</span> helper(matrix, target,currentCol, r, t, currentRow <span class="pl-k">-</span> <span class="pl-c1">1</span>);

     }
</pre></div>

<p>2) row-based</p>

<div class="highlight highlight-java"><pre>     <span class="pl-k">public</span> <span class="pl-k">boolean</span> searchMatrix(<span class="pl-k">int</span>[][] matrix, <span class="pl-k">int</span> target) {
         <span class="pl-k">return</span> helper(matrix, target, <span class="pl-c1">0</span>, matrix[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, matrix<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>);
     }

     <span class="pl-c">/* l r u b stands for left, right, top, bottom.*/</span> 
     <span class="pl-k">public</span> <span class="pl-k">boolean</span> searchMatrix(<span class="pl-k">int</span>[][] matrix, <span class="pl-k">int</span> target, <span class="pl-k">int</span> l, <span class="pl-k">int</span> r, <span class="pl-k">int</span> t, <span class="pl-k">int</span> b) {
         <span class="pl-k">if</span> (l <span class="pl-k">&gt;</span> r <span class="pl-k">||</span> t <span class="pl-k">&gt;</span> b) {
             <span class="pl-k">return</span> <span class="pl-c1">false</span>;
         }
         <span class="pl-k">int</span> midRow <span class="pl-k">=</span> t <span class="pl-k">+</span> (b <span class="pl-k">-</span> t) <span class="pl-k">/</span> <span class="pl-c1">2</span>;
         <span class="pl-k">int</span> currentCol <span class="pl-k">=</span> l;
         <span class="pl-k">while</span>(currentCol <span class="pl-k">&lt;=</span> r <span class="pl-k">&amp;&amp;</span> matrix[midRow][currentCol] <span class="pl-k">&lt;=</span> target) {
             <span class="pl-k">if</span> (matrix[midRow][currentCol] <span class="pl-k">==</span> target) {
                 <span class="pl-k">return</span> <span class="pl-c1">true</span>;
             }
             currentCol<span class="pl-k">++</span>;
         }
         <span class="pl-k">return</span> helper(matrix, target, l, currentCol <span class="pl-k">-</span> <span class="pl-c1">1</span>, midRow <span class="pl-k">+</span> <span class="pl-c1">1</span>, b) <span class="pl-k">||</span> helper(matrix, target,currentCol, r, t, midRow <span class="pl-k">-</span> <span class="pl-c1">1</span>);

     }

</pre></div>

<p><strong>Solution 3</strong>: Time complexity:O(n)</p>

<p>Take row-based as an example</p>

<div class="highlight highlight-java"><pre>     <span class="pl-k">public</span> <span class="pl-k">boolean</span> searchMatrix(<span class="pl-k">int</span>[][] matrix, <span class="pl-k">int</span> target) {
         <span class="pl-k">return</span> helper(matrix, target, <span class="pl-c1">0</span>, matrix[<span class="pl-c1">0</span>]<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, matrix<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>);
     }

     <span class="pl-c">/* l r u b stands for left, right, top, bottom.*/</span> 
     <span class="pl-k">public</span> <span class="pl-k">boolean</span> searchMatrix(<span class="pl-k">int</span>[][] matrix, <span class="pl-k">int</span> target, <span class="pl-k">int</span> l, <span class="pl-k">int</span> r, <span class="pl-k">int</span> t, <span class="pl-k">int</span> b) {
         <span class="pl-k">if</span> (l <span class="pl-k">&gt;</span> r <span class="pl-k">||</span> t <span class="pl-k">&gt;</span> b) {
             <span class="pl-k">return</span> <span class="pl-c1">false</span>;
         }
         <span class="pl-k">int</span> midRow <span class="pl-k">=</span> t <span class="pl-k">+</span> (b <span class="pl-k">-</span> t) <span class="pl-k">/</span> <span class="pl-c1">2</span>;
         <span class="pl-k">int</span> currentCol <span class="pl-k">=</span> l;
         <span class="pl-k">int</span> right <span class="pl-k">=</span> r;
         <span class="pl-k">while</span>(currentCol <span class="pl-k">&lt;=</span> r <span class="pl-k">&amp;&amp;</span> matrix[midRow][currentCol] <span class="pl-k">&lt;=</span> target) {
             <span class="pl-k">int</span> mid <span class="pl-k">=</span> currentCol <span class="pl-k">+</span> (right <span class="pl-k">-</span> currentCol) <span class="pl-k">/</span> <span class="pl-c1">2</span>;
             <span class="pl-k">if</span> (matrix[midRow][mid] <span class="pl-k">==</span> target) {
                 <span class="pl-k">return</span> <span class="pl-c1">true</span>;
             } <span class="pl-k">else</span> <span class="pl-k">if</span> (matrix[midRow][mid] <span class="pl-k">&gt;</span> target) {
                 right <span class="pl-k">=</span> mid <span class="pl-k">-</span> <span class="pl-c1">1</span>;
             } <span class="pl-k">else</span> {
                 currentCol <span class="pl-k">=</span> mid <span class="pl-k">+</span> <span class="pl-c1">1</span>;
             }
         }
         <span class="pl-k">return</span> helper(matrix, target, l, currentCol <span class="pl-k">-</span> <span class="pl-c1">1</span>, midRow <span class="pl-k">+</span> <span class="pl-c1">1</span>, b) <span class="pl-k">||</span> helper(matrix, target,currentCol, r, t, midRow <span class="pl-k">-</span> <span class="pl-c1">1</span>);

     }
</pre></div>

<h3><a id="user-content-2-first-bad-version" class="anchor" href="https://github.com/wishyouhappy/Algorithm#2-first-bad-version" aria-hidden="true"><span class="octicon octicon-link"></span></a>2 First Bad Version</h3>

<blockquote>
<p><em>From lintcode</em></p>

<p>The code base version is an integer start from 1 to n. One day, someone committed a bad version in the code case, so it caused this version and the following versions are all failed in the unit tests. Find the first bad version.</p>

<p>You can call isBadVersion to help you determine which version is the first bad one. The details interface can be found in the code's annotation part.</p>

<p>Example
Given n=5:</p>

<p>Call isBadVersion(3), get false;</p>

<p>Call isBadVersion(5), get true;</p>

<p>Call isBadVersion(4), get true;</p>

<p>Here we are 100% sure that the 4th version is the first bad version.</p>

<p>Note
Please read the annotation in code area to get the correct way to call isBadVersion in different language. For example, Java is VersionControl.isBadVersion(v)</p>

<p>Challenge
You should call isBadVersion as few as possible.</p>
</blockquote>

<p><strong>Idea</strong>: Since the bad version causes it's later version fail to the test, thus if version i is ok, then versions after i must be ok. Thus, we can use binary search to search the first bad version. </p>

<p><strong>Code</strong>:</p>

<div class="highlight highlight-java"><pre><span class="pl-c">/**</span>
<span class="pl-c"> * public class VersionControl {</span>
<span class="pl-c"> *     public static boolean isBadVersion(int k);</span>
<span class="pl-c"> * }</span>
<span class="pl-c"> * you can use VersionControl.isBadVersion(k) to judge wether </span>
<span class="pl-c"> * the kth code version is bad or not.</span>
<span class="pl-c">*/</span>
<span class="pl-k">class</span> <span class="pl-en">Solution</span> {
    <span class="pl-c">/**</span>
<span class="pl-c">     * @param n: An integers.</span>
<span class="pl-c">     * @return: An integer which is the first bad version.</span>
<span class="pl-c">     */</span>
    <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">findFirstBadVersion</span>(<span class="pl-k">int</span> <span class="pl-v">n</span>) {
        <span class="pl-c">// write your code here</span>
        <span class="pl-k">if</span> (n <span class="pl-k">&lt;=</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
        }

        <span class="pl-k">int</span> l <span class="pl-k">=</span> <span class="pl-c1">1</span>;
        <span class="pl-k">int</span> r <span class="pl-k">=</span> n;
        <span class="pl-k">while</span> (l <span class="pl-k">&lt;=</span> r) {
            <span class="pl-k">int</span> mid <span class="pl-k">=</span> l <span class="pl-k">+</span> (r <span class="pl-k">-</span> l) <span class="pl-k">/</span> <span class="pl-c1">2</span>;
            <span class="pl-k">if</span> (<span class="pl-smi">VersionControl</span><span class="pl-k">.</span>isBadVersion(mid)) {
                r <span class="pl-k">=</span> mid <span class="pl-k">-</span> <span class="pl-c1">1</span>;
            } <span class="pl-k">else</span> {
                l <span class="pl-k">=</span> mid <span class="pl-k">+</span> <span class="pl-c1">1</span>;
            }
        }
        <span class="pl-k">return</span> l;
    }

</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-3-compare-strings" class="anchor" href="https://github.com/wishyouhappy/Algorithm#3-compare-strings" aria-hidden="true"><span class="octicon octicon-link"></span></a>3 Compare Strings</h3>

<blockquote>
<p>Compare two strings A and B, determine whether A contains all of the characters in B.</p>

<p>The characters in string A and B are all Upper Case letters.</p>
</blockquote>

<pre>Example
For A = "ABCD", B = "ACD", return true.

For A = "ABCD", B = "AABC", return false.

**"ABCDE", "DB" return true**

</pre>

<p>Note
<strong>The characters of B in A are not necessary continuous or ordered.</strong></p>

<p><strong>Idea</strong>: </p>

<ul>
<li>The question does not require that the appear sequence in A and B sould be the same, thus we need fisrt sort tehe string before we compare. </li>
<li>When compare, since it does not require the characters should be continuous in A, thus for each begin index in A, we need to walk through the end to check if B exists. Here is a example solution below in O(n^2) time. </li>
</ul>

<p><strong>Solution</strong>:</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Solution</span> {
    <span class="pl-c">/**</span>
<span class="pl-c">     * @param A : A string includes Upper Case letters</span>
<span class="pl-c">     * @param B : A string includes Upper Case letter</span>
<span class="pl-c">     * @return :  if string A contains all of the characters in B return true else return false</span>
<span class="pl-c">     */</span>
    <span class="pl-k">public</span> <span class="pl-k">boolean</span> <span class="pl-en">compareStrings</span>(<span class="pl-smi">String</span> <span class="pl-smi">A</span>, <span class="pl-smi">String</span> <span class="pl-smi">B</span>) {
        <span class="pl-c">// write your code here</span>
        <span class="pl-k">if</span> (<span class="pl-smi">A</span> <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> <span class="pl-smi">B</span> <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
        <span class="pl-k">if</span> (<span class="pl-smi">B</span><span class="pl-k">.</span>length() <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">true</span>;
        }
        <span class="pl-k">char</span>[] arrA <span class="pl-k">=</span> <span class="pl-smi">A</span><span class="pl-k">.</span>toCharArray();
        <span class="pl-k">char</span>[] arrB <span class="pl-k">=</span> <span class="pl-smi">B</span><span class="pl-k">.</span>toCharArray();
        <span class="pl-smi">Arrays</span><span class="pl-k">.</span>sort(arrA);
        <span class="pl-smi">Arrays</span><span class="pl-k">.</span>sort(arrB);

        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;=</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length() <span class="pl-k">-</span> <span class="pl-smi">B</span><span class="pl-k">.</span>length(); i<span class="pl-k">++</span>) {
            <span class="pl-k">int</span> temp <span class="pl-k">=</span> <span class="pl-c1">0</span>;
            <span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>;
            <span class="pl-k">while</span> (j <span class="pl-k">&lt;</span> <span class="pl-smi">B</span><span class="pl-k">.</span>length() <span class="pl-k">&amp;&amp;</span> i <span class="pl-k">+</span> temp <span class="pl-k">&lt;</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length()) {
                <span class="pl-k">if</span> (arrA[i <span class="pl-k">+</span> temp] <span class="pl-k">==</span> arrB[j]) {
                    temp<span class="pl-k">++</span>;
                    j<span class="pl-k">++</span>;
                } <span class="pl-k">else</span> {
                    temp<span class="pl-k">++</span>;
                }
            }
            <span class="pl-k">if</span> (j <span class="pl-k">&gt;</span> <span class="pl-smi">B</span><span class="pl-k">.</span>length() <span class="pl-k">-</span> <span class="pl-c1">1</span>) {
                <span class="pl-k">return</span> <span class="pl-c1">true</span>;
            }
        }
        <span class="pl-k">return</span> <span class="pl-c1">false</span>;
    }
}</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-4-longest-common-substring" class="anchor" href="https://github.com/wishyouhappy/Algorithm#4-longest-common-substring" aria-hidden="true"><span class="octicon octicon-link"></span></a>4 Longest Common Substring</h3>

<blockquote>
<p>Given two strings, find the longest common substring. Return the length of it. From lintcode</p>

<p>Example, Given A = "ABCD", B = "CBCE", return 2.</p>
</blockquote>

<p>Note: The characters in substring should occur continuously in original string. This is different with subsequence.</p>

<p>Challenge O(n x m) time and memory.</p>

<p><strong>Idea</strong>: 
The most straight forward way to solve this problem takes O(n^3) time, we compare from the begining of two string, when not equal, update the max, move the pointer of the second string to the next character. The time complexity is bad. </p>

<p>Generally, there are two ways to solve the longest common substring problem. </p>

<ul>
<li><p>Dynamic programming</p></li>
<li><p><strong>suffix tree</strong></p></li>
</ul>

<p>Using dynamix programming we can get the result in O(m * n) time, m, n is the length of the two strings.</p>

<p>Using suffix tree we can reduce the time complexity to O(m + n). </p>

<p>Below is the solution of dynamic programming.</p>

<p>Want to know more about the solution of suffix tree, click on this two links: <a href="http://algs4.cs.princeton.edu/63suffix/LongestCommonSubstring.java.html">longest common substring</a> , <a href="http://algs4.cs.princeton.edu/63suffix/SuffixArray.java.html">suffix array</a></p>

<p><strong>Solution</strong>:</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Solution</span> {
    <span class="pl-c">/**</span>
<span class="pl-c">     * @param A, B: Two string.</span>
<span class="pl-c">     * @return: the length of the longest common substring.</span>
<span class="pl-c">     */</span>
    <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">longestCommonSubstring</span>(<span class="pl-smi">String</span> <span class="pl-smi">A</span>, <span class="pl-smi">String</span> <span class="pl-smi">B</span>) {
        <span class="pl-c">// write your code here</span>
        <span class="pl-k">if</span> (<span class="pl-smi">A</span> <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> <span class="pl-smi">B</span> <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length() <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> <span class="pl-smi">B</span><span class="pl-k">.</span>length() <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        }
        <span class="pl-k">int</span> maxLen <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(<span class="pl-smi">A</span><span class="pl-k">.</span>length(), <span class="pl-smi">B</span><span class="pl-k">.</span>length());
        <span class="pl-k">int</span>[][] dp <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[maxLen<span class="pl-k">+</span><span class="pl-c1">1</span>][maxLen<span class="pl-k">+</span><span class="pl-c1">1</span>];
        <span class="pl-k">int</span> res <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">A</span><span class="pl-k">.</span>length(); i<span class="pl-k">++</span>) {
            <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;</span> <span class="pl-smi">B</span><span class="pl-k">.</span>length(); j<span class="pl-k">++</span>) {
                <span class="pl-k">if</span> (<span class="pl-smi">A</span><span class="pl-k">.</span>charAt(i) <span class="pl-k">==</span> <span class="pl-smi">B</span><span class="pl-k">.</span>charAt(j)) {
                    dp[i<span class="pl-k">+</span><span class="pl-c1">1</span>][j<span class="pl-k">+</span><span class="pl-c1">1</span>] <span class="pl-k">=</span> dp[i][j] <span class="pl-k">+</span> <span class="pl-c1">1</span>;
                    res <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(res, dp[i<span class="pl-k">+</span><span class="pl-c1">1</span>][j<span class="pl-k">+</span><span class="pl-c1">1</span>]);
                } <span class="pl-k">else</span> {
                    dp[i][j] <span class="pl-k">=</span> <span class="pl-c1">0</span>;
                }
            }
        }
        <span class="pl-k">return</span> res;
    }
}</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-5-insert-in-sorted-linked-list" class="anchor" href="https://github.com/wishyouhappy/Algorithm#5-insert-in-sorted-linked-list" aria-hidden="true"><span class="octicon octicon-link"></span></a>5 Insert in Sorted Linked List</h3>

<p><strong>Idea</strong>: We need to find insert position, then add the element into the linkedlist</p>

<ul>
<li>1) if  head is null, return new ListNode as head</li>
<li>2) if insert value &lt;= head.value, add element at the beginning, return new added list element</li>
<li>3) find insert position, insert element </li>
</ul>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-smi">ListNode</span> insert(<span class="pl-smi">ListNode</span> head, <span class="pl-k">int</span> value) {
    <span class="pl-c">// write your solution here</span>
    <span class="pl-smi">ListNode</span> newNode <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">ListNode</span>(value);
    <span class="pl-k">if</span> (head <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      head <span class="pl-k">=</span> newNode;
      <span class="pl-k">return</span> head;
    }
    <span class="pl-c">//find insert position</span>
    <span class="pl-smi">ListNode</span> temp <span class="pl-k">=</span> head;
    <span class="pl-smi">ListNode</span> pre <span class="pl-k">=</span> <span class="pl-c1">null</span>;
    <span class="pl-k">while</span>(temp <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> temp<span class="pl-k">.</span>value <span class="pl-k">&lt;</span> value) {
      pre <span class="pl-k">=</span> temp;
      temp <span class="pl-k">=</span> temp<span class="pl-k">.</span>next;
    }
    <span class="pl-k">if</span> (head<span class="pl-k">.</span>value <span class="pl-k">&gt;=</span> value) {
      newNode<span class="pl-k">.</span>next <span class="pl-k">=</span> head;
      <span class="pl-k">return</span> newNode;
    }
    pre<span class="pl-k">.</span>next <span class="pl-k">=</span> newNode;
    newNode<span class="pl-k">.</span>next <span class="pl-k">=</span> temp;
    <span class="pl-k">return</span> head;
}</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-6-is-bipartite" class="anchor" href="https://github.com/wishyouhappy/Algorithm#6-is-bipartite" aria-hidden="true"><span class="octicon octicon-link"></span></a>6 Is Bipartite</h3>

<blockquote>
<p>Suppose a graph is repensented as list, check if this graph is bipartite. If you are not familiar with bipartite, click on this link: <a href="http://en.wikipedia.org/wiki/Bipartite_graph">bipartite</a>.</p>
</blockquote>

<p><strong>Idea</strong>: In bipartite graph, we can divide the graph into two groups and inside each group, there is no edge between nodes in that group. </p>

<p>Let's give an example, suppose group red and blue, if node 1 is in group green, if node 2 is neighbor of node 1, then node 2 must in group red. Thus we can traverse the graph to check if this condition is always true.</p>

<p><strong>Some notes</strong>:</p>

<ul>
<li><p>1) In graph traversal, unlike tree traversal, we need to record if a node is visited or not</p></li>
<li><p>2) In this problem, we also need to record the group information of each node. Let's use the above example: if node 1 is in group green, if node 2 is neighbor of node 1, then node 2 must in group red. And if node 2 has neighbor node 3, and node3 is red, then the graph is not a bipartite. </p></li>
</ul>

<p><strong>Solution</strong>:</p>

<div class="highlight highlight-java"><pre><span class="pl-c">/**</span>
<span class="pl-c"> * public class GraphNode {</span>
<span class="pl-c"> *   public int key;</span>
<span class="pl-c"> *   public List&lt;GraphNode&gt; neighbors;</span>
<span class="pl-c"> *   public GraphNode(int key) {</span>
<span class="pl-c"> *     this.key = key;</span>
<span class="pl-c"> *     this.neighbors = new ArrayList&lt;GraphNode&gt;();</span>
<span class="pl-c"> *   }</span>
<span class="pl-c"> * }</span>
<span class="pl-c"> */</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Solution</span> {
  <span class="pl-k">public</span> <span class="pl-k">boolean</span> <span class="pl-en">isBipartite</span>(<span class="pl-k">List&lt;<span class="pl-smi">GraphNode</span>&gt;</span> <span class="pl-v">graph</span>) {
    <span class="pl-k">if</span> (graph <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }
    <span class="pl-k">Map&lt;<span class="pl-smi">GraphNode</span>, <span class="pl-smi">Integer</span>&gt;</span> map <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashMap&lt;<span class="pl-smi">GraphNode</span>, <span class="pl-smi">Integer</span>&gt;</span>();
    <span class="pl-k">for</span> (<span class="pl-smi">GraphNode</span> n <span class="pl-k">:</span> graph) {
      <span class="pl-k">if</span> (map<span class="pl-k">.</span>containsKey(n)) {
        <span class="pl-k">continue</span>;
      }
      <span class="pl-k">Queue&lt;<span class="pl-smi">GraphNode</span>&gt;</span> queue <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">LinkedList&lt;<span class="pl-smi">GraphNode</span>&gt;</span>();
      queue<span class="pl-k">.</span>offer(n);
      map<span class="pl-k">.</span>put(n, <span class="pl-c1">0</span>);
      <span class="pl-k">while</span> (<span class="pl-k">!</span>queue<span class="pl-k">.</span>isEmpty()) {
        <span class="pl-smi">GraphNode</span> cur <span class="pl-k">=</span> queue<span class="pl-k">.</span>poll();
        <span class="pl-k">List&lt;<span class="pl-smi">GraphNode</span>&gt;</span> neighbors <span class="pl-k">=</span> cur<span class="pl-k">.</span>neighbors;
        <span class="pl-k">int</span> reverseColor <span class="pl-k">=</span> map<span class="pl-k">.</span>get(cur) <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">?</span> <span class="pl-c1">1</span> <span class="pl-k">:</span> <span class="pl-c1">0</span>;
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> neighbors<span class="pl-k">.</span>size(); i<span class="pl-k">++</span>){
          <span class="pl-smi">GraphNode</span> neighbor <span class="pl-k">=</span> neighbors<span class="pl-k">.</span>get(i);
          <span class="pl-k">if</span> (<span class="pl-k">!</span>map<span class="pl-k">.</span>containsKey(neighbor)) {
            map<span class="pl-k">.</span>put(neighbor, reverseColor);
            queue<span class="pl-k">.</span>offer(neighbor);
          } <span class="pl-k">else</span> <span class="pl-k">if</span> (map<span class="pl-k">.</span>get(neighbor) <span class="pl-k">!=</span> reverseColor) {
              <span class="pl-k">return</span> <span class="pl-c1">false</span>;
          }
        }
      }
    }

    <span class="pl-k">return</span> <span class="pl-c1">true</span>;
  }
}</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-7-lowest-common-ancestor" class="anchor" href="https://github.com/wishyouhappy/Algorithm#7-lowest-common-ancestor" aria-hidden="true"><span class="octicon octicon-link"></span></a>7 Lowest Common Ancestor</h3>

<blockquote>
<p>Given two nodes in a binary tree, find their lowest common ancestor.</p>
</blockquote>

<p><strong>Idea</strong>: Use recursion</p>

<p>1) base case : root == null, root == one or root == two
2) expect from left child : left child returns one or two
   expect from right child : right child returns one or two.
3) In current level: 
    a. if left child returns one or two and right child returns one or two, indicates that we have found the lowest common ancester, returns root.
    b. if one side returns one or two, return the not null one.</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-smi">TreeNode</span> lowestCommonAncestor(<span class="pl-smi">TreeNode</span> root,
      <span class="pl-smi">TreeNode</span> one, <span class="pl-smi">TreeNode</span> two) {
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span> <span class="pl-c1">null</span>;
    }
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> one <span class="pl-k">||</span> root <span class="pl-k">==</span> two) {
      <span class="pl-k">return</span> root;
    }
    <span class="pl-smi">TreeNode</span> left <span class="pl-k">=</span> lowestCommonAncestor(root<span class="pl-k">.</span>left, one, two);
    <span class="pl-smi">TreeNode</span> right <span class="pl-k">=</span> lowestCommonAncestor(root<span class="pl-k">.</span>right, one, two);
    <span class="pl-k">if</span> (left <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> right <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span> root;
    }
    <span class="pl-k">return</span> left <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">?</span> right <span class="pl-k">:</span> left;
  }</pre></div>

<p><br></p>

<p><strong>Related</strong>: What if the TreeNode has parant pointer?</p>

<p><strong>Idea</strong>: Calculate the height from root to two nodes, find the difference, then use these height to find their common ancestor.</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-smi">TreeNodeP</span> lowestCommonAncestor(<span class="pl-smi">TreeNodeP</span> one, <span class="pl-smi">TreeNodeP</span> two) {
    <span class="pl-k">int</span> heightOne <span class="pl-k">=</span> getHeight(one);
    <span class="pl-k">int</span> heightTwo <span class="pl-k">=</span> getHeight(two);
    <span class="pl-k">int</span> diff <span class="pl-k">=</span> heightOne <span class="pl-k">-</span> heightTwo;
    <span class="pl-k">return</span> diff <span class="pl-k">&lt;</span> <span class="pl-c1">0</span> <span class="pl-k">?</span> getAncestor(one, two, <span class="pl-k">-</span>diff) <span class="pl-k">:</span> getAncestor(two, one, diff);
  }

  <span class="pl-k">private</span> <span class="pl-smi">TreeNodeP</span> getAncestor(<span class="pl-smi">TreeNodeP</span> one, <span class="pl-smi">TreeNodeP</span> two, <span class="pl-k">int</span> diff) {
    <span class="pl-k">while</span> (diff <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>) {
      two <span class="pl-k">=</span> two<span class="pl-k">.</span>parent;
      diff<span class="pl-k">--</span>;
    }
    <span class="pl-k">while</span> (one <span class="pl-k">!=</span> two) {
      one <span class="pl-k">=</span> one<span class="pl-k">.</span>parent;
      two <span class="pl-k">=</span> two<span class="pl-k">.</span>parent;
    }
    <span class="pl-k">return</span> one;
  }
  <span class="pl-k">private</span> <span class="pl-k">int</span> getHeight(<span class="pl-smi">TreeNodeP</span> node) {
    <span class="pl-k">int</span> res <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">while</span> (node <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
      res<span class="pl-k">++</span>;
      node <span class="pl-k">=</span> node<span class="pl-k">.</span>parent;
    }
    <span class="pl-k">return</span> res;
  }
</pre></div>

<p><br></p>

<p><strong>Related</strong>: Lowest common ancestor of k nodes.</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-smi">TreeNode</span> lowestCommonAncestor(<span class="pl-smi">TreeNode</span> root, <span class="pl-k">List&lt;<span class="pl-smi">TreeNode</span>&gt;</span> nodes) {
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span> <span class="pl-c1">null</span>;
    }
    <span class="pl-k">for</span> (<span class="pl-smi">TreeNode</span> node <span class="pl-k">:</span> nodes) {
      <span class="pl-k">if</span> (root <span class="pl-k">==</span> node) {
        <span class="pl-k">return</span> root;
      }
    }
    <span class="pl-smi">TreeNode</span> left <span class="pl-k">=</span> lowestCommonAncestor(root<span class="pl-k">.</span>left, nodes);
    <span class="pl-smi">TreeNode</span> right <span class="pl-k">=</span> lowestCommonAncestor(root<span class="pl-k">.</span>right, nodes);
    <span class="pl-k">if</span> (left <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> right <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span> root;
    }
    <span class="pl-k">return</span> left <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">?</span> left <span class="pl-k">:</span> right;
  }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-8-median-tracker" class="anchor" href="https://github.com/wishyouhappy/Algorithm#8-median-tracker" aria-hidden="true"><span class="octicon octicon-link"></span></a>8 Median Tracker</h3>

<blockquote>
<p>Unlimited flow of numbers, return median sofar.</p>
</blockquote>

<p><strong>Idea</strong>: minHeap and maxHeap</p>

<p>minHeap stores the larger half</p>

<p>MaxHeap stores the smaller half</p>

<p>size difference of minHeap and maxHeap should &lt;= 1.</p>

<p><strong>Solution</strong>:</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">private</span> <span class="pl-k">PriorityQueue&lt;<span class="pl-smi">Integer</span>&gt;</span> minQue;
  <span class="pl-k">private</span> <span class="pl-k">PriorityQueue&lt;<span class="pl-smi">Integer</span>&gt;</span> maxQue;
  <span class="pl-k">public</span> Solution() {
    minQue <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">PriorityQueue&lt;<span class="pl-smi">Integer</span>&gt;</span>(); <span class="pl-c">// for larger half</span>
    maxQue <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">PriorityQueue&lt;<span class="pl-smi">Integer</span>&gt;</span>(<span class="pl-c1">10</span>, <span class="pl-smi">Collections</span><span class="pl-k">.</span>reverseOrder()); <span class="pl-c">// for smaller half</span>
  }

  <span class="pl-k">public</span> <span class="pl-k">void</span> read(<span class="pl-k">int</span> value) {
    <span class="pl-c">// minQue.size &gt;= maxQue.size, minQue.size - maxQue.size &lt;= 1</span>
    <span class="pl-k">if</span> (minQue<span class="pl-k">.</span>isEmpty() <span class="pl-k">||</span> value <span class="pl-k">&gt;=</span> minQue<span class="pl-k">.</span>peek()) {
      minQue<span class="pl-k">.</span>offer(value);
    } <span class="pl-k">else</span> {
      maxQue<span class="pl-k">.</span>offer(value);
    }
    <span class="pl-c">//if maxQue.size &gt; minQue.size, poll one from maxQue to minQue</span>
    <span class="pl-k">if</span> (maxQue<span class="pl-k">.</span>size() <span class="pl-k">&gt;</span> minQue<span class="pl-k">.</span>size()) {
      minQue<span class="pl-k">.</span>offer(maxQue<span class="pl-k">.</span>poll());
    } <span class="pl-k">else</span> <span class="pl-k">if</span> (minQue<span class="pl-k">.</span>size() <span class="pl-k">-</span> maxQue<span class="pl-k">.</span>size() <span class="pl-k">&gt;</span> <span class="pl-c1">1</span>) {
      maxQue<span class="pl-k">.</span>offer(minQue<span class="pl-k">.</span>poll());
    }
  }

  <span class="pl-k">public</span> <span class="pl-smi">Double</span> median() {
    <span class="pl-k">int</span> size <span class="pl-k">=</span> minQue<span class="pl-k">.</span>size() <span class="pl-k">+</span> maxQue<span class="pl-k">.</span>size();
    <span class="pl-k">if</span> (size <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
      <span class="pl-k">return</span> <span class="pl-c1">null</span>;
    } <span class="pl-k">else</span> <span class="pl-k">if</span> (size <span class="pl-k">%</span> <span class="pl-c1">2</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
      <span class="pl-k">return</span> (minQue<span class="pl-k">.</span>peek() <span class="pl-k">+</span> maxQue<span class="pl-k">.</span>peek())<span class="pl-k">/</span>(<span class="pl-k">double</span>)<span class="pl-c1">2</span>;
    } <span class="pl-k">else</span> {
      <span class="pl-k">return</span> (<span class="pl-k">double</span>)minQue<span class="pl-k">.</span>peek();
    }
  }</pre></div>

<p><br></p>

<p><br></p>

<h3><a id="user-content-9-95-percentile" class="anchor" href="https://github.com/wishyouhappy/Algorithm#9-95-percentile" aria-hidden="true"><span class="octicon octicon-link"></span></a>9 95 Percentile</h3>

<blockquote>
<p>Find 95 percentile. Suppose the maximum length  is 4096 and lengths is not null and not empty.</p>
</blockquote>

<p><strong>Idea</strong>:</p>

<p>Count sort, then find 95% or 5%.</p>

<p><strong>Solution</strong>:</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">int</span> percentile95(<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> lengths) {
    <span class="pl-k">int</span>[] arr <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[<span class="pl-c1">4097</span>];
    <span class="pl-k">for</span> (<span class="pl-smi">Integer</span> i<span class="pl-k">:</span> lengths) {
      arr[i]<span class="pl-k">++</span>;
    }
    <span class="pl-k">int</span> percentile <span class="pl-k">=</span> (<span class="pl-k">int</span>)(<span class="pl-c1">0.05</span> <span class="pl-k">*</span> lengths<span class="pl-k">.</span>size());
    <span class="pl-k">int</span> count <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">int</span> res <span class="pl-k">=</span> <span class="pl-c1">4097</span>;
    <span class="pl-k">while</span> (count <span class="pl-k">&lt;=</span> percentile) {
      count <span class="pl-k">+=</span> arr[<span class="pl-k">--</span>res];
    }
    <span class="pl-k">return</span> res;
  }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-10-perfect-shuffle" class="anchor" href="https://github.com/wishyouhappy/Algorithm#10-perfect-shuffle" aria-hidden="true"><span class="octicon octicon-link"></span></a>10 Perfect shuffle</h3>

<blockquote>
<p>shuffle the array such that all permutations are equally likely to be generated.</p>
</blockquote>

<p><strong>Idea</strong>: Random chooce a index, swap it with the current element. So the probability will be the same.</p>

<p><strong>Solution</strong>:</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">void</span> shuffle(<span class="pl-k">int</span>[] array) {
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> array<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>; i <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>; i<span class="pl-k">--</span>) {
      <span class="pl-k">int</span> random <span class="pl-k">=</span> (<span class="pl-k">int</span>) (<span class="pl-smi">Math</span><span class="pl-k">.</span>random() <span class="pl-k">*</span> (i <span class="pl-k">+</span> <span class="pl-c1">1</span>));
      swap(array, i, random);
    }
  }

  <span class="pl-k">private</span> <span class="pl-k">void</span> swap(<span class="pl-k">int</span>[] array, <span class="pl-k">int</span> i, <span class="pl-k">int</span> j) {
    <span class="pl-k">int</span> temp <span class="pl-k">=</span> array[i];
    array[i] <span class="pl-k">=</span> array[j];
    array[j] <span class="pl-k">=</span> temp;
  }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-11-reservoir-sample" class="anchor" href="https://github.com/wishyouhappy/Algorithm#11-reservoir-sample" aria-hidden="true"><span class="octicon octicon-link"></span></a>11 Reservoir sample</h3>

<blockquote>
<p>Unlimited flow, return a random number read so far.</p>
</blockquote>

<p><strong>Idea</strong>: Save it at probability 1/n.</p>

<p><strong>Solution</strong>:</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Solution</span> {
  <span class="pl-k">private</span> <span class="pl-smi">Integer</span> res;
  <span class="pl-k">private</span> <span class="pl-k">int</span> count;
  <span class="pl-k">public</span> <span class="pl-en">Solution</span>() {
    res <span class="pl-k">=</span> <span class="pl-c1">null</span>;
    count <span class="pl-k">=</span> <span class="pl-c1">0</span>;
  }

  <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">read</span>(<span class="pl-k">int</span> <span class="pl-v">value</span>) {
    count<span class="pl-k">++</span>;
    <span class="pl-k">int</span> temp <span class="pl-k">=</span> (<span class="pl-k">int</span>) (<span class="pl-smi">Math</span><span class="pl-k">.</span>random() <span class="pl-k">*</span> count);
    <span class="pl-k">if</span> (temp <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
      res <span class="pl-k">=</span> value;
    }
  }


  <span class="pl-k">public</span> <span class="pl-smi">Integer</span> <span class="pl-en">sample</span>() {
    <span class="pl-k">return</span> res;
  }
}</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-12-random7-using-random5" class="anchor" href="https://github.com/wishyouhappy/Algorithm#12-random7-using-random5" aria-hidden="true"><span class="octicon octicon-link"></span></a>12 Random7 Using Random5</h3>

<blockquote>
<p>Given random5() which generates[0, 4], implement random7().</p>
</blockquote>

<p><strong>Idea</strong>:</p>

<p>RandomFive.random5() * 5 + RandomFive.random5() generates[0, 24] in equal probability.</p>

<p>Then match to [0, 6]. We can use %, but the probability is not equal, thus we could only includes [0, 20]</p>

<p><strong>Solution</strong>:</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">int</span> random7() {
    <span class="pl-k">int</span> res <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">while</span> (<span class="pl-c1">true</span>) {
      res <span class="pl-k">=</span> <span class="pl-smi">RandomFive</span><span class="pl-k">.</span>random5() <span class="pl-k">*</span> <span class="pl-c1">5</span> <span class="pl-k">+</span> <span class="pl-smi">RandomFive</span><span class="pl-k">.</span>random5() ;
      <span class="pl-k">if</span> (res <span class="pl-k">&lt;=</span> <span class="pl-c1">20</span>) {
        <span class="pl-k">break</span>;
      } 
    }
    <span class="pl-k">return</span> res <span class="pl-k">%</span> <span class="pl-c1">7</span>;
  }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-13-random1000-using-random5" class="anchor" href="https://github.com/wishyouhappy/Algorithm#13-random1000-using-random5" aria-hidden="true"><span class="octicon octicon-link"></span></a>13 Random1000 using random5</h3>

<blockquote>
<p>Given random5() which generates[0, 4], implement random1000().</p>
</blockquote>

<p><strong>Idea</strong>:</p>

<p>Create random10() to generate [0, 9] equally, then use random10() to generate three digits of Random1000.</p>

<p><strong>Solution</strong>:</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">int</span> random1000() {
    <span class="pl-k">return</span> random10() <span class="pl-k">*</span> <span class="pl-c1">100</span> <span class="pl-k">+</span> random10() <span class="pl-k">*</span> <span class="pl-c1">10</span> <span class="pl-k">+</span> random10();
  }

  <span class="pl-k">private</span> <span class="pl-k">int</span> random10() {
    <span class="pl-k">return</span>  random2() <span class="pl-k">*</span> <span class="pl-c1">5</span> <span class="pl-k">+</span> <span class="pl-smi">RandomFive</span><span class="pl-k">.</span>random5();
  }

  <span class="pl-k">private</span> <span class="pl-k">int</span> random2() {
    <span class="pl-k">return</span> (<span class="pl-k">int</span>) (<span class="pl-smi">Math</span><span class="pl-k">.</span>random() <span class="pl-k">*</span> <span class="pl-c1">2</span>);
  }</pre></div>

<p><br></p>

<p><br></p>

<h3><a id="user-content-14-array-deduplication" class="anchor" href="https://github.com/wishyouhappy/Algorithm#14-array-deduplication" aria-hidden="true"><span class="octicon octicon-link"></span></a>14 Array deduplication</h3>

<blockquote>
<p>Deduplication in place, for each group keep only one of them.</p>
</blockquote>

<p><strong>Solution</strong>:</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">int</span>[] dedup(<span class="pl-k">int</span>[] array) {
    <span class="pl-k">if</span> (array <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> array<span class="pl-k">.</span>length <span class="pl-k">&lt;=</span> <span class="pl-c1">1</span>) {
      <span class="pl-k">return</span> array;
    }
    <span class="pl-k">int</span> l <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">int</span> r <span class="pl-k">=</span> <span class="pl-c1">1</span>;
    <span class="pl-k">while</span> (r <span class="pl-k">&lt;</span> array<span class="pl-k">.</span>length) {
      <span class="pl-k">if</span> (array[l] <span class="pl-k">!=</span> array[r]) {
        array[<span class="pl-k">++</span>l] <span class="pl-k">=</span> array[r];
      }
      r<span class="pl-k">++</span>;
    }
    <span class="pl-k">return</span> <span class="pl-smi">Arrays</span><span class="pl-k">.</span>copyOfRange(array, <span class="pl-c1">0</span>, l <span class="pl-k">+</span> <span class="pl-c1">1</span>);
  }</pre></div>

<p><br></p>

<p><strong>Related</strong>: Keep two duplicates.</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">int</span>[] dedup(<span class="pl-k">int</span>[] array) {
    <span class="pl-k">if</span> (array <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> array<span class="pl-k">.</span>length <span class="pl-k">&lt;=</span> <span class="pl-c1">2</span>) {
      <span class="pl-k">return</span> array;
    }
    <span class="pl-k">int</span> l <span class="pl-k">=</span> <span class="pl-c1">1</span>;
    <span class="pl-k">int</span> r <span class="pl-k">=</span> <span class="pl-c1">2</span>;
    <span class="pl-k">while</span> (r <span class="pl-k">&lt;</span> array<span class="pl-k">.</span>length) {
      <span class="pl-k">if</span> (array[r] <span class="pl-k">!=</span> array[l <span class="pl-k">-</span> <span class="pl-c1">1</span>]) {
        array[<span class="pl-k">++</span>l] <span class="pl-k">=</span> array[r];
      }
      r<span class="pl-k">++</span>;
    }
    <span class="pl-k">return</span> <span class="pl-smi">Arrays</span><span class="pl-k">.</span>copyOfRange(array, <span class="pl-c1">0</span>, l <span class="pl-k">+</span> <span class="pl-c1">1</span>);
  }
</pre></div>

<p><br></p>

<p><strong>Related</strong>: Keep zero.</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">int</span>[] dedup(<span class="pl-k">int</span>[] array) {
    <span class="pl-k">if</span> (array <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> array<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
      <span class="pl-k">return</span> array;
    }
    <span class="pl-k">int</span> l <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">boolean</span> isDup <span class="pl-k">=</span> <span class="pl-c1">false</span>;
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;</span> array<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
      <span class="pl-k">if</span> (array[i] <span class="pl-k">==</span> array[l]) {
        isDup <span class="pl-k">=</span> <span class="pl-c1">true</span>;
      } <span class="pl-k">else</span> <span class="pl-k">if</span> (isDup <span class="pl-k">==</span> <span class="pl-c1">true</span>) {
        array[l] <span class="pl-k">=</span> array[i];
        isDup <span class="pl-k">=</span> <span class="pl-c1">false</span>;
      } <span class="pl-k">else</span> {
        array[<span class="pl-k">++</span>l] <span class="pl-k">=</span> array[i];
      }
    }
    <span class="pl-k">return</span> isDup <span class="pl-k">?</span> <span class="pl-smi">Arrays</span><span class="pl-k">.</span>copyOfRange(array, <span class="pl-c1">0</span>, l) <span class="pl-k">:</span> <span class="pl-smi">Arrays</span><span class="pl-k">.</span>copyOfRange(array, <span class="pl-c1">0</span>, l <span class="pl-k">+</span> <span class="pl-c1">1</span>);
  }
</pre></div>

<p><strong>Related</strong>: deduplication recursive.</p>

<blockquote>
<p>For example: [1, 2, 3, 3, 3, 2, 2, 1, 2, 2] , result should be []</p>
</blockquote>

<p><strong>Solution</strong>:</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">int</span>[] dedup(<span class="pl-k">int</span>[] array) {
    <span class="pl-k">if</span> (array <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> array<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
      <span class="pl-k">return</span> array;
    }
    <span class="pl-k">int</span> l <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
   <span class="pl-k">for</span> (<span class="pl-k">int</span> r <span class="pl-k">=</span> <span class="pl-c1">0</span>; r <span class="pl-k">&lt;</span> array<span class="pl-k">.</span>length; r<span class="pl-k">++</span>) {
      <span class="pl-k">if</span> (l <span class="pl-k">==</span> <span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-k">||</span> array[r] <span class="pl-k">!=</span> array[l]) {
        array[<span class="pl-k">++</span>l] <span class="pl-k">=</span> array[r];
      } <span class="pl-k">else</span> {
        <span class="pl-k">while</span> (r <span class="pl-k">+</span> <span class="pl-c1">1</span> <span class="pl-k">&lt;</span> array<span class="pl-k">.</span>length <span class="pl-k">&amp;&amp;</span> array[r <span class="pl-k">+</span> <span class="pl-c1">1</span>] <span class="pl-k">==</span> array[l]) {
          r<span class="pl-k">++</span>;
        }
        l<span class="pl-k">--</span>;
      }
    }
    <span class="pl-k">return</span> <span class="pl-smi">Arrays</span><span class="pl-k">.</span>copyOfRange(array, <span class="pl-c1">0</span>, l <span class="pl-k">+</span> <span class="pl-c1">1</span>);
  }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-15-move-0s-to-the-end" class="anchor" href="https://github.com/wishyouhappy/Algorithm#15-move-0s-to-the-end" aria-hidden="true"><span class="octicon octicon-link"></span></a>15 Move 0s to the end</h3>

<blockquote>
<p>Move all the 0s to the right end of the array.</p>

<p>No need to keep relative order</p>
</blockquote>

<p><strong>Solution</strong>:</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">int</span>[] moveZero(<span class="pl-k">int</span>[] array) {
    <span class="pl-k">int</span> start <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">int</span> end <span class="pl-k">=</span> array<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>;
    <span class="pl-k">while</span> (start <span class="pl-k">&lt;=</span> end) {
      <span class="pl-k">if</span> (array[start] <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
        <span class="pl-k">while</span> (end <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> array[end] <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
          end<span class="pl-k">--</span>;
        }
        <span class="pl-k">if</span> (end <span class="pl-k">&lt;</span> start) {
            <span class="pl-k">break</span>;
        }
        array[start] <span class="pl-k">=</span> array[end];
        array[end] <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        end<span class="pl-k">--</span>;
      }
      start<span class="pl-k">++</span>;
    }
    <span class="pl-k">return</span> array;
  } </pre></div>

<p><br></p>

<p><strong>Related</strong>:</p>

<blockquote>
<p>Need to keep the relative order</p>
</blockquote>

<p><strong>Idea</strong>: Traverse from left, keep the relative order of non-zero element, then fill the rest to 0s.</p>

<p><strong>Solution</strong>:</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">int</span>[] moveZero(<span class="pl-k">int</span>[] array) {
    <span class="pl-k">if</span> (array <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> array<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
      <span class="pl-k">return</span> array;
    }
    <span class="pl-k">int</span> l <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">int</span> r <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">while</span> (r <span class="pl-k">&lt;</span> array<span class="pl-k">.</span>length) {
      <span class="pl-k">if</span> (array[r] <span class="pl-k">!=</span> <span class="pl-c1">0</span>) {
        array[l<span class="pl-k">++</span>] <span class="pl-k">=</span> array[r];
      }
      r<span class="pl-k">++</span>;
    }
    <span class="pl-k">while</span>(l <span class="pl-k">&lt;</span> array<span class="pl-k">.</span>length) {
      array[l<span class="pl-k">++</span>] <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    }
    <span class="pl-k">return</span> array;
  }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-16-largest-and-samllest" class="anchor" href="https://github.com/wishyouhappy/Algorithm#16-largest-and-samllest" aria-hidden="true"><span class="octicon octicon-link"></span></a>16 Largest and Samllest</h3>

<blockquote>
<p>Return the largest number and the smallest number using the smallest comparison.</p>
</blockquote>

<p><strong>Idea</strong>:</p>

<p>The most straightforward way is 2n comparing times.</p>

<p>Compare in pair, so the compare time is 3/2 * n</p>

<p><strong>Solution</strong>:</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">int</span>[] largestAndSmallest(<span class="pl-k">int</span>[] array) {
    <span class="pl-k">int</span>[] res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[<span class="pl-c1">2</span>];
    res[<span class="pl-c1">0</span>] <span class="pl-k">=</span> <span class="pl-smi">Integer</span><span class="pl-c1"><span class="pl-k">.</span>MIN_VALUE</span>;
    res[<span class="pl-c1">1</span>] <span class="pl-k">=</span> <span class="pl-smi">Integer</span><span class="pl-c1"><span class="pl-k">.</span>MAX_VALUE</span>;
    <span class="pl-k">int</span> l <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">int</span> r <span class="pl-k">=</span> array<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>;
    <span class="pl-k">while</span> (l <span class="pl-k">&lt;=</span> r) {
      <span class="pl-k">boolean</span> isSmaller <span class="pl-k">=</span> array[l] <span class="pl-k">&lt;</span> array[r];
      <span class="pl-k">if</span> (isSmaller) {
        res[<span class="pl-c1">0</span>] <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(array[r], res[<span class="pl-c1">0</span>]);
        res[<span class="pl-c1">1</span>] <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>min(array[l], res[<span class="pl-c1">1</span>]);
      } <span class="pl-k">else</span> {
        res[<span class="pl-c1">0</span>] <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>max(array[l], res[<span class="pl-c1">0</span>]);
        res[<span class="pl-c1">1</span>] <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>min(array[r], res[<span class="pl-c1">1</span>]);
      }
      l<span class="pl-k">++</span>;
      r<span class="pl-k">--</span>;
    }
    <span class="pl-k">return</span> res;
  }</pre></div>

<p><br></p>

<p><strong>Related</strong>: Largest and second largest.</p>

<blockquote>
<p>Find the largest and second largest element in least comparison.</p>
</blockquote>

<p><strong>Idea</strong>: Compare two and two, record the element that smaller then that element when compare. </p>

<p>After the first round of comparison, we get a binary tree, and the root is the largest, then we find the second largest in the list we record. </p>

<p>**Time complexity : n + log(n). </p>

<p>where n is the time complexity for two two compare, log(n) is the time complexity for find the second largest. Since the height of the tree is log(n), thus the time is log(n) to find the second largest.</p>

<p><strong>Solution</strong>:</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">int</span>[] largestAndSecond(<span class="pl-k">int</span>[] array) {
    <span class="pl-k">int</span>[] res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[<span class="pl-c1">2</span>];
    <span class="pl-k">if</span> (array <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> array<span class="pl-k">.</span>length <span class="pl-k">&lt;</span> <span class="pl-c1">2</span>) {
      <span class="pl-k">return</span> res;
    }
    <span class="pl-k">List&lt;<span class="pl-smi">Pair</span>&gt;</span> list <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Pair</span>&gt;</span>();
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> array<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
      list<span class="pl-k">.</span>add(<span class="pl-k">new</span> <span class="pl-smi">Pair</span>(i, array[i]));
    }
    <span class="pl-k">Map&lt;<span class="pl-smi">Integer</span>, <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> map <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashMap&lt;<span class="pl-smi">Integer</span>, <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>();
    <span class="pl-k">while</span> (list<span class="pl-k">.</span>size() <span class="pl-k">&gt;</span> <span class="pl-c1">1</span>) {
      <span class="pl-k">List&lt;<span class="pl-smi">Pair</span>&gt;</span> next <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Pair</span>&gt;</span>();
      <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> list<span class="pl-k">.</span>size(); i <span class="pl-k">+=</span> <span class="pl-c1">2</span>) {
        <span class="pl-k">if</span> (i <span class="pl-k">==</span> list<span class="pl-k">.</span>size() <span class="pl-k">-</span> <span class="pl-c1">1</span>) {
          next<span class="pl-k">.</span>add(list<span class="pl-k">.</span>get(i));
        } <span class="pl-k">else</span> {
          <span class="pl-smi">Pair</span> e1 <span class="pl-k">=</span> list<span class="pl-k">.</span>get(i);
          <span class="pl-smi">Pair</span> e2 <span class="pl-k">=</span> list<span class="pl-k">.</span>get(i <span class="pl-k">+</span> <span class="pl-c1">1</span>);
          <span class="pl-k">if</span> (e1<span class="pl-k">.</span>value <span class="pl-k">&lt;=</span> e2<span class="pl-k">.</span>value) {
            next<span class="pl-k">.</span>add(e2);
            <span class="pl-k">if</span> (<span class="pl-k">!</span>map<span class="pl-k">.</span>containsKey(e2<span class="pl-k">.</span>index)) {
              map<span class="pl-k">.</span>put(e2<span class="pl-k">.</span>index, <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>());
            } 
            map<span class="pl-k">.</span>get(e2<span class="pl-k">.</span>index)<span class="pl-k">.</span>add(e1<span class="pl-k">.</span>value);
          } <span class="pl-k">else</span> {
            next<span class="pl-k">.</span>add(e1);
            <span class="pl-k">if</span> (<span class="pl-k">!</span>map<span class="pl-k">.</span>containsKey(e1<span class="pl-k">.</span>index)) {
              map<span class="pl-k">.</span>put(e1<span class="pl-k">.</span>index, <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>());
            }
            map<span class="pl-k">.</span>get(e1<span class="pl-k">.</span>index)<span class="pl-k">.</span>add(e2<span class="pl-k">.</span>value);
          }
        }
      }
      list <span class="pl-k">=</span> next;
    }
    res[<span class="pl-c1">0</span>] <span class="pl-k">=</span> list<span class="pl-k">.</span>get(<span class="pl-c1">0</span>)<span class="pl-k">.</span>value;
    res[<span class="pl-c1">1</span>] <span class="pl-k">=</span> getSecondLargest(map<span class="pl-k">.</span>get(list<span class="pl-k">.</span>get(<span class="pl-c1">0</span>)<span class="pl-k">.</span>index));
    <span class="pl-k">return</span> res;
  }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-17-sort-in-specific-order" class="anchor" href="https://github.com/wishyouhappy/Algorithm#17-sort-in-specific-order" aria-hidden="true"><span class="octicon octicon-link"></span></a>17 Sort in specific order</h3>

<blockquote>
<p>Given two arrays, A1 and A2, sort A1 in such a way that the relative order among the elements will be same as those are in A2.</p>
</blockquote>

<p><strong>Idea</strong>:</p>

<p>Create an comparator, sort according the rules in comparator.</p>

<ul>
<li><p>If e1, e2 both exist in A2, then we sort them according to their indexs in A2</p></li>
<li><p>If only e1 in A2, then e1 &lt; e2</p></li>
<li><p>If only e2 in A2, then e2 &lt; e1</p></li>
<li><p>Otherwise, compare them in the natural order.</p></li>
</ul>

<p>Preprocess: We need a hashmap t record the index of each element in A2. </p>

<p><strong>Note</strong>: </p>

<ul>
<li><p>this hashmap should be <strong>final</strong>, because it needs to be used into the comparator</p></li>
<li><p>we needs to convert int[] to Integer[], because we used the Arrays.sort(), it needs a T[].</p></li>
</ul>

<p>**Time complexity: O(nlgn)</p>

<p><strong>Solution</strong>:</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">int</span>[] sortSpecial(<span class="pl-k">int</span>[] <span class="pl-c1">A1</span>, <span class="pl-k">int</span>[] <span class="pl-c1">A2</span>) {
    <span class="pl-k">if</span> (<span class="pl-c1">A1</span> <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> <span class="pl-c1">A1</span><span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
      <span class="pl-k">return</span> <span class="pl-c1">A1</span>;
    }
    <span class="pl-k">final</span> <span class="pl-k">Map&lt;<span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>&gt;</span> map <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">HashMap&lt;<span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>&gt;</span>();
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-c1">A2</span><span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
      <span class="pl-k">if</span> (<span class="pl-k">!</span>map<span class="pl-k">.</span>containsKey(<span class="pl-c1">A2</span>[i])) {
        map<span class="pl-k">.</span>put(<span class="pl-c1">A2</span>[i], i);
      }
    }
    <span class="pl-k">Comparator&lt;<span class="pl-smi">Integer</span>&gt;</span> comp <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">Comparator&lt;<span class="pl-smi">Integer</span>&gt;</span>() {
      <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">compare</span>(<span class="pl-smi">Integer</span> <span class="pl-v">arg1</span>, <span class="pl-smi">Integer</span> <span class="pl-v">arg2</span>) {
        <span class="pl-k">if</span> (map<span class="pl-k">.</span>containsKey(arg1) <span class="pl-k">&amp;&amp;</span> map<span class="pl-k">.</span>containsKey(arg2)) {
          <span class="pl-k">return</span> map<span class="pl-k">.</span>get(arg1) <span class="pl-k">-</span> map<span class="pl-k">.</span>get(arg2);
        } <span class="pl-k">else</span> <span class="pl-k">if</span> (map<span class="pl-k">.</span>containsKey(arg1)) {
          <span class="pl-k">return</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
        } <span class="pl-k">else</span> <span class="pl-k">if</span> (map<span class="pl-k">.</span>containsKey(arg2)) {
          <span class="pl-k">return</span> <span class="pl-c1">1</span>;
        } <span class="pl-k">else</span> {
          <span class="pl-k">return</span> arg1 <span class="pl-k">-</span> arg2;
        }
      }
    };
    <span class="pl-k">Integer</span>[] arr <span class="pl-k">=</span> convertToIntegerArray(<span class="pl-c1">A1</span>);
    <span class="pl-smi">Arrays</span><span class="pl-k">.</span>sort(arr, comp);
    <span class="pl-k">return</span> convertBackToIntArray(arr);
  }

  <span class="pl-k">private</span> <span class="pl-k">Integer</span>[] convertToIntegerArray(<span class="pl-k">int</span>[] arr) {
    <span class="pl-k">Integer</span>[] res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Integer</span>[arr<span class="pl-k">.</span>length];
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> arr<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
      res[i] <span class="pl-k">=</span> <span class="pl-smi">Integer</span><span class="pl-k">.</span>valueOf(arr[i]);
    }
    <span class="pl-k">return</span> res;
  }

  <span class="pl-k">private</span> <span class="pl-k">int</span>[] convertBackToIntArray(<span class="pl-k">Integer</span>[] arr) {
    <span class="pl-k">int</span>[] res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[arr<span class="pl-k">.</span>length];
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> arr<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
      res[i] <span class="pl-k">=</span> arr[i];
    }
    <span class="pl-k">return</span> res;
  }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-18-closest-number-in-binary-search-tree" class="anchor" href="https://github.com/wishyouhappy/Algorithm#18-closest-number-in-binary-search-tree" aria-hidden="true"><span class="octicon octicon-link"></span></a>18 Closest number in binary search tree</h3>

<blockquote>
<p>Given a binary search tree and a target value, return the number that is closest to target.</p>
</blockquote>

<p><strong>Solution</strong>:</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">int</span> closest(<span class="pl-smi">TreeNode</span> root, <span class="pl-k">int</span> target) {
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
    }
    <span class="pl-k">int</span> res <span class="pl-k">=</span> root<span class="pl-k">.</span>key;
    <span class="pl-k">while</span> (root <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">if</span> (<span class="pl-smi">Math</span><span class="pl-k">.</span>abs(target <span class="pl-k">-</span> root<span class="pl-k">.</span>key) <span class="pl-k">&lt;</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>abs(target <span class="pl-k">-</span> res)) {
        res <span class="pl-k">=</span> root<span class="pl-k">.</span>key;
      }
      <span class="pl-k">if</span> (target <span class="pl-k">&gt;</span> root<span class="pl-k">.</span>key) {
        root <span class="pl-k">=</span> root<span class="pl-k">.</span>right;
      } <span class="pl-k">else</span> <span class="pl-k">if</span> (target <span class="pl-k">==</span> root<span class="pl-k">.</span>key) {
        <span class="pl-k">return</span> root<span class="pl-k">.</span>key;
      } <span class="pl-k">else</span> {
        root <span class="pl-k">=</span> root<span class="pl-k">.</span>left;
      }
    }
    <span class="pl-k">return</span> res;
  }
</pre></div>

<p><br></p>

<p><strong>Related</strong>: Largest Number Smaller In Binary Search Tree</p>

<p><strong>Idea</strong>: Update result only when go to the right subtree.</p>

<p><strong>Solution</strong>:</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">int</span> largestSmaller(<span class="pl-smi">TreeNode</span> root, <span class="pl-k">int</span> target) {
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span> <span class="pl-smi">Integer</span><span class="pl-c1"><span class="pl-k">.</span>MIN_VALUE</span>;
    }
    <span class="pl-k">int</span> res <span class="pl-k">=</span> <span class="pl-smi">Integer</span><span class="pl-c1"><span class="pl-k">.</span>MIN_VALUE</span>;
    <span class="pl-k">while</span> (root <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">if</span> (target <span class="pl-k">&gt;</span> root<span class="pl-k">.</span>key) {
        res <span class="pl-k">=</span> root<span class="pl-k">.</span>key;
        root <span class="pl-k">=</span> root<span class="pl-k">.</span>right;
      } <span class="pl-k">else</span> {
        root <span class="pl-k">=</span> root<span class="pl-k">.</span>left;
      }
    }
    <span class="pl-k">return</span> res;
}
</pre></div>

<h3><a id="user-content-19-delete-in-binary-search-tree" class="anchor" href="https://github.com/wishyouhappy/Algorithm#19-delete-in-binary-search-tree" aria-hidden="true"><span class="octicon octicon-link"></span></a>19 Delete In Binary Search Tree</h3>

<blockquote>
<p>Delete a node in binary search tree.</p>
</blockquote>

<div class="highlight highlight-java"><pre></pre></div>

<p><br>
<br></p>

<h3><a id="user-content-19-delete-in-binary-search-tree-1" class="anchor" href="https://github.com/wishyouhappy/Algorithm#19-delete-in-binary-search-tree-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>19 Delete In Binary Search Tree</h3>

<blockquote>
<p>Given a binary search tree, delete a node, the structure of BST should be maintianed. Suppose there is no duplicates in the BST.</p>
</blockquote>

<p><strong>Idea</strong>: First we need to find the node we need to delete. Then there are three cases:</p>

<ul>
<li><p>Target does not has child, just delete it.</p></li>
<li><p>Target has only one child, set target.parent.left/right = child.left/right</p></li>
<li><p>Target has two children, if target.right.left == null, just set target.right.left = target.left. Otherwise, find the smallest element as the new root in target's right subtree.</p></li>
</ul>

<p><strong>Solution</strong>:</p>

<div class="highlight highlight-java"><pre><span class="pl-c">/**</span>
<span class="pl-c"> * public class TreeNode {</span>
<span class="pl-c"> *   public int key;</span>
<span class="pl-c"> *   public TreeNode left;</span>
<span class="pl-c"> *   public TreeNode right;</span>
<span class="pl-c"> *   public TreeNode(int key) {</span>
<span class="pl-c"> *     this.key = key;</span>
<span class="pl-c"> *   }</span>
<span class="pl-c"> * }</span>
<span class="pl-c"> */</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Solution</span> {
  <span class="pl-k">public</span> <span class="pl-smi">TreeNode</span> <span class="pl-en">delete</span>(<span class="pl-smi">TreeNode</span> <span class="pl-v">root</span>, <span class="pl-k">int</span> <span class="pl-v">key</span>) {
    <span class="pl-k">if</span>(root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span> <span class="pl-c1">null</span>;
    } <span class="pl-k">else</span> <span class="pl-k">if</span> (key <span class="pl-k">&lt;</span> root<span class="pl-k">.</span>key) {
      root<span class="pl-k">.</span>left <span class="pl-k">=</span> delete(root<span class="pl-k">.</span>left, key);
      <span class="pl-k">return</span> root;
    } <span class="pl-k">else</span> <span class="pl-k">if</span> (key <span class="pl-k">&gt;</span> root<span class="pl-k">.</span>key) {
      root<span class="pl-k">.</span>right <span class="pl-k">=</span> delete(root<span class="pl-k">.</span>right, key);
      <span class="pl-k">return</span> root;
    } <span class="pl-k">else</span> {
      <span class="pl-k">return</span> deleteNode(root, key);
    }
  }

  <span class="pl-k">private</span> <span class="pl-smi">TreeNode</span> <span class="pl-en">deleteNode</span>(<span class="pl-smi">TreeNode</span> <span class="pl-v">root</span>, <span class="pl-k">int</span> <span class="pl-v">key</span>) {
    <span class="pl-k">if</span> (root<span class="pl-k">.</span>left <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span> root<span class="pl-k">.</span>right;
    } <span class="pl-k">else</span> <span class="pl-k">if</span> (root<span class="pl-k">.</span>right <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span> root<span class="pl-k">.</span>left;
    } <span class="pl-k">else</span> <span class="pl-k">if</span> (root<span class="pl-k">.</span>right<span class="pl-k">.</span>left <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      root<span class="pl-k">.</span>right<span class="pl-k">.</span>left <span class="pl-k">=</span> root<span class="pl-k">.</span>left;
      <span class="pl-k">return</span> root<span class="pl-k">.</span>right;
    } <span class="pl-k">else</span> {
      <span class="pl-smi">TreeNode</span> newRoot <span class="pl-k">=</span> getNewRoot(root<span class="pl-k">.</span>right);
      newRoot<span class="pl-k">.</span>left <span class="pl-k">=</span> root<span class="pl-k">.</span>left;
      newRoot<span class="pl-k">.</span>right <span class="pl-k">=</span> root<span class="pl-k">.</span>right;
      <span class="pl-k">return</span> newRoot;
    }
  }

  <span class="pl-k">private</span> <span class="pl-smi">TreeNode</span> <span class="pl-en">getNewRoot</span>(<span class="pl-smi">TreeNode</span> <span class="pl-v">root</span>) {
    <span class="pl-smi">TreeNode</span> pre <span class="pl-k">=</span> <span class="pl-c1">null</span>;
    <span class="pl-k">while</span> (root<span class="pl-k">.</span>left <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
      pre <span class="pl-k">=</span> root;
      root <span class="pl-k">=</span> root<span class="pl-k">.</span>left;
    }
    <span class="pl-smi">TreeNode</span> res <span class="pl-k">=</span> root;
    pre<span class="pl-k">.</span>left <span class="pl-k">=</span> pre<span class="pl-k">.</span>left<span class="pl-k">.</span>right;
    <span class="pl-k">return</span> res;
  }


}
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-20-cutting-wood" class="anchor" href="https://github.com/wishyouhappy/Algorithm#20-cutting-wood" aria-hidden="true"><span class="octicon octicon-link"></span></a>20 Cutting wood</h3>

<blockquote>
<p>Cutting wood into pieces, where the cutting positions are defined in an int array A and the cost of each cut is the length of the stick segment being cut. Determine the minimum total cost to cut.</p>
</blockquote>

<p><strong>Idea</strong>:</p>

<p>Fill cuts array with start and end. For example wood length 5, cuts[] = {1, 3}, we fill it to {0, 1, 3, 5}</p>

<p>then cost[i][j] = cut[j] - cut[i] + min(cut[i][k] + cut[k][j])</p>

<p><strong>Fill it from bottom to top, left to right</strong></p>

<p>Time: o(N ^ 3)</p>

<p><strong>Solution</strong>:</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">int</span> minCost(<span class="pl-k">int</span>[] cuts, <span class="pl-k">int</span> length) {
    <span class="pl-k">int</span>[] arr <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[cuts<span class="pl-k">.</span>length <span class="pl-k">+</span> <span class="pl-c1">2</span>];
    <span class="pl-k">int</span>[][] cost <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[arr<span class="pl-k">.</span>length][arr<span class="pl-k">.</span>length];
    arr[<span class="pl-c1">0</span>] <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> cuts<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
      arr[i <span class="pl-k">+</span> <span class="pl-c1">1</span>] <span class="pl-k">=</span> cuts[i];
    }
    arr[arr<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>] <span class="pl-k">=</span> length;
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;</span> arr<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
      <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> i <span class="pl-k">-</span> <span class="pl-c1">1</span>; j <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>; j<span class="pl-k">--</span>) {
        <span class="pl-k">if</span> (j <span class="pl-k">==</span> i <span class="pl-k">-</span> <span class="pl-c1">1</span>) {
          cost[j][i] <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        } <span class="pl-k">else</span> {
          cost[j][i] <span class="pl-k">=</span> <span class="pl-smi">Integer</span><span class="pl-c1"><span class="pl-k">.</span>MAX_VALUE</span>;
          <span class="pl-k">for</span> (<span class="pl-k">int</span> k <span class="pl-k">=</span> j <span class="pl-k">+</span> <span class="pl-c1">1</span>; k <span class="pl-k">&lt;</span> i; k<span class="pl-k">++</span>) {
            cost[j][i] <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>min(cost[j][i], cost[j][k] <span class="pl-k">+</span> cost[k][i]);
          }
          cost[j][i] <span class="pl-k">+=</span> arr[i] <span class="pl-k">-</span> arr[j];
        }
      }
    }
    <span class="pl-k">return</span> cost[<span class="pl-c1">0</span>][arr<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>];
  }
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-21-merge-stone" class="anchor" href="https://github.com/wishyouhappy/Algorithm#21-merge-stone" aria-hidden="true"><span class="octicon octicon-link"></span></a>21 Merge stone</h3>

<blockquote>
<p>Give a list of piles of stones, each pile of stones has a certain weight represent as an integer array. Each time we can merge two adjacent piles into one larger pile, the cost is the sum of the weights of the two piles. Determine the minimum total cost to merge the piles of stones until we have only one pile left. </p>
</blockquote>

<p>eg : {4, 3, 3, 4}, the minimum cost is 28.</p>

<p><strong>Idea</strong>:</p>

<p>Pretty like the cutting wood. </p>

<p>induction rule:  min[j][i] = Math.min(min[j][k] + min[k + 1][i] + sum[j][i], min[j][i]);</p>

<p><strong>Solution</strong>:</p>

<div class="highlight highlight-java"><pre><span class="pl-k">public</span> <span class="pl-k">int</span> minCost(<span class="pl-k">int</span>[] stones) {
  <span class="pl-k">if</span> (stones <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> stones<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
      <span class="pl-k">return</span> <span class="pl-c1">0</span>;
  }
  <span class="pl-k">int</span>[][] min <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[stones<span class="pl-k">.</span>length][stones<span class="pl-k">.</span>length];
  <span class="pl-k">int</span>[][] sum <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">int</span>[stones<span class="pl-k">.</span>length][stones<span class="pl-k">.</span>length];
  <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> stones<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
      <span class="pl-k">for</span> (<span class="pl-k">int</span> j <span class="pl-k">=</span> i; j <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>; j<span class="pl-k">--</span>) {
          <span class="pl-k">if</span> (j <span class="pl-k">==</span> i) {
              sum[j][i] <span class="pl-k">=</span> stones[j];
              min[j][i] <span class="pl-k">=</span> <span class="pl-c1">0</span>; 
          } <span class="pl-k">else</span> {
              sum[j][i] <span class="pl-k">=</span> sum[j][i <span class="pl-k">-</span> <span class="pl-c1">1</span>] <span class="pl-k">+</span> stones[i];
              min[j][i] <span class="pl-k">=</span> <span class="pl-smi">Integer</span><span class="pl-c1"><span class="pl-k">.</span>MAX_VALUE</span>;
              <span class="pl-k">for</span> (<span class="pl-k">int</span> k <span class="pl-k">=</span> j; k <span class="pl-k">&lt;</span> i; k<span class="pl-k">++</span>) {
                  min[j][i] <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>min(min[j][k] <span class="pl-k">+</span> min[k <span class="pl-k">+</span> <span class="pl-c1">1</span>][i] <span class="pl-k">+</span> sum[j][i], min[j][i]);
              }
          }
      }
  }
  <span class="pl-k">return</span> min[<span class="pl-c1">0</span>][stones<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>];
}
</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-22-binary-tree-path-sum-to-target" class="anchor" href="https://github.com/wishyouhappy/Algorithm#22-binary-tree-path-sum-to-target" aria-hidden="true"><span class="octicon octicon-link"></span></a>22 Binary Tree Path Sum To Target</h3>

<blockquote>
<p>Binary tree, the two nodes can be the same node and they can only be on the path from root to one of the leaf nodes, from any node to any node, check if sum to target exists.</p>
</blockquote>

<p><strong>Idea</strong>: Record the prefix nodes from root of each node, each time visit a node, check if there is a path sum to target sum.</p>

<p><strong>Time complexity</strong>: if tree is balanced, O(nlogn), Worst case, O(n ^ 2).</p>

<p><strong>Solution</strong>:</p>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">boolean</span> exist(<span class="pl-smi">TreeNode</span> root, <span class="pl-k">int</span> target) {
    <span class="pl-k">return</span> exist(root, <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>(), target);
  }

  <span class="pl-k">private</span> <span class="pl-k">boolean</span> exist(<span class="pl-smi">TreeNode</span> root, <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> prefixList, <span class="pl-k">int</span> target) {
    <span class="pl-k">if</span> (root <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
      <span class="pl-k">return</span> <span class="pl-c1">false</span>;
    }
    prefixList<span class="pl-k">.</span>add(root<span class="pl-k">.</span>key);
    <span class="pl-k">if</span> (checkSum(prefixList, target)) {
      <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }
    <span class="pl-k">if</span> (exist(root<span class="pl-k">.</span>left, prefixList, target)) {
      <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }
    prefixList<span class="pl-k">.</span>remove(prefixList<span class="pl-k">.</span>size() <span class="pl-k">-</span> <span class="pl-c1">1</span>);
    prefixList<span class="pl-k">.</span>add(root<span class="pl-k">.</span>key);
    <span class="pl-k">if</span> (exist(root<span class="pl-k">.</span>right, prefixList, target)) {
      <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }
    prefixList<span class="pl-k">.</span>remove(prefixList<span class="pl-k">.</span>size() <span class="pl-k">-</span> <span class="pl-c1">1</span>);
    <span class="pl-k">return</span> <span class="pl-c1">false</span>;
  }

  <span class="pl-k">private</span> <span class="pl-k">boolean</span> checkSum(<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> prefixList, <span class="pl-k">int</span> target) {
    <span class="pl-k">int</span> sum <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> prefixList<span class="pl-k">.</span>size() <span class="pl-k">-</span> <span class="pl-c1">1</span>; i <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>; i<span class="pl-k">--</span>) {
      sum <span class="pl-k">+=</span> prefixList<span class="pl-k">.</span>get(i);
      <span class="pl-k">if</span> (sum <span class="pl-k">==</span> target) {
        <span class="pl-k">return</span> <span class="pl-c1">true</span>;
      }
    }
    <span class="pl-k">return</span> <span class="pl-c1">false</span>;
  }</pre></div>

<p><br>
<br></p>

<h3><a id="user-content-23-common-elements-in-three-sorted-array" class="anchor" href="https://github.com/wishyouhappy/Algorithm#23-common-elements-in-three-sorted-array" aria-hidden="true"><span class="octicon octicon-link"></span></a>23 Common Elements in Three Sorted Array</h3>

<blockquote>
<p>Find all common elements in 3 sorted arrays.</p>
</blockquote>

<div class="highlight highlight-java"><pre>  <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> common(<span class="pl-k">int</span>[] a, <span class="pl-k">int</span>[] b, <span class="pl-k">int</span>[] c) {
    <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> res <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Integer</span>&gt;</span>();
    <span class="pl-k">if</span> (a <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> a<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> b <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> b<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">||</span> c <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> c<span class="pl-k">.</span>length <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
      <span class="pl-k">return</span> res;
    }
    <span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">int</span> k <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">while</span> (i <span class="pl-k">&lt;</span> a<span class="pl-k">.</span>length <span class="pl-k">&amp;&amp;</span> j <span class="pl-k">&lt;</span> b<span class="pl-k">.</span>length <span class="pl-k">&amp;&amp;</span> k <span class="pl-k">&lt;</span> c<span class="pl-k">.</span>length) {
      <span class="pl-k">if</span> (a[i] <span class="pl-k">==</span> b[j] <span class="pl-k">&amp;&amp;</span> a[i] <span class="pl-k">==</span> c[k]) {
        res<span class="pl-k">.</span>add(a[i<span class="pl-k">++</span>]);
        j<span class="pl-k">++</span>;
        k<span class="pl-k">++</span>;
      } <span class="pl-k">else</span> <span class="pl-k">if</span> (a[i] <span class="pl-k">&lt;</span> b[j]) {
        i<span class="pl-k">++</span>;
      } <span class="pl-k">else</span> <span class="pl-k">if</span> (b[j] <span class="pl-k">&lt;</span> c[k]) {
        j<span class="pl-k">++</span>;
      } <span class="pl-k">else</span> {
        k<span class="pl-k">++</span>;
      }
    }
    <span class="pl-k">return</span> res;
  }</pre></div>

<pre><code>List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();
combinations(target, coins, 0, new ArrayList&lt;Integer&gt;(), res);
return res;
</code></pre>

<p>}
  private void combinations(int target, int[] coins, int index, List cur, List&gt; res) {
    if (index == coins.length - 1) {
      if (target % coins[coins.length - 1] == 0) {
        cur.add(target / coins[coins.length - 1]);
        res.add(new ArrayList(cur));
        cur.remove(cur.size() - 1);
      }
      return;
    }
    for (int i = 0, num = target/ coins[index]; i &lt;= num; i++) {
      cur.add(i);
      combinations(target - i * coins[index], coins, index + 1, cur, res);
      cur.remove(cur.size() - 1);
    }</p>
</article>
  </div>


          </div>
        </div>
        <div class="modal-backdrop"></div>
      </div>
  </div>


    </div><!-- /.wrapper -->

      <div class="container">
  <div class="site-footer" role="contentinfo">
    <ul class="site-footer-links right">
        <li><a href="https://status.github.com/" data-ga-click="Footer, go to status, text:status">Status</a></li>
      <li><a href="https://developer.github.com/" data-ga-click="Footer, go to api, text:api">API</a></li>
      <li><a href="https://training.github.com/" data-ga-click="Footer, go to training, text:training">Training</a></li>
      <li><a href="https://shop.github.com/" data-ga-click="Footer, go to shop, text:shop">Shop</a></li>
        <li><a href="https://github.com/blog" data-ga-click="Footer, go to blog, text:blog">Blog</a></li>
        <li><a href="https://github.com/about" data-ga-click="Footer, go to about, text:about">About</a></li>
        <li><a href="https://help.github.com/" data-ga-click="Footer, go to help, text:help">Help</a></li>

    </ul>

    <a href="https://github.com/" aria-label="Homepage">
      <span class="mega-octicon octicon-mark-github" title="GitHub"></span>
</a>
    <ul class="site-footer-links">
      <li>© 2015 <span title="0.06884s from github-fe125-cp1-prd.iad.github.net">GitHub</span>, Inc.</li>
        <li><a href="https://github.com/site/terms" data-ga-click="Footer, go to terms, text:terms">Terms</a></li>
        <li><a href="https://github.com/site/privacy" data-ga-click="Footer, go to privacy, text:privacy">Privacy</a></li>
        <li><a href="https://github.com/security" data-ga-click="Footer, go to security, text:security">Security</a></li>
        <li><a href="https://github.com/contact" data-ga-click="Footer, go to contact, text:contact">Contact</a></li>
    </ul>
  </div>
</div>


    <div class="fullscreen-overlay js-fullscreen-overlay" id="fullscreen_overlay">
  <div class="fullscreen-container js-suggester-container">
    <div class="textarea-wrap">
      <textarea name="fullscreen-contents" id="fullscreen-contents" class="fullscreen-contents js-fullscreen-contents" placeholder="" aria-label=""></textarea>
      <div class="suggester-container">
        <div class="suggester fullscreen-suggester js-suggester js-navigation-container"></div>
      </div>
    </div>
  </div>
  <div class="fullscreen-sidebar">
    <a href="https://github.com/wishyouhappy/Algorithm#" class="exit-fullscreen js-exit-fullscreen tooltipped tooltipped-w" aria-label="Exit Zen Mode">
      <span class="mega-octicon octicon-screen-normal"></span>
    </a>
    <a href="https://github.com/wishyouhappy/Algorithm#" class="theme-switcher js-theme-switcher tooltipped tooltipped-w" aria-label="Switch themes">
      <span class="octicon octicon-color-mode"></span>
    </a>
  </div>
</div>



    
    

    <div id="ajax-error-message" class="flash flash-error">
      <span class="octicon octicon-alert"></span>
      <a href="https://github.com/wishyouhappy/Algorithm#" class="octicon octicon-x flash-close js-ajax-error-dismiss" aria-label="Dismiss error"></a>
      Something went wrong with that request. Please try again.
    </div>


      <script crossorigin="anonymous" src="./wishyouhappy_Algorithm_files/frameworks-783bb77b540b7a2867011519a322b2b7427e8cb20e4ea9936b6868b240fccdc5.js"></script>
      <script async="async" crossorigin="anonymous" src="./wishyouhappy_Algorithm_files/index-5e7d8e39101d627e89721230a3c433b3c92a4f00a921033e5c18796310da63c2.js"></script>
      
      
  


<span style="height: 20px; width: 40px; position: absolute; opacity: 0.85; z-index: 8675309; display: none; cursor: pointer; border: none; background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAUCAYAAAD/Rn+7AAADU0lEQVR42s2WXUhTYRjHz0VEVPRFUGmtVEaFUZFhHxBhsotCU5JwBWEf1EWEEVHQx4UfFWYkFa2biPJiXbUta33OXFtuUXMzJ4bK3Nqay7m5NeZq6h/tPQ+xU20zugjOxR/+7/O8539+5znnwMtNTExwJtMb3L/fiLv3botCSmUjeCaejTOb39AiFothfHxcFIrHY8RksZjBsckJcOIRMfFsHD/SsbExUYpnI8DR0dGUGjSb0byhEJp5Uqg5CTSzc2CQleJbMEj9/ywBcGRkJEk9DQqouEVQT1sK444yWI9UonmTjGqauVLEIlHa9x8lAMbj8SSpp0rwKGMVvg8P46vbg0C7na8z8JsMcgHe7jlEa+edRhiLy8n/TUMfu6EvLElk+U0WtGwrTrdfAGQf5J8iiK4LVzDU28t8JtMSocf8E+l68myaNFXm/6rXslLK7ay5TOunuRvZWpJuvwAYjUaTpOIWoquuAZ219RTaxKYp9BbjycoN5FvL9qH9TBX5rvoGdJythvXYSTxdtRnWylO/ZdqrLsGwszzhWQ593z2KlAwCYCQSSZJ6ehZ0W7bD9VBLgN0NCqr3qR7R2rBrL3pu3Sb/7nDlz2uy6cG0OXk0GTbZXzNp8trsPAQdTj6frlWzN2DcXZGKQQAMh8NJ6rpyHe+PnkCr/CAFdZyvpfpjuvkifLF9wIt1Wwlo0OHie1RvWrKa93RjzfzliTzPKz3ltB0/Tevmwp14wGUgHAzSOoUEwFAolFaaBSuhnslPRkJexUJtZ6v5HtUeLswl33n1BgEY5fvhs9sJ3FAiT+QYyyvoAQJuD0KBAFRTJNAuz5/s3gJgMBhMJwrVFRThM5tY5zUF/A4X1f2fvQTRLCuBreoim0YmAbqNJryvPEXeeq46kaNdkQ/1HCncbJKPs9ZSv2VHGfWsZ2hfkhKAfr8/pdxWKx4wwD69PmVfNSOL+lr2w+gYqHpWDtXt1xQ8AMlWU0e1lqLd/APRHoP8AJqWrQG9gYxcPMsvSJUvAA4MDKTUJ7MZLaVy8v+qT21tcDx/OemePr0RTkNrur4A6PP5xCgBsL+/X4wiQDpuuVxOeL1eMYmYeDY6sOp0z+B0OuHxeEQhxkJMFosJiSO/UinOI/8Pc+l7KKArAT8AAAAASUVORK5CYII=); background-color: transparent;"></span></body></html>